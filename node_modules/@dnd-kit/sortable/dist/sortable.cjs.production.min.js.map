{"version":3,"file":"sortable.cjs.production.min.js","sources":["../src/utilities/arrayMove.ts","../src/utilities/isValidIndex.ts","../src/strategies/horizontalListSorting.ts","../src/strategies/rectSorting.ts","../src/strategies/verticalListSorting.ts","../src/components/SortableContext.tsx","../src/hooks/defaults.ts","../src/sensors/keyboard/sortableKeyboardCoordinates.ts","../src/utilities/getSortedRects.ts","../src/strategies/rectSwapping.ts","../src/hooks/useSortable.ts","../src/hooks/utilities/useDerivedTransform.ts"],"sourcesContent":["/**\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\n */\nexport function arrayMove<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n  newArray.splice(\n    to < 0 ? newArray.length + to : to,\n    0,\n    newArray.splice(from, 1)[0]\n  );\n\n  return newArray;\n}\n","export function isValidIndex(index: number | null): index is number {\n  return index !== null && index >= 0;\n}\n","import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const horizontalListSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = layoutRects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x:\n        activeIndex < overIndex\n          ? newIndexRect.offsetLeft +\n            newIndexRect.width -\n            (activeNodeRect.offsetLeft + activeNodeRect.width)\n          : newIndexRect.offsetLeft - activeNodeRect.offsetLeft,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n\n  if (!previousRect && !nextRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width)\n      : nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width);\n  }\n\n  return nextRect\n    ? nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width)\n    : currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width);\n}\n","import {arrayMove} from '../utilities';\nimport type {SortingStrategy} from '../types';\n\nexport const rectSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const newRects = arrayMove(layoutRects, overIndex, activeIndex);\n\n  const oldRect = layoutRects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const verticalListSortingStrategy: SortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = layoutRects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y:\n        activeIndex < overIndex\n          ? overIndexRect.offsetTop +\n            overIndexRect.height -\n            (activeNodeRect.offsetTop + activeNodeRect.height)\n          : overIndexRect.offsetTop - activeNodeRect.offsetTop,\n      ...defaultScale,\n    };\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect = layoutRects[index];\n  const previousRect = layoutRects[index - 1];\n  const nextRect = layoutRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n      : nextRect\n      ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n      : 0;\n  }\n\n  return nextRect\n    ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n    : previousRect\n    ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n    : 0;\n}\n","import React, {MutableRefObject, useEffect, useMemo, useRef} from 'react';\nimport {useDndContext, LayoutRect, UniqueIdentifier} from '@dnd-kit/core';\nimport {useIsomorphicLayoutEffect, useUniqueId} from '@dnd-kit/utilities';\n\nimport type {SortingStrategy} from '../types';\nimport {getSortedRects} from '../utilities';\nimport {rectSortingStrategy} from '../strategies';\n\nexport interface Props {\n  children: React.ReactNode;\n  items: UniqueIdentifier[];\n  strategy?: SortingStrategy;\n  id?: string;\n}\n\nconst ID_PREFIX = 'Sortable';\n\ninterface ContextDescriptor {\n  activeIndex: number;\n  containerId: string;\n  disableTransforms: boolean;\n  items: UniqueIdentifier[];\n  overIndex: number;\n  useDragOverlay: boolean;\n  sortedRects: LayoutRect[];\n  strategy: SortingStrategy;\n  wasSorting: MutableRefObject<boolean>;\n}\n\nexport const Context = React.createContext<ContextDescriptor>({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  wasSorting: {current: false},\n});\n\nexport function SortableContext({\n  children,\n  id,\n  items,\n  strategy = rectSortingStrategy,\n}: Props) {\n  const {\n    active,\n    overlayNode,\n    droppableRects,\n    over,\n    recomputeLayouts,\n    willRecomputeLayouts,\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(overlayNode.rect !== null);\n  const activeIndex = active ? items.indexOf(active) : -1;\n  const isSorting = activeIndex !== -1;\n  const wasSorting = useRef(isSorting);\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const sortedRects = getSortedRects(items, droppableRects);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms =\n    (overIndex !== -1 && activeIndex === -1) || itemsHaveChanged;\n\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {\n      // To-do: Add partial recompution of only subset of rects\n      recomputeLayouts();\n    }\n  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);\n\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n\n  useEffect(() => {\n    requestAnimationFrame(() => {\n      wasSorting.current = isSorting;\n    });\n  }, [isSorting]);\n\n  const contextValue = useMemo(\n    (): ContextDescriptor => ({\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      useDragOverlay,\n      sortedRects,\n      strategy,\n      wasSorting,\n    }),\n    [\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      sortedRects,\n      useDragOverlay,\n      strategy,\n      wasSorting,\n    ]\n  );\n\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>;\n}\n\nfunction isEqual(arr1: string[], arr2: string[]) {\n  return arr1.join() === arr2.join();\n}\n","import {CSS} from '@dnd-kit/utilities';\n\nimport type {AnimateLayoutChanges, SortableTransition} from './types';\n\nexport const defaultAnimateLayoutChanges: AnimateLayoutChanges = ({\n  isSorting,\n  index,\n  newIndex,\n  transition,\n}) => {\n  if (!transition) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index;\n};\n\nexport const defaultTransition: SortableTransition = {\n  duration: 200,\n  easing: 'ease',\n};\n\nexport const transitionProperty = 'transform';\n\nexport const disabledTransition = CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear',\n});\n\nexport const defaultAttributes = {\n  roleDescription: 'sortable',\n};\n","import {\n  closestCorners,\n  getViewRect,\n  getScrollableAncestors,\n  KeyboardCode,\n  RectEntry,\n  KeyboardCoordinateGetter,\n} from '@dnd-kit/core';\n\nconst directions: string[] = [\n  KeyboardCode.Down,\n  KeyboardCode.Right,\n  KeyboardCode.Up,\n  KeyboardCode.Left,\n];\n\nexport const sortableKeyboardCoordinates: KeyboardCoordinateGetter = (\n  event,\n  {context: {droppableContainers, translatedRect, scrollableAncestors}}\n) => {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!translatedRect) {\n      return;\n    }\n\n    const layoutRects: RectEntry[] = [];\n\n    Object.entries(droppableContainers).forEach(([id, container]) => {\n      if (container?.disabled) {\n        return;\n      }\n\n      const node = container?.node.current;\n\n      if (!node) {\n        return;\n      }\n\n      const rect = getViewRect(node);\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (translatedRect.top + translatedRect.height <= rect.top) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (translatedRect.top >= rect.top + rect.height) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (translatedRect.left >= rect.left + rect.width) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (translatedRect.left + translatedRect.width <= rect.left) {\n            layoutRects.push([id, rect]);\n          }\n          break;\n      }\n    });\n\n    const closestId = closestCorners(layoutRects, translatedRect);\n\n    if (closestId) {\n      const newNode = droppableContainers[closestId]?.node.current;\n\n      if (newNode) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some(\n          (element, index) => scrollableAncestors[index] !== element\n        );\n        const newRect = getViewRect(newNode);\n        const offset = hasDifferentScrollAncestors\n          ? {\n              x: 0,\n              y: 0,\n            }\n          : {\n              x: translatedRect.width - newRect.width,\n              y: translatedRect.height - newRect.height,\n            };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y,\n        };\n\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n","import type {\n  LayoutRect,\n  UniqueIdentifier,\n  UseDndContextReturnValue,\n} from '@dnd-kit/core';\n\nexport function getSortedRects(\n  items: UniqueIdentifier[],\n  layoutRects: UseDndContextReturnValue['droppableRects']\n) {\n  return items.reduce<LayoutRect[]>((accumulator, id, index) => {\n    const layoutRect = layoutRects.get(id);\n\n    if (layoutRect) {\n      accumulator[index] = layoutRect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n","import type {SortingStrategy} from '../types';\n\nexport const rectSwappingStrategy: SortingStrategy = ({\n  activeIndex,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import {useContext, useEffect, useMemo, useRef} from 'react';\nimport {useDraggable, useDroppable, UseDraggableArguments} from '@dnd-kit/core';\nimport {CSS, useCombinedRefs} from '@dnd-kit/utilities';\n\nimport {Context} from '../components';\nimport type {SortingStrategy} from '../types';\nimport {arrayMove, isValidIndex} from '../utilities';\nimport {\n  defaultAnimateLayoutChanges,\n  defaultAttributes,\n  defaultTransition,\n  disabledTransition,\n  transitionProperty,\n} from './defaults';\nimport type {AnimateLayoutChanges, SortableTransition} from './types';\nimport {useDerivedTransform} from './utilities';\n\nexport interface Arguments extends UseDraggableArguments {\n  animateLayoutChanges?: AnimateLayoutChanges;\n  strategy?: SortingStrategy;\n  transition?: SortableTransition | null;\n}\n\nexport function useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled,\n  id,\n  strategy: localStrategy,\n  transition = defaultTransition,\n}: Arguments) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n    wasSorting,\n  } = useContext(Context);\n  const {\n    active,\n    activeNodeRect,\n    activatorEvent,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform,\n  } = useDraggable({\n    id,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes,\n    },\n    disabled,\n  });\n  const index = items.indexOf(id);\n  const data = useMemo(() => ({containerId, index, items}), [\n    containerId,\n    index,\n    items,\n  ]);\n  const {rect, node, setNodeRef: setDroppableNodeRef} = useDroppable({\n    id,\n    data,\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem =\n    isSorting &&\n    wasSorting.current &&\n    !disableTransforms &&\n    isValidIndex(activeIndex) &&\n    isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement =\n    shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy ?? globalStrategy;\n  const finalTransform = displaceItem\n    ? dragSourceDisplacement ??\n      strategy({\n        layoutRects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index,\n      })\n    : null;\n  const newIndex =\n    isValidIndex(activeIndex) && isValidIndex(overIndex)\n      ? arrayMove(items, activeIndex, overIndex).indexOf(id)\n      : index;\n  const prevNewIndex = useRef(newIndex);\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: prevNewIndex.current,\n    transition,\n    wasSorting: wasSorting.current,\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect,\n  });\n\n  useEffect(() => {\n    if (isSorting) {\n      prevNewIndex.current = newIndex;\n    }\n  }, [isSorting, newIndex]);\n\n  return {\n    active,\n    attributes,\n    activatorEvent,\n    rect,\n    index,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform ?? finalTransform,\n    transition: getTransition(),\n  };\n\n  function getTransition() {\n    if (derivedTransform) {\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource || !transition) {\n      return null;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty,\n      });\n    }\n\n    return null;\n  }\n}\n","import {useEffect, useRef, useState} from 'react';\nimport {getBoundingClientRect, LayoutRect} from '@dnd-kit/core';\nimport type {Transform} from '@dnd-kit/utilities';\n\ninterface Arguments {\n  rect: React.MutableRefObject<LayoutRect | null>;\n  disabled: boolean;\n  index: number;\n  node: React.MutableRefObject<HTMLElement | null>;\n}\n\n/*\n * When the index of an item changes while sorting,\n * we need to temporarily disable the transforms\n */\nexport function useDerivedTransform({rect, disabled, index, node}: Arguments) {\n  const [derivedTransform, setDerivedtransform] = useState<Transform | null>(\n    null\n  );\n  const prevIndex = useRef(index);\n\n  useEffect(() => {\n    if (!disabled && index !== prevIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getBoundingClientRect(node.current);\n        const delta = {\n          x: initial.offsetLeft - current.offsetLeft,\n          y: initial.offsetTop - current.offsetTop,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height,\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== prevIndex.current) {\n      prevIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n\n  return derivedTransform;\n}\n"],"names":["arrayMove","array","from","to","newArray","slice","splice","length","isValidIndex","index","defaultScale","scaleX","scaleY","rectSortingStrategy","layoutRects","newRects","overIndex","activeIndex","oldRect","newRect","x","offsetLeft","y","offsetTop","width","height","Context","React","createContext","containerId","disableTransforms","items","useDragOverlay","sortedRects","strategy","wasSorting","current","defaultAnimateLayoutChanges","transition","isSorting","newIndex","defaultTransition","duration","easing","disabledTransition","CSS","Transition","toString","property","defaultAttributes","roleDescription","directions","KeyboardCode","Down","Right","Up","Left","arr2","children","id","useDndContext","active","overlayNode","droppableRects","over","recomputeLayouts","willRecomputeLayouts","useUniqueId","Boolean","rect","indexOf","useRef","previousItemsRef","reduce","accumulator","layoutRect","get","Array","getSortedRects","itemsHaveChanged","join","useIsomorphicLayoutEffect","useEffect","requestAnimationFrame","contextValue","useMemo","Provider","value","activeNodeRect","itemGap","currentRect","previousRect","nextRect","getItemGap","newIndexRect","event","context","droppableContainers","translatedRect","scrollableAncestors","includes","code","preventDefault","Object","entries","forEach","container","disabled","node","getViewRect","top","push","left","closestId","closestCorners","newNode","_droppableContainers$","hasDifferentScrollAncestors","getScrollableAncestors","some","element","offset","animateLayoutChanges","userDefinedAttributes","attributes","localStrategy","useContext","globalStrategy","useDraggable","activatorEvent","setDraggableNodeRef","setNodeRef","listeners","isDragging","transform","data","useDroppable","setDroppableNodeRef","useCombinedRefs","displaceItem","shouldDisplaceDragSource","dragSourceDisplacement","finalTransform","prevNewIndex","shouldAnimateLayoutChanges","derivedTransform","useState","setDerivedtransform","prevIndex","initial","getBoundingClientRect","delta","useDerivedTransform","overIndexRect"],"mappings":"wNAGgBA,EAAaC,EAAYC,EAAcC,OAC/CC,EAAWH,EAAMI,eACvBD,EAASE,OACPH,EAAK,EAAIC,EAASG,OAASJ,EAAKA,EAChC,EACAC,EAASE,OAAOJ,EAAM,GAAG,IAGpBE,WCXOI,EAAaC,UACV,OAAVA,GAAkBA,GAAS,iNCGpC,IAAMC,EAAe,CACnBC,OAAQ,EACRC,OAAQ,GCHGC,EAAuC,gBAClDC,IAAAA,YAGAL,IAAAA,MAEMM,EAAWf,EAAUc,IAH3BE,YADAC,aAMMC,EAAUJ,EAAYL,GACtBU,EAAUJ,EAASN,UAEpBU,GAAYD,EAIV,CACLE,EAAGD,EAAQE,WAAaH,EAAQG,WAChCC,EAAGH,EAAQI,UAAYL,EAAQK,UAC/BZ,OAAQQ,EAAQK,MAAQN,EAAQM,MAChCZ,OAAQO,EAAQM,OAASP,EAAQO,QAP1B,MCXLf,EAAe,CACnBC,OAAQ,EACRC,OAAQ,GCuBGc,EAAUC,EAAMC,cAAiC,CAC5DX,aAAc,EACdY,YAhBgB,WAiBhBC,mBAAmB,EACnBC,MAAO,GACPf,WAAY,EACZgB,gBAAgB,EAChBC,YAAa,GACbC,SAAUrB,EACVsB,WAAY,CAACC,SAAS,KClCXC,EAAoD,uBAI/DC,eAHAC,aAEAC,aADA/B,QAeWgC,EAAwC,CACnDC,SAAU,IACVC,OAAQ,QAKGC,EAAqBC,MAAIC,WAAWC,SAAS,CACxDC,SAHgC,YAIhCN,SAAU,EACVC,OAAQ,WAGGM,EAAoB,CAC/BC,gBAAiB,YC1BbC,EAAuB,CAC3BC,eAAaC,KACbD,eAAaE,MACbF,eAAaG,GACbH,eAAaI,8CFmGkBC,EAtE/BC,IAAAA,SACAC,IAAAA,GACA5B,IAAAA,UACAG,SAAAA,aAAWrB,MASP+C,kBANFC,IAAAA,OACAC,IAAAA,YACAC,IAAAA,eACAC,IAAAA,KACAC,IAAAA,iBACAC,IAAAA,qBAEIrC,EAAcsC,cAxCJ,WAwC2BR,GACrC3B,EAAiBoC,QAA6B,OAArBN,EAAYO,MACrCpD,EAAc4C,EAAS9B,EAAMuC,QAAQT,IAAW,EAChDtB,GAA6B,IAAjBtB,EACZkB,EAAaoC,SAAOhC,GACpBvB,EAAYgD,EAAOjC,EAAMuC,QAAQN,EAAKL,KAAO,EAC7Ca,EAAmBD,SAAOxC,GAC1BE,WGvDNF,EACAjB,UAEOiB,EAAM0C,QAAqB,SAACC,EAAaf,EAAIlD,OAC5CkE,EAAa7D,EAAY8D,IAAIjB,UAE/BgB,IACFD,EAAYjE,GAASkE,GAGhBD,IACNG,MAAM9C,EAAMxB,SH4CKuE,CAAe/C,EAAOgC,GACpCgB,GAiDyBtB,EAjDUe,EAAiBpC,UAAxBL,EAkDtBiD,SAAWvB,EAAKuB,SAjDtBlD,GACY,IAAfd,IAAqC,IAAjBC,GAAuB8D,EAE9CE,6BAA0B,WACpBF,GAAoBxC,IAAc2B,GAEpCD,MAED,CAACc,EAAkBxC,EAAW0B,EAAkBC,IAEnDgB,aAAU,WACRV,EAAiBpC,QAAUL,IAC1B,CAACA,IAEJmD,aAAU,WACRC,uBAAsB,WACpBhD,EAAWC,QAAUG,OAEtB,CAACA,QAEE6C,EAAeC,WACnB,iBAA0B,CACxBpE,YAAAA,EACAY,YAAAA,EACAC,kBAAAA,EACAC,MAAAA,EACAf,UAAAA,EACAgB,eAAAA,EACAC,YAAAA,EACAC,SAAAA,EACAC,WAAAA,KAEF,CACElB,EACAY,EACAC,EACAC,EACAf,EACAiB,EACAD,EACAE,EACAC,WAIGR,gBAACD,EAAQ4D,UAASC,MAAOH,GAAe1B,oGHpGa,kBAC5D5C,IAAAA,YAEAG,IAAAA,YACAD,IAAAA,UACAP,IAAAA,MAEM+E,WAAiB1E,EAAYG,QALnCuE,mBAOKA,SACI,SAGHC,EA4CR,SACE3E,EACAL,EACAQ,OAEMyE,EAAc5E,EAAYL,GAC1BkF,EAAe7E,EAAYL,EAAQ,GACnCmF,EAAW9E,EAAYL,EAAQ,UAEhCkF,GAAiBC,EAIlB3E,EAAcR,EACTkF,EACHD,EAAYrE,YAAcsE,EAAatE,WAAasE,EAAanE,OACjEoE,EAASvE,YAAcqE,EAAYrE,WAAaqE,EAAYlE,OAG3DoE,EACHA,EAASvE,YAAcqE,EAAYrE,WAAaqE,EAAYlE,OAC5DkE,EAAYrE,YAAcsE,EAAatE,WAAasE,EAAanE,OAX5D,EAtDOqE,CAAW/E,EAAaL,EAAOQ,MAE3CR,IAAUQ,EAAa,KACnB6E,EAAehF,EAAYE,UAE5B8E,KAKH1E,EACEH,EAAcD,EACV8E,EAAazE,WACbyE,EAAatE,OACZgE,EAAenE,WAAamE,EAAehE,OAC5CsE,EAAazE,WAAamE,EAAenE,WAC/CC,EAAG,GACAZ,GAXI,cAePD,EAAQQ,GAAeR,GAASO,GAEhCI,GAAIoE,EAAehE,MAAQiE,EAC3BnE,EAAG,GAKHb,EAAQQ,GAAeR,GAASO,GAEhCI,EAAGoE,EAAehE,MAAQiE,EAC1BnE,EAAG,IAMLF,EAAG,EACHE,EAAG,GAdEZ,+DO7C4C,gBAM/CQ,EACAC,EANJF,IAAAA,YACAR,IAAAA,MACAK,IAAAA,YACAE,IAAAA,iBAKIP,IAAUQ,IACZC,EAAUJ,EAAYL,GACtBU,EAAUL,EAAYE,IAGpBP,IAAUO,IACZE,EAAUJ,EAAYL,GACtBU,EAAUL,EAAYG,IAGnBE,GAAYD,EAIV,CACLE,EAAGD,EAAQE,WAAaH,EAAQG,WAChCC,EAAGH,EAAQI,UAAYL,EAAQK,UAC/BZ,OAAQQ,EAAQK,MAAQN,EAAQM,MAChCZ,OAAQO,EAAQM,OAASP,EAAQO,QAP1B,0CFN0D,SACnEsE,aACCC,QAAUC,IAAAA,oBAAqBC,IAAAA,eAAgBC,IAAAA,uBAE5ChD,EAAWiD,SAASL,EAAMM,MAAO,IACnCN,EAAMO,kBAEDJ,aAICpF,EAA2B,GAEjCyF,OAAOC,QAAQP,GAAqBQ,SAAQ,gBAAE9C,OAAI+C,kBAC5CA,SAAAA,EAAWC,eAITC,QAAOF,SAAAA,EAAWE,KAAKxE,WAExBwE,OAICvC,EAAOwC,cAAYD,UAEjBb,EAAMM,WACPjD,eAAaC,KACZ6C,EAAeY,IAAMZ,EAAezE,QAAU4C,EAAKyC,KACrDhG,EAAYiG,KAAK,CAACpD,EAAIU,eAGrBjB,eAAaG,GACZ2C,EAAeY,KAAOzC,EAAKyC,IAAMzC,EAAK5C,QACxCX,EAAYiG,KAAK,CAACpD,EAAIU,eAGrBjB,eAAaI,KACZ0C,EAAec,MAAQ3C,EAAK2C,KAAO3C,EAAK7C,OAC1CV,EAAYiG,KAAK,CAACpD,EAAIU,eAGrBjB,eAAaE,MACZ4C,EAAec,KAAOd,EAAe1E,OAAS6C,EAAK2C,MACrDlG,EAAYiG,KAAK,CAACpD,EAAIU,cAMxB4C,EAAYC,iBAAepG,EAAaoF,MAE1Ce,EAAW,OACPE,WAAUlB,EAAoBgB,WAApBG,EAAgCR,KAAKxE,WAEjD+E,EAAS,KAELE,EADqBC,yBAAuBH,GACKI,MACrD,SAACC,EAAS/G,UAAU0F,EAAoB1F,KAAW+G,KAE/CrG,EAAU0F,cAAYM,GACtBM,EAASJ,EACX,CACEjG,EAAG,EACHE,EAAG,GAEL,CACEF,EAAG8E,EAAe1E,MAAQL,EAAQK,MAClCF,EAAG4E,EAAezE,OAASN,EAAQM,cAElB,CACrBL,EAAGD,EAAQ6F,KAAOS,EAAOrG,EACzBE,EAAGH,EAAQ2F,IAAMW,EAAOnG,+CGhEhCoG,qBAAAA,aAAuBrF,IACXsF,IAAZC,WACAjB,IAAAA,SACAhD,IAAAA,GACUkE,IAAV3F,aACAI,WAAAA,aAAaG,MAYTqF,aAAWpG,GATbK,IAAAA,MACAF,IAAAA,YACAZ,IAAAA,YACAa,IAAAA,kBACAG,IAAAA,YACAjB,IAAAA,UACAgB,IAAAA,eACU+F,IAAV7F,SACAC,IAAAA,aAYE6F,eAAa,CACfrE,GAAAA,EACAiE,gBACK3E,EACA0E,GAELhB,SAAAA,IAfA9C,IAAAA,OACA2B,IAAAA,eACAyC,IAAAA,eACAL,IAAAA,WACYM,IAAZC,WACAC,IAAAA,UACAC,IAAAA,WACArE,IAAAA,KACAsE,IAAAA,UASI7H,EAAQsB,EAAMuC,QAAQX,GACtB4E,EAAOlD,WAAQ,iBAAO,CAACxD,YAAAA,EAAapB,MAAAA,EAAOsB,MAAAA,KAAS,CACxDF,EACApB,EACAsB,MAEoDyG,eAAa,CACjE7E,GAAAA,EACA4E,KAAAA,IAFKlE,IAAAA,KAAMuC,IAAAA,KAAkB6B,IAAZN,WAIbA,EAAaO,kBAAgBD,EAAqBP,GAClD3F,EAAY6B,QAAQP,GACpB8E,EACJpG,GACAJ,EAAWC,UACVN,GACDtB,EAAaS,IACbT,EAAaQ,GACT4H,GAA4B5G,GAAkBqG,EAC9CQ,EACJD,GAA4BD,EAAeL,EAAY,KAEnDQ,EAAiBH,QACnBE,EAAAA,SAFahB,EAAAA,EAAiBE,GAGrB,CACPjH,YAAamB,EACbuD,eAAAA,EACAvE,YAAAA,EACAD,UAAAA,EACAP,MAAAA,IAEF,KACE+B,EACJhC,EAAaS,IAAgBT,EAAaQ,GACtChB,EAAU+B,EAAOd,EAAaD,GAAWsD,QAAQX,GACjDlD,EACAsI,EAAexE,SAAO/B,GACtBwG,GAA6BtB,EAAqB,CACtD7D,OAAAA,EACAwE,WAAAA,EACA9F,UAAAA,EACAoB,GAAAA,EACAlD,MAAAA,EACAsB,MAAAA,EACAS,SAAUuG,EAAa3G,QACvBE,WAAAA,EACAH,WAAYA,EAAWC,UAEnB6G,mBC7F6B5E,IAAAA,KAAMsC,IAAAA,SAAUlG,IAAAA,MAAOmG,IAAAA,OACVsC,WAC9C,MADKD,OAAkBE,OAGnBC,EAAY7E,SAAO9D,UAEzByE,aAAU,eACHyB,GAAYlG,IAAU2I,EAAUhH,SAAWwE,EAAKxE,QAAS,KACtDiH,EAAUhF,EAAKjC,WAEjBiH,EAAS,KACLjH,EAAUkH,wBAAsB1C,EAAKxE,SACrCmH,EAAQ,CACZnI,EAAGiI,EAAQhI,WAAae,EAAQf,WAChCC,EAAG+H,EAAQ9H,UAAYa,EAAQb,UAC/BZ,OAAQ0I,EAAQ7H,MAAQY,EAAQZ,MAChCZ,OAAQyI,EAAQ5H,OAASW,EAAQX,SAG/B8H,EAAMnI,GAAKmI,EAAMjI,IACnB6H,EAAoBI,IAKtB9I,IAAU2I,EAAUhH,UACtBgH,EAAUhH,QAAU3B,KAErB,CAACkG,EAAUlG,EAAOmG,EAAMvC,IAE3Ba,aAAU,WACJ+D,GACF9D,uBAAsB,WACpBgE,EAAoB,WAGvB,CAACF,IAEGA,EDuDkBO,CAAoB,CAC3C7C,UAAWqC,GACXvI,MAAAA,EACAmG,KAAAA,EACAvC,KAAAA,WAGFa,aAAU,WACJ3C,IACFwG,EAAa3G,QAAUI,KAExB,CAACD,EAAWC,IAER,CACLqB,OAAAA,EACA+D,WAAAA,EACAK,eAAAA,EACA5D,KAAAA,EACA5D,MAAAA,EACA8B,UAAAA,EACA8F,WAAAA,EACAD,UAAAA,EACAxB,KAAAA,EACA5F,UAAAA,EACAgD,KAAAA,EACAmE,WAAAA,EACAM,oBAAAA,EACAP,oBAAAA,EACAI,gBAAWW,GAAAA,GAAoBH,EAC/BxG,WAII2G,GAEKrG,EAGLgG,IAA6BtG,EACxB,KAGLC,GAAayG,GACRnG,MAAIC,WAAWC,cACjBT,GACHU,SJ/H0B,eImIvB,2CNpJiD,kBAC1D/B,IAAAA,YAEAR,IAAAA,MACAK,IAAAA,YACAE,IAAAA,UAEMwE,WAAiB1E,EAAYG,QALnCuE,mBAOKA,SACI,QAGL/E,IAAUQ,EAAa,KACnBwI,EAAgB3I,EAAYE,UAE7ByI,KAKHrI,EAAG,EACHE,EACEL,EAAcD,EACVyI,EAAclI,UACdkI,EAAchI,QACb+D,EAAejE,UAAYiE,EAAe/D,QAC3CgI,EAAclI,UAAYiE,EAAejE,WAC5Cb,GAXI,SAeL+E,EAyBR,SACE3E,EACAL,EACAQ,OAEMyE,EAAc5E,EAAYL,GAC1BkF,EAAe7E,EAAYL,EAAQ,GACnCmF,EAAW9E,EAAYL,EAAQ,UAEhCiF,EAIDzE,EAAcR,EACTkF,EACHD,EAAYnE,WAAaoE,EAAapE,UAAYoE,EAAalE,QAC/DmE,EACAA,EAASrE,WAAamE,EAAYnE,UAAYmE,EAAYjE,QAC1D,EAGCmE,EACHA,EAASrE,WAAamE,EAAYnE,UAAYmE,EAAYjE,QAC1DkE,EACAD,EAAYnE,WAAaoE,EAAapE,UAAYoE,EAAalE,QAC/D,EAfK,EAnCOoE,CAAW/E,EAAaL,EAAOQ,YAE3CR,EAAQQ,GAAeR,GAASO,GAEhCI,EAAG,EACHE,GAAIkE,EAAe/D,OAASgE,GAK5BhF,EAAQQ,GAAeR,GAASO,GAEhCI,EAAG,EACHE,EAAGkE,EAAe/D,OAASgE,IAM7BrE,EAAG,EACHE,EAAG,GAdEZ"}