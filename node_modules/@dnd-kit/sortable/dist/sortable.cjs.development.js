'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var core = require('@dnd-kit/core');
var utilities = require('@dnd-kit/utilities');

/**
 * Move an array item to a different position. Returns a new array with the item moved to the new position.
 */
function arrayMove(array, from, to) {
  var newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}

function getSortedRects(items, layoutRects) {
  return items.reduce(function (accumulator, id, index) {
    var layoutRect = layoutRects.get(id);

    if (layoutRect) {
      accumulator[index] = layoutRect;
    }

    return accumulator;
  }, Array(items.length));
}

function isValidIndex(index) {
  return index !== null && index >= 0;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// To-do: We should be calculating scale transformation
var defaultScale = {
  scaleX: 1,
  scaleY: 1
};
var horizontalListSortingStrategy = function horizontalListSortingStrategy(_ref) {
  var _layoutRects$activeIn;

  var layoutRects = _ref.layoutRects,
      fallbackActiveRect = _ref.activeNodeRect,
      activeIndex = _ref.activeIndex,
      overIndex = _ref.overIndex,
      index = _ref.index;
  var activeNodeRect = (_layoutRects$activeIn = layoutRects[activeIndex]) != null ? _layoutRects$activeIn : fallbackActiveRect;

  if (!activeNodeRect) {
    return null;
  }

  var itemGap = getItemGap(layoutRects, index, activeIndex);

  if (index === activeIndex) {
    var newIndexRect = layoutRects[overIndex];

    if (!newIndexRect) {
      return null;
    }

    return _extends({
      x: activeIndex < overIndex ? newIndexRect.offsetLeft + newIndexRect.width - (activeNodeRect.offsetLeft + activeNodeRect.width) : newIndexRect.offsetLeft - activeNodeRect.offsetLeft,
      y: 0
    }, defaultScale);
  }

  if (index > activeIndex && index <= overIndex) {
    return _extends({
      x: -activeNodeRect.width - itemGap,
      y: 0
    }, defaultScale);
  }

  if (index < activeIndex && index >= overIndex) {
    return _extends({
      x: activeNodeRect.width + itemGap,
      y: 0
    }, defaultScale);
  }

  return _extends({
    x: 0,
    y: 0
  }, defaultScale);
};

function getItemGap(layoutRects, index, activeIndex) {
  var currentRect = layoutRects[index];
  var previousRect = layoutRects[index - 1];
  var nextRect = layoutRects[index + 1];

  if (!previousRect && !nextRect) {
    return 0;
  }

  if (activeIndex < index) {
    return previousRect ? currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width) : nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width);
  }

  return nextRect ? nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width) : currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width);
}

var rectSortingStrategy = function rectSortingStrategy(_ref) {
  var layoutRects = _ref.layoutRects,
      activeIndex = _ref.activeIndex,
      overIndex = _ref.overIndex,
      index = _ref.index;
  var newRects = arrayMove(layoutRects, overIndex, activeIndex);
  var oldRect = layoutRects[index];
  var newRect = newRects[index];

  if (!newRect || !oldRect) {
    return null;
  }

  return {
    x: newRect.offsetLeft - oldRect.offsetLeft,
    y: newRect.offsetTop - oldRect.offsetTop,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};

var rectSwappingStrategy = function rectSwappingStrategy(_ref) {
  var activeIndex = _ref.activeIndex,
      index = _ref.index,
      layoutRects = _ref.layoutRects,
      overIndex = _ref.overIndex;
  var oldRect;
  var newRect;

  if (index === activeIndex) {
    oldRect = layoutRects[index];
    newRect = layoutRects[overIndex];
  }

  if (index === overIndex) {
    oldRect = layoutRects[index];
    newRect = layoutRects[activeIndex];
  }

  if (!newRect || !oldRect) {
    return null;
  }

  return {
    x: newRect.offsetLeft - oldRect.offsetLeft,
    y: newRect.offsetTop - oldRect.offsetTop,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};

// To-do: We should be calculating scale transformation
var defaultScale$1 = {
  scaleX: 1,
  scaleY: 1
};
var verticalListSortingStrategy = function verticalListSortingStrategy(_ref) {
  var _layoutRects$activeIn;

  var activeIndex = _ref.activeIndex,
      fallbackActiveRect = _ref.activeNodeRect,
      index = _ref.index,
      layoutRects = _ref.layoutRects,
      overIndex = _ref.overIndex;
  var activeNodeRect = (_layoutRects$activeIn = layoutRects[activeIndex]) != null ? _layoutRects$activeIn : fallbackActiveRect;

  if (!activeNodeRect) {
    return null;
  }

  if (index === activeIndex) {
    var overIndexRect = layoutRects[overIndex];

    if (!overIndexRect) {
      return null;
    }

    return _extends({
      x: 0,
      y: activeIndex < overIndex ? overIndexRect.offsetTop + overIndexRect.height - (activeNodeRect.offsetTop + activeNodeRect.height) : overIndexRect.offsetTop - activeNodeRect.offsetTop
    }, defaultScale$1);
  }

  var itemGap = getItemGap$1(layoutRects, index, activeIndex);

  if (index > activeIndex && index <= overIndex) {
    return _extends({
      x: 0,
      y: -activeNodeRect.height - itemGap
    }, defaultScale$1);
  }

  if (index < activeIndex && index >= overIndex) {
    return _extends({
      x: 0,
      y: activeNodeRect.height + itemGap
    }, defaultScale$1);
  }

  return _extends({
    x: 0,
    y: 0
  }, defaultScale$1);
};

function getItemGap$1(layoutRects, index, activeIndex) {
  var currentRect = layoutRects[index];
  var previousRect = layoutRects[index - 1];
  var nextRect = layoutRects[index + 1];

  if (!currentRect) {
    return 0;
  }

  if (activeIndex < index) {
    return previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : 0;
  }

  return nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : 0;
}

var ID_PREFIX = 'Sortable';
var Context = /*#__PURE__*/React__default.createContext({
  activeIndex: -1,
  containerId: ID_PREFIX,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  wasSorting: {
    current: false
  }
});
function SortableContext(_ref) {
  var children = _ref.children,
      id = _ref.id,
      items = _ref.items,
      _ref$strategy = _ref.strategy,
      strategy = _ref$strategy === void 0 ? rectSortingStrategy : _ref$strategy;

  var _useDndContext = core.useDndContext(),
      active = _useDndContext.active,
      overlayNode = _useDndContext.overlayNode,
      droppableRects = _useDndContext.droppableRects,
      over = _useDndContext.over,
      recomputeLayouts = _useDndContext.recomputeLayouts,
      willRecomputeLayouts = _useDndContext.willRecomputeLayouts;

  var containerId = utilities.useUniqueId(ID_PREFIX, id);
  var useDragOverlay = Boolean(overlayNode.rect !== null);
  var activeIndex = active ? items.indexOf(active) : -1;
  var isSorting = activeIndex !== -1;
  var wasSorting = React.useRef(isSorting);
  var overIndex = over ? items.indexOf(over.id) : -1;
  var previousItemsRef = React.useRef(items);
  var sortedRects = getSortedRects(items, droppableRects);
  var itemsHaveChanged = !isEqual(items, previousItemsRef.current);
  var disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  utilities.useIsomorphicLayoutEffect(function () {
    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {
      // To-do: Add partial recompution of only subset of rects
      recomputeLayouts();
    }
  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);
  React.useEffect(function () {
    previousItemsRef.current = items;
  }, [items]);
  React.useEffect(function () {
    requestAnimationFrame(function () {
      wasSorting.current = isSorting;
    });
  }, [isSorting]);
  var contextValue = React.useMemo(function () {
    return {
      activeIndex: activeIndex,
      containerId: containerId,
      disableTransforms: disableTransforms,
      items: items,
      overIndex: overIndex,
      useDragOverlay: useDragOverlay,
      sortedRects: sortedRects,
      strategy: strategy,
      wasSorting: wasSorting
    };
  }, [activeIndex, containerId, disableTransforms, items, overIndex, sortedRects, useDragOverlay, strategy, wasSorting]);
  return React__default.createElement(Context.Provider, {
    value: contextValue
  }, children);
}

function isEqual(arr1, arr2) {
  return arr1.join() === arr2.join();
}

var defaultAnimateLayoutChanges = function defaultAnimateLayoutChanges(_ref) {
  var isSorting = _ref.isSorting,
      index = _ref.index,
      newIndex = _ref.newIndex,
      transition = _ref.transition;

  if (!transition) {
    return false;
  }

  if (isSorting) {
    return true;
  }

  return newIndex !== index;
};
var defaultTransition = {
  duration: 200,
  easing: 'ease'
};
var transitionProperty = 'transform';
var disabledTransition = /*#__PURE__*/utilities.CSS.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: 'linear'
});
var defaultAttributes = {
  roleDescription: 'sortable'
};

/*
 * When the index of an item changes while sorting,
 * we need to temporarily disable the transforms
 */

function useDerivedTransform(_ref) {
  var rect = _ref.rect,
      disabled = _ref.disabled,
      index = _ref.index,
      node = _ref.node;

  var _useState = React.useState(null),
      derivedTransform = _useState[0],
      setDerivedtransform = _useState[1];

  var prevIndex = React.useRef(index);
  React.useEffect(function () {
    if (!disabled && index !== prevIndex.current && node.current) {
      var initial = rect.current;

      if (initial) {
        var current = core.getBoundingClientRect(node.current);
        var delta = {
          x: initial.offsetLeft - current.offsetLeft,
          y: initial.offsetTop - current.offsetTop,
          scaleX: initial.width / current.width,
          scaleY: initial.height / current.height
        };

        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }

    if (index !== prevIndex.current) {
      prevIndex.current = index;
    }
  }, [disabled, index, node, rect]);
  React.useEffect(function () {
    if (derivedTransform) {
      requestAnimationFrame(function () {
        setDerivedtransform(null);
      });
    }
  }, [derivedTransform]);
  return derivedTransform;
}

function useSortable(_ref) {
  var _ref$animateLayoutCha = _ref.animateLayoutChanges,
      animateLayoutChanges = _ref$animateLayoutCha === void 0 ? defaultAnimateLayoutChanges : _ref$animateLayoutCha,
      userDefinedAttributes = _ref.attributes,
      disabled = _ref.disabled,
      id = _ref.id,
      localStrategy = _ref.strategy,
      _ref$transition = _ref.transition,
      transition = _ref$transition === void 0 ? defaultTransition : _ref$transition;

  var _useContext = React.useContext(Context),
      items = _useContext.items,
      containerId = _useContext.containerId,
      activeIndex = _useContext.activeIndex,
      disableTransforms = _useContext.disableTransforms,
      sortedRects = _useContext.sortedRects,
      overIndex = _useContext.overIndex,
      useDragOverlay = _useContext.useDragOverlay,
      globalStrategy = _useContext.strategy,
      wasSorting = _useContext.wasSorting;

  var _useDraggable = core.useDraggable({
    id: id,
    attributes: _extends({}, defaultAttributes, userDefinedAttributes),
    disabled: disabled
  }),
      active = _useDraggable.active,
      activeNodeRect = _useDraggable.activeNodeRect,
      activatorEvent = _useDraggable.activatorEvent,
      attributes = _useDraggable.attributes,
      setDraggableNodeRef = _useDraggable.setNodeRef,
      listeners = _useDraggable.listeners,
      isDragging = _useDraggable.isDragging,
      over = _useDraggable.over,
      transform = _useDraggable.transform;

  var index = items.indexOf(id);
  var data = React.useMemo(function () {
    return {
      containerId: containerId,
      index: index,
      items: items
    };
  }, [containerId, index, items]);

  var _useDroppable = core.useDroppable({
    id: id,
    data: data
  }),
      rect = _useDroppable.rect,
      node = _useDroppable.node,
      setDroppableNodeRef = _useDroppable.setNodeRef;

  var setNodeRef = utilities.useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  var isSorting = Boolean(active);
  var displaceItem = isSorting && wasSorting.current && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  var shouldDisplaceDragSource = !useDragOverlay && isDragging;
  var dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  var strategy = localStrategy != null ? localStrategy : globalStrategy;
  var finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    layoutRects: sortedRects,
    activeNodeRect: activeNodeRect,
    activeIndex: activeIndex,
    overIndex: overIndex,
    index: index
  }) : null;
  var newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? arrayMove(items, activeIndex, overIndex).indexOf(id) : index;
  var prevNewIndex = React.useRef(newIndex);
  var shouldAnimateLayoutChanges = animateLayoutChanges({
    active: active,
    isDragging: isDragging,
    isSorting: isSorting,
    id: id,
    index: index,
    items: items,
    newIndex: prevNewIndex.current,
    transition: transition,
    wasSorting: wasSorting.current
  });
  var derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index: index,
    node: node,
    rect: rect
  });
  React.useEffect(function () {
    if (isSorting) {
      prevNewIndex.current = newIndex;
    }
  }, [isSorting, newIndex]);
  return {
    active: active,
    attributes: attributes,
    activatorEvent: activatorEvent,
    rect: rect,
    index: index,
    isSorting: isSorting,
    isDragging: isDragging,
    listeners: listeners,
    node: node,
    overIndex: overIndex,
    over: over,
    setNodeRef: setNodeRef,
    setDroppableNodeRef: setDroppableNodeRef,
    setDraggableNodeRef: setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };

  function getTransition() {
    if (derivedTransform) {
      // Temporarily disable transitions for a single frame to set up derived transforms
      return disabledTransition;
    }

    if (shouldDisplaceDragSource || !transition) {
      return null;
    }

    if (isSorting || shouldAnimateLayoutChanges) {
      return utilities.CSS.Transition.toString(_extends({}, transition, {
        property: transitionProperty
      }));
    }

    return null;
  }
}

var directions = [core.KeyboardCode.Down, core.KeyboardCode.Right, core.KeyboardCode.Up, core.KeyboardCode.Left];
var sortableKeyboardCoordinates = function sortableKeyboardCoordinates(event, _ref) {
  var _ref$context = _ref.context,
      droppableContainers = _ref$context.droppableContainers,
      translatedRect = _ref$context.translatedRect,
      scrollableAncestors = _ref$context.scrollableAncestors;

  if (directions.includes(event.code)) {
    event.preventDefault();

    if (!translatedRect) {
      return;
    }

    var layoutRects = [];
    Object.entries(droppableContainers).forEach(function (_ref2) {
      var id = _ref2[0],
          container = _ref2[1];

      if (container == null ? void 0 : container.disabled) {
        return;
      }

      var node = container == null ? void 0 : container.node.current;

      if (!node) {
        return;
      }

      var rect = core.getViewRect(node);

      switch (event.code) {
        case core.KeyboardCode.Down:
          if (translatedRect.top + translatedRect.height <= rect.top) {
            layoutRects.push([id, rect]);
          }

          break;

        case core.KeyboardCode.Up:
          if (translatedRect.top >= rect.top + rect.height) {
            layoutRects.push([id, rect]);
          }

          break;

        case core.KeyboardCode.Left:
          if (translatedRect.left >= rect.left + rect.width) {
            layoutRects.push([id, rect]);
          }

          break;

        case core.KeyboardCode.Right:
          if (translatedRect.left + translatedRect.width <= rect.left) {
            layoutRects.push([id, rect]);
          }

          break;
      }
    });
    var closestId = core.closestCorners(layoutRects, translatedRect);

    if (closestId) {
      var _droppableContainers$;

      var newNode = (_droppableContainers$ = droppableContainers[closestId]) == null ? void 0 : _droppableContainers$.node.current;

      if (newNode) {
        var newScrollAncestors = core.getScrollableAncestors(newNode);
        var hasDifferentScrollAncestors = newScrollAncestors.some(function (element, index) {
          return scrollableAncestors[index] !== element;
        });
        var newRect = core.getViewRect(newNode);
        var offset = hasDifferentScrollAncestors ? {
          x: 0,
          y: 0
        } : {
          x: translatedRect.width - newRect.width,
          y: translatedRect.height - newRect.height
        };
        var newCoordinates = {
          x: newRect.left - offset.x,
          y: newRect.top - offset.y
        };
        return newCoordinates;
      }
    }
  }

  return undefined;
};

exports.SortableContext = SortableContext;
exports.arrayMove = arrayMove;
exports.defaultAnimateLayoutChanges = defaultAnimateLayoutChanges;
exports.horizontalListSortingStrategy = horizontalListSortingStrategy;
exports.rectSortingStrategy = rectSortingStrategy;
exports.rectSwappingStrategy = rectSwappingStrategy;
exports.sortableKeyboardCoordinates = sortableKeyboardCoordinates;
exports.useSortable = useSortable;
exports.verticalListSortingStrategy = verticalListSortingStrategy;
//# sourceMappingURL=sortable.cjs.development.js.map
