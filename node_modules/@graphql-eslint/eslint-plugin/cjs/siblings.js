"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSiblings = void 0;
const utils_1 = require("@graphql-tools/utils");
const graphql_1 = require("graphql");
const documents_js_1 = require("./documents.js");
const utils_js_1 = require("./utils.js");
const siblingOperationsCache = new Map();
function getSiblings(project, documents) {
    const siblings = project
        ? (0, documents_js_1.getDocuments)(project)
        : typeof documents === 'string'
            ? [(0, utils_1.parseGraphQLSDL)('operation.graphql', documents, { noLocation: true })]
            : [];
    if (siblings.length === 0) {
        let printed = false;
        const noopWarn = () => {
            if (!printed) {
                utils_js_1.logger.warn('getSiblingOperations was called without any operations. Make sure to set "parserOptions.operations" to make this feature available!');
                printed = true;
            }
            return [];
        };
        return {
            available: false,
            getFragment: noopWarn,
            getFragments: noopWarn,
            getFragmentByType: noopWarn,
            getFragmentsInUse: noopWarn,
            getOperation: noopWarn,
            getOperations: noopWarn,
            getOperationByType: noopWarn,
        };
    }
    // Since the siblings array is cached, we can use it as cache key.
    // We should get the same array reference each time we get
    // to this point for the same graphql project
    const value = siblingOperationsCache.get(siblings);
    if (value) {
        return value;
    }
    let fragmentsCache = null;
    const getFragments = () => {
        var _a;
        if (fragmentsCache === null) {
            const result = [];
            for (const source of siblings) {
                for (const definition of ((_a = source.document) === null || _a === void 0 ? void 0 : _a.definitions) || []) {
                    if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {
                        result.push({
                            filePath: source.location,
                            document: definition,
                        });
                    }
                }
            }
            fragmentsCache = result;
        }
        return fragmentsCache;
    };
    let cachedOperations = null;
    const getOperations = () => {
        var _a;
        if (cachedOperations === null) {
            const result = [];
            for (const source of siblings) {
                for (const definition of ((_a = source.document) === null || _a === void 0 ? void 0 : _a.definitions) || []) {
                    if (definition.kind === graphql_1.Kind.OPERATION_DEFINITION) {
                        result.push({
                            filePath: source.location,
                            document: definition,
                        });
                    }
                }
            }
            cachedOperations = result;
        }
        return cachedOperations;
    };
    const getFragment = (name) => getFragments().filter(f => f.document.name.value === name);
    const collectFragments = (selectable, recursive, collected = new Map()) => {
        (0, graphql_1.visit)(selectable, {
            FragmentSpread(spread) {
                const fragmentName = spread.name.value;
                const [fragment] = getFragment(fragmentName);
                if (!fragment) {
                    utils_js_1.logger.warn(`Unable to locate fragment named "${fragmentName}", please make sure it's loaded using "parserOptions.operations"`);
                    return;
                }
                if (!collected.has(fragmentName)) {
                    collected.set(fragmentName, fragment.document);
                    if (recursive) {
                        collectFragments(fragment.document, recursive, collected);
                    }
                }
            },
        });
        return collected;
    };
    const siblingOperations = {
        available: true,
        getFragment,
        getFragments,
        getFragmentByType: typeName => getFragments().filter(f => f.document.typeCondition.name.value === typeName),
        getFragmentsInUse: (selectable, recursive = true) => Array.from(collectFragments(selectable, recursive).values()),
        getOperation: name => getOperations().filter(o => { var _a; return ((_a = o.document.name) === null || _a === void 0 ? void 0 : _a.value) === name; }),
        getOperations,
        getOperationByType: type => getOperations().filter(o => o.document.operation === type),
    };
    siblingOperationsCache.set(siblings, siblingOperations);
    return siblingOperations;
}
exports.getSiblings = getSiblings;
