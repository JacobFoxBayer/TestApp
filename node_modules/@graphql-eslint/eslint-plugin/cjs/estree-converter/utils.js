"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertLocation = exports.extractComments = exports.extractTokens = exports.convertToken = exports.getBaseType = exports.valueFromNode = void 0;
const graphql_1 = require("graphql");
const valueFromASTUntyped_js_1 = require("graphql/utilities/valueFromASTUntyped.js");
const valueFromNode = (...args) => {
    return (0, valueFromASTUntyped_js_1.valueFromASTUntyped)(...args);
};
exports.valueFromNode = valueFromNode;
function getBaseType(type) {
    if ((0, graphql_1.isNonNullType)(type) || (0, graphql_1.isListType)(type)) {
        return getBaseType(type.ofType);
    }
    return type;
}
exports.getBaseType = getBaseType;
function convertToken(token, type) {
    const { line, column, end, start, value } = token;
    return {
        type,
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion -- TODO: remove `!` when drop support of graphql@15
        value: value,
        /*
         * ESLint has 0-based column number
         * https://eslint.org/docs/developer-guide/working-with-rules#contextreport
         */
        loc: {
            start: {
                line,
                column: column - 1,
            },
            end: {
                line,
                column: column - 1 + (end - start),
            },
        },
        range: [start, end],
    };
}
exports.convertToken = convertToken;
function getLexer(source) {
    // GraphQL v14
    const gqlLanguage = require('graphql/language');
    if (gqlLanguage === null || gqlLanguage === void 0 ? void 0 : gqlLanguage.createLexer) {
        return gqlLanguage.createLexer(source, {});
    }
    // GraphQL v15
    const { Lexer: LexerCls } = require('graphql');
    if (LexerCls && typeof LexerCls === 'function') {
        return new LexerCls(source);
    }
    throw new Error('Unsupported GraphQL version! Please make sure to use GraphQL v14 or newer!');
}
function extractTokens(filePath, code) {
    const source = new graphql_1.Source(code, filePath);
    const lexer = getLexer(source);
    const tokens = [];
    let token = lexer.advance();
    while (token && token.kind !== graphql_1.TokenKind.EOF) {
        const result = convertToken(token, token.kind);
        tokens.push(result);
        token = lexer.advance();
    }
    return tokens;
}
exports.extractTokens = extractTokens;
function extractComments(loc) {
    if (!loc) {
        return [];
    }
    const comments = [];
    let token = loc.startToken;
    while (token) {
        if (token.kind === graphql_1.TokenKind.COMMENT) {
            const comment = convertToken(token, 
            // `eslint-disable` directive works only with `Block` type comment
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion -- TODO: remove `!` when drop support of graphql@15
            token.value.trimStart().startsWith('eslint') ? 'Block' : 'Line');
            comments.push(comment);
        }
        token = token.next;
    }
    return comments;
}
exports.extractComments = extractComments;
function convertLocation(location) {
    const { startToken, endToken, source, start, end } = location;
    /*
     * ESLint has 0-based column number
     * https://eslint.org/docs/developer-guide/working-with-rules#contextreport
     */
    const loc = {
        start: {
            /*
             * Kind.Document has startToken: { line: 0, column: 0 }, we set line as 1 and column as 0
             */
            line: startToken.line === 0 ? 1 : startToken.line,
            column: startToken.column === 0 ? 0 : startToken.column - 1,
        },
        end: {
            line: endToken.line,
            column: endToken.column - 1,
        },
        source: source.body,
    };
    if (loc.start.column === loc.end.column) {
        loc.end.column += end - start;
    }
    return loc;
}
exports.convertLocation = convertLocation;
