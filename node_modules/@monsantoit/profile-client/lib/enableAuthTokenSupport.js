"use strict";

/* eslint-disable no-use-before-define */
var agent = require('superagent');
var _ = require('./lodash');
var namespace = require('./safe/namespace');
var settings = require('./safe/settings');
var debug = require('./debug');
var EXPIRATION_THRESHOLD_IN_MILLISECONDS = 60 * 1000;
var dependencies = {
  getTime: function getTime() {
    return new Date().getTime();
  }
};
var state = {
  promise: null,
  intervalId: null,
  timeoutId: null
};
var reset = function reset() {
  clearInterval(state.intervalId);
  clearTimeout(state.timeoutId);
  state = {
    promise: null,
    intervalId: null,
    timeoutId: null
  };
  return state;
};
var handleError = function handleError(options) {
  return function (err) {
    console.error(err);
    console.warn('Profile Client: Could not update authorization token. Trying again in 5 seconds.');
    clearTimeout(state.timeoutId);
    state.timeoutId = setTimeout(function () {
      return createPromise(options);
    }, settings.retryInterval());
    return state.timeoutId;
  };
};
var updateToken = function updateToken(route, path) {
  var _namespace$get;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var getTime = dependencies.getTime;
  var requestPath = path || 'auth-token-info';
  var cookieToken = settings.tokenFromCookie(options.cookieName);
  // _.get should be able to fetch auth.expires, but some teams are pulling in an odd version of lodash
  var ttl = ((_namespace$get = namespace.get('auth', {})) === null || _namespace$get === void 0 ? void 0 : _namespace$get.expires) || 0;
  if (cookieToken) {
    debug.log('updateToken: with cookie', {
      cookieName: options.cookieName,
      cookieToken: cookieToken
    });
    namespace.set('authHeader', function () {
      return {
        Authorization: "Bearer ".concat(cookieToken)
      };
    });
    namespace.set('auth.token', cookieToken);

    // fetch token in background to get expiration.
    authTokenRequest(route, requestPath).catch(handleError(options));
    return Promise.resolve();
  }
  if (ttl <= getTime() + EXPIRATION_THRESHOLD_IN_MILLISECONDS) {
    debug.log('updateToken: No valid token available. Fetching Fresh token.', {
      ttl: ttl
    });
    return authTokenRequest(route, requestPath);
  }
  debug.log('updateToken: Token not expired.');
  return Promise.resolve();
};
var authTokenRequest = function authTokenRequest(route, path) {
  var getTime = dependencies.getTime;
  debug.log('authTokenRequest:', route, path);
  var url = "/".concat(route).concat(path);
  debug.log('authTokenRequest: ocelot url', url);
  return agent.get(url).then(function (_ref) {
    var body = _ref.body;
    debug.log('authTokenRequest: successful', body);
    var accessToken = body.access_token,
      expiresInSeconds = body.expires_in;
    var expireTime = getTime() + expiresInSeconds * 1000;
    debug.log("authTokenRequest: New token will expire at ".concat(new Date(expireTime).toString()));
    namespace.set('authHeader', function () {
      return {
        Authorization: "Bearer ".concat(accessToken)
      };
    });
    namespace.set('auth.token', accessToken);
    namespace.set('auth.expires', expireTime);

    // refreshing can be disabled for testing systems that wait for the event
    // loop to idle.
    if (settings.refreshEnabled()) {
      // Schedule the refresh prior to expiration
      var effectiveExpireTime = expireTime - EXPIRATION_THRESHOLD_IN_MILLISECONDS;
      var refreshDelay = Math.max(effectiveExpireTime - getTime(), settings.retryInterval());
      debug.log('authTokenRequest: refresh enabled.', {
        refreshDelay: refreshDelay
      });
      clearInterval(state.intervalId);
      state.intervalId = setInterval(function () {
        return updateToken(route, 'auth-token-refresh');
      }, refreshDelay);
      debug.log("authTokenRequest: Token refresh scheduled at ".concat(new Date(effectiveExpireTime).toString()));
      return state.intervalId;
    }
    debug.log('authTokenRequest: refresh not enabled.');
    return accessToken;
  });
};
var createPromise = function createPromise(options) {
  if (settings.authEnabled()) {
    debug.log('enableAuthTokenSupport: auth is enabled');
    // eslint-disable-next-line no-restricted-globals
    var path = (location.pathname || '/').substr(1);
    if (path.substr(path.length - 1) !== '/') {
      path += '/';
    }
    if (path === '/') {
      path = '';
    }
    return updateToken(path, 'auth-token-info', options).catch(handleError(options));
  }
  debug.log('enableAuthTokenSupport: auth is not enabled');
  return Promise.resolve();
};
var enableAuthTokenSupport = function enableAuthTokenSupport() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  debug.log('enableAuthTokenSupport');
  if (!state.promise) {
    state.promise = createPromise(options);
  }
  return state.promise;
};
module.exports = _.extend(enableAuthTokenSupport, {
  dependencies: dependencies,
  reset: reset,
  state: state
});