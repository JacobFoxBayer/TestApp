/* eslint-disable no-use-before-define */
const agent = require('superagent')
const _ = require('./lodash')
const namespace = require('./safe/namespace')
const settings = require('./safe/settings')
const debug = require('./debug')

const EXPIRATION_THRESHOLD_IN_MILLISECONDS = 60 * 1000

const dependencies = {
    getTime() {
        return new Date().getTime()
    }
}

let state = {
    promise: null,
    intervalId: null,
    timeoutId: null
}

const reset = () => {
    clearInterval(state.intervalId)
    clearTimeout(state.timeoutId)
    state = {
        promise: null,
        intervalId: null,
        timeoutId: null
    }
    return state
}

const handleError = (options) => (err) => {
    console.error(err)
    console.warn('Profile Client: Could not update authorization token. Trying again in 5 seconds.')

    clearTimeout(state.timeoutId)
    state.timeoutId = setTimeout(() => createPromise(options), settings.retryInterval())
    return state.timeoutId
}

const updateToken = (route, path, options = {}) => {
    const {getTime} = dependencies

    const requestPath = path || 'auth-token-info'
    const cookieToken = settings.tokenFromCookie(options.cookieName)
    // _.get should be able to fetch auth.expires, but some teams are pulling in an odd version of lodash
    const ttl = namespace.get('auth', {})?.expires || 0

    if (cookieToken) {
        debug.log('updateToken: with cookie', {cookieName: options.cookieName, cookieToken})

        namespace.set('authHeader', () => ({Authorization: `Bearer ${cookieToken}`}))
        namespace.set('auth.token', cookieToken)

        // fetch token in background to get expiration.
        authTokenRequest(route, requestPath).catch(handleError(options))

        return Promise.resolve()
    }

    if (ttl <= getTime() + EXPIRATION_THRESHOLD_IN_MILLISECONDS) {
        debug.log('updateToken: No valid token available. Fetching Fresh token.', {ttl})
        return authTokenRequest(route, requestPath)
    }

    debug.log('updateToken: Token not expired.')
    return Promise.resolve()
}

const authTokenRequest = (route, path) => {
    const {getTime} = dependencies
    debug.log('authTokenRequest:', route, path)

    const url = `/${route}${path}`
    debug.log('authTokenRequest: ocelot url', url)

    return agent.get(url).then(({body}) => {
        debug.log('authTokenRequest: successful', body)

        const {access_token: accessToken, expires_in: expiresInSeconds} = body
        const expireTime = getTime() + expiresInSeconds * 1000
        debug.log(`authTokenRequest: New token will expire at ${new Date(expireTime).toString()}`)

        namespace.set('authHeader', () => ({Authorization: `Bearer ${accessToken}`}))
        namespace.set('auth.token', accessToken)
        namespace.set('auth.expires', expireTime)

        // refreshing can be disabled for testing systems that wait for the event
        // loop to idle.
        if (settings.refreshEnabled()) {
            // Schedule the refresh prior to expiration
            const effectiveExpireTime = expireTime - EXPIRATION_THRESHOLD_IN_MILLISECONDS
            const refreshDelay = Math.max(effectiveExpireTime - getTime(), settings.retryInterval())
            debug.log('authTokenRequest: refresh enabled.', {refreshDelay})

            clearInterval(state.intervalId)
            state.intervalId = setInterval(
                () => updateToken(route, 'auth-token-refresh'),
                refreshDelay
            )
            debug.log(
                `authTokenRequest: Token refresh scheduled at ${new Date(
                    effectiveExpireTime
                ).toString()}`
            )
            return state.intervalId
        }
        debug.log('authTokenRequest: refresh not enabled.')
        return accessToken
    })
}

const createPromise = (options) => {
    if (settings.authEnabled()) {
        debug.log('enableAuthTokenSupport: auth is enabled')
        // eslint-disable-next-line no-restricted-globals
        let path = (location.pathname || '/').substr(1)
        if (path.substr(path.length - 1) !== '/') {
            path += '/'
        }
        if (path === '/') {
            path = ''
        }
        return updateToken(path, 'auth-token-info', options).catch(handleError(options))
    }
    debug.log('enableAuthTokenSupport: auth is not enabled')
    return Promise.resolve()
}

const enableAuthTokenSupport = (options = {}) => {
    debug.log('enableAuthTokenSupport')
    if (!state.promise) {
        state.promise = createPromise(options)
    }
    return state.promise
}

module.exports = _.extend(enableAuthTokenSupport, {dependencies, reset, state})
