# Processors
The following processors are provided by default.

## Using your config, to define your processors.

Each processor can take additional configuration. If you'd like to keep all your
configuration in one place, you can use the following notation to reference your
config:

``` js
{inConfig: 'path.to.config.value'}
```

This would, for exaple: let you set one value locally, then defer to cloudfoundry
bindings when deployed.

The `inConfig` key signals to the library that the option should be determined by
the configuration, and the value uses dot-notation to signify where the
configuration lives.

The above example, applied to the object below, would pick the value `true`.
```
{
    path: {
        to: {
            config: {
                value: true // <-- this gets selected.
            }
        }
    }
}
```

> NOTE: Processors take the configuration value at the time it's passed into the processor.
> A vault processor can't read from vault to fetch it's own configuration.

## Environment Variable Processors
The following processors read from the process.env values.

### processor.readEnvironmentVariablesFromConfig
This processor loads string and JSON values from process.env.

Assuming the following are in the environment:
``` bash
VARIABLE_ONE=foo
VARIABLE_TWO='{"bar":{"baz":"value"}}'
```

Environment Variable URI examples:
``` bash
env://VARIABLE_ONE
# becomes "foo"

env://VARIABLE_TWO/bar/baz
# becomes "value"

env://VARIABLE_TWO/bar
# becomes {baz: "value"}

env://VARIABLE_TWO/
# becomes {bar: {baz: "value"}}
```

## AWS Processors
The following processors presume that authorization is provided by the environment. They do not directly accept AWS credentials, but can be optionally configured with a region.

### processor.readParamStoreFromConfig
This processor looks for parameter store URIs in your sourced config, and
fetches the value from AWS SSM. A parameter store URI starts with `awsparam://`, and ends
with the parameter store path.

Full Parameter Store URI Example:
``` bash
awsparam://DevTest/MyApp/database/my-password
# grabs the value under the path /DevTest/MyApp/database/my-password
```

Example usage:
``` js
const {processor, env } = require('@monsantoit/config')


processor.readParamStoreFromConfig({
    enabled: true, // defaults to false, should be set based on env.
    region: 'us-east-1' // optional, for other ways to set the region see: https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-region.html
})
```

### processor.readSecretsManagerFromConfig
This processor looks for secrets manager URIs in your sourced config, and fetches the secret value from AWS SecretsManager. A secrets manager URI starts with `awssecret://`, and ends with the pattern defined by AWS for [dynamic references](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/dynamic-references.html#dynamic-references-secretsmanager).  At its simplest, this could just be the secret name, but this pattern also allows for fetching specific keys from the secret and specifying a version if necessary.

Reference Pattern (See link above for full details)
`secret-id:secret-string:json-key:version-stage:version-id`


#### Simple Secrets Manager URI Example
This example will fetch the entire secret value.  If you created the secret in a way that it is simply a string and not a key-value pair, this would be how you fetch it.
`awssecret://my-api-key`

#### Secrets Manager URI With Json Key Example
This example will fetch the value for the key `client-id` within the secret's key-value structure.  This is likely the most common way to use secrets manager.
`awssecret://my-oauth-client:SecretString:client-id`

#### Secrets Manager URI With Versioning Via Version Stage Example
This example will fetch the value for the key `client-secret` within the secret's key-value structure.  Here a version stage is also specified.  This pattern would be useful if you are rotating a secret and need to test the new value before switching over.
`awssecret://my-oauth-client:SecretString:client-secret:AWSPENDING`

#### Secrets Manager URI With Versioning Via Version Id Example
This example will fetch an exact version of a secret via its version id.  Note the double colon between the json key and the version id.  AWS Secrets Manager does not support version stage and version id in the same get request but the format must remain the same.  The empty space (figuratively, not whitespace) between the two colons is essentially the version stage left blank.
`awssecret://my-oauth-client:SecretString:client-secret::xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`

Example usage:
``` js
const {processor, env } = require('@monsantoit/config')


processor.readSecretsManagerFromConfig({
    enabled: true, // defaults to false, should be set based on env.
    region: 'us-east-1' // optional, for other ways to set the region see: https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-region.html
})
```


## Vault Processors
There are two vault-based processors - one that inspects the config itself, and one
that injects values at paths.

#### processor.readVaultFromConfig
Similar to `@monsantoit/vault-cf-services`, this processor looks for vault URIs
in your sourced config, and fetches the value from vault.

Vault authentication options are detailed below.

A vault URI starts with `vault://` and ends with the path to the secret.

> NOTE: For versions to config@0.5.0 and earlier, the `kv` backend requires you toprepend your path with `kv/data`, due to vault's API.
> This is super annoying, and has been fixed in config 0.6.0

Example Vault URI:
``` bash
# grabs the secret under the key `client-id`, in the secret path
# `secret/your-team/np/appname/oauth`

# secret backend
vault://secret/your-team/np/appname/oauth/client-id

#kv backend
vault://kv/your-team/np/appname/oauth/client-id

```

Example usage:
``` js
processor.readVaultFromConfig({
    url: 'https://vault.agro.services', // default value. can be omitted
    enabled: true // defaults to false. You should enable processors with `env`.
    auth: {
        type: 'appRole',
        roleId: process.env.APP_VAULT_ROLE_ID,
        secretId: process.env.APP_VAULT_SECRET_ID,
    }
})
```

#### processor.readVaultFromPaths
Iterates over a list of paths, and assigns them to a list of keys.

You can use values from within the configuration, or supply them directly.
``` js
processor.readVaultFromPaths({
    url: 'https://vault.agro.services',
    auth {
        type: 'appRole',
        roleId: { inConfig: 'path.to.roleIdKeyInConfig' },
        secretId: { inConfig: 'path.to.secretIdInConfig' },
    },
    paths: [{
        key: 'database',  secret: '/path/for/database',
        key: 'sqs', secret: '/path/for/sqs/'
    }]
})
```

### Vault Authentication
Vault access requires a token. Tokens can be fetched using your local user,
a approle credentials, or an assumed AWS role.

You can provide options within the configuration, or supply them directly.


#### Auto auth (beta)
* Tries to fetch a local vault token, an approle from config, and an aws role concurrently.
* Works locally, on jenkins, in cloudfoundry, or on AWS.
* Supply all possible options. In the case of conflict, this method prioritizes local, appRole, then AWS role.


``` js
processor.readVaultFromConfig({
    enabled: true,
    auth: {
        type: 'auto',
        roleName: { inConfig: 'path.to.aws_role_name'},
        roleId: { inConfig: 'path.to.role_id'},
        secretId: {inConfig: 'path.to.secret_id'}
    }
})
```

``` js
processor.readVaultFromConfig({
    enabled: true,
    auth: {
        type: 'auto',
        roleName: 'my-team-lambda',
        roleId: process.env.APP_VAULT_ROLE_ID,
        secretId: process.env.APP_VAULT_SECRET_ID,
    }
})
```

#### local token auth
* authenticates using your current vault token.
* has all the access your current user has. You may need to log in again if your access changes.
* will not work when deployed
* requires no additional configuration.

``` js
processor.readVaultFromConfig({
    enabled: env.inDevelopment,
    auth: { type: 'local' }
})
```

#### App Role auth
* authenticates using a supplied role id and secret id
* Role is created/configured in fort-knox
* credentials have to come from _somewhere_.
    * Cloudfoundry bindings,
    * direct environment variables
    * etc.

``` js
processor.readVaultFromConfig({
    enabled: env.inProduction,
    auth: {
        type: 'appRole',
        roleId: process.env.APP_VAULT_ROLE_ID,
        secretId: process.env.APP_VAULT_SECRET_ID,
    }
})
```

#### Aws Role auth
* Authenticates using your current AWS role.
* Role is created/configured in fort-knox.
* No credentials have to be supplied through your app.
* Will not work in cloudfoundry

``` js
processor.readVaultFromConfig({
    enabled: env.inProduction,
    auth: {
        type: 'awsRole',
        roleName: 'my-team-lambda', // this value can be found in fort-knox.
    }
})
```


You'll likely change configuration between local development and deployment.
Your sourced configuration can determine how to authenticate,
use the `inConfig` option.

#### fetch from sourced configuration
``` js
processor.readVaultFromConfig({
    url:  'https://vault.agro.services',
    auth: {
        type: { inConfig: 'path.to.typeInConfig' }          // inConfig property looks for
        roleId: { inConfig: 'path.to.roleIdKeyInConfig' },  // the value within the config,
        secretId: { inConfig: 'path.to.secretIdInConfig' }, // generated by your sources.
    }
})
```


## Debugging Processors
The following processors are useful for debugging any issues with configuration

### processor.writeToFile
Write the current configuration to a file, as JSON, for later inspection. It takes the path as given, you'll need to resolve the path yourself.

Takes an optional `omit` or `only` parameter, to filter out keys you don't care about. (Note: Omit is exclusive.)

``` js
// everything
processor.writeToFile(({
    output: '/path/to/destination.json',
}))


// everything but...
processor.writeToFile(({
    output: '/path/to/destination.json',
    omit: ['not', 'these', 'keys']
}))

// nothing except...
processor.writeToFile(({
    output: '/path/to/destination.json',
    only: ['just', 'these', 'keys']
}))
```


### processor.inspect
Inspects a key during processing. Use multiple inspections to see values change between stages.

``` js
processor.inspect("path.to.key") // logs value at key
```