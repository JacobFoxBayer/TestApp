'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime-corejs3/helpers/extends');
var slider = require('@material/slider');
var clsx = require('clsx');
var React = require('react');
var reactIcon = require('@element/react-icon');
var reactTextfield = require('@element/react-textfield');
var reactCommon = require('@element/react-common');
var PropTypes = require('prop-types');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefault(_extends);
var clsx__default = /*#__PURE__*/_interopDefault(clsx);
var React__default = /*#__PURE__*/_interopDefault(React);
var PropTypes__default = /*#__PURE__*/_interopDefault(PropTypes);

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const SliderPropTypes = {
  /**
   * Accessibility label for assistive technologies.
   *
   * Defaults to **null**.
   */
  ariaLabel: PropTypes__default["default"].string,
  /**
   * Id of the component being labeled for assistive technologies.
   *
   * Defaults to **null**.
   */
  ariaLabelledBy: PropTypes__default["default"].string,
  /**
   * Set this input attribute to a string that makes the slider value understandable, e.g. 'Monday'.
   *
   * Defaults to **null**.
   */
  ariaValuetext: PropTypes__default["default"].string,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes__default["default"].string,
  /**
   * Prevent user interaction.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes__default["default"].bool,
  /**
   * Discrete sliders display a numeric value label when the slider control is focused, which allows a user to input an exact value.
   *
   * Defaults to **false**.
   */
  discrete: PropTypes__default["default"].bool,
  /**
   * Display tracker markers with discrete slider only.
   *
   * Defaults to **false**.
   */
  displayMarkers: PropTypes__default["default"].bool,
  /**
   * ID for html input. May be overwritten.
   *
   * Defaults to **null**.
   */
  id: PropTypes__default["default"].string,
  /**
   * Custom content to be displayed in the leading block container. See leadingBlockType for types supported. If a string is sent for a icon an Element Icon will be rendered
   *
   * Defaults to **null**.
   */
  leadingBlock: PropTypes__default["default"].node,
  /**
   * Props to be added to the leading block node. For example, if an input is chosen, this is where you should send the input value and you can send in variant: 'filled' to use a filled textfield.
   *
   * Defaults to **null**.
   */
  leadingBlockProps: PropTypes__default["default"].object,
  /**
   * Styles to be added to leading block div.
   *
   * Defaults to **null**.
   */
  leadingBlockStyle: PropTypes__default["default"].object,
  /**
   * The type of media that will render in the leading block.
   *
   * Defaults to **null**.
   */
  leadingBlockType: PropTypes__default["default"].oneOf(["", "icon", "input", "text"]),
  /**
   * The maximum value a slider can have.
   *
   * Defaults to **100**.
   */
  max: PropTypes__default["default"].number,
  /**
   * The minimum value a slider can have.
   *
   * Defaults to **0**.
   */
  min: PropTypes__default["default"].number,
  /**
   * When using the range slider, this is the value of the minimum knob of the slider. The maximum value will use the standard value prop.
   *
   * Defaults to **'0'**.
   */
  minValue: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string, PropTypes__default["default"].object]),
  /**
   * Fired when the slider is blurred after the value of slider changes.
   *
   * Defaults to **null**.
   */
  onChange: PropTypes__default["default"].func,
  /**
   * Fired whenever the value of slider changes.
   *
   * Defaults to **null**.
   */
  onInput: PropTypes__default["default"].func,
  /**
   * Allows the slider to have two knobs to select a range value.
   *
   * Defaults to **false**.
   */
  range: PropTypes__default["default"].bool,
  /**
   * Specifies the increments at which a slider value can be set. Can be any positive number.
   *
   * Defaults to **1**.
   */
  step: PropTypes__default["default"].number,
  /**
   * Slider color theme.
   *
   * Defaults to **'primary'**.
   */
  themeColor: PropTypes__default["default"].oneOf(["primary", "secondary"]),
  /**
   * Custom content to be displayed in the trailing block container. See trailingBlockType for types supported. If a string is sent for icon an Element Icon will be rendered.
   *
   * Defaults to **null**.
   */
  trailingBlock: PropTypes__default["default"].node,
  /**
   * Props to be added to the trailing block node. For example, if an input is chosen, this is where you should send the input value and you can send in variant: 'filled' to use a filled textfield.
   *
   * Defaults to **null**.
   */
  trailingBlockProps: PropTypes__default["default"].object,
  /**
   * Styles to be added to trailing block div.
   *
   * Defaults to **null**.
   */
  trailingBlockStyle: PropTypes__default["default"].object,
  /**
   * The type of media that will render in the trailing block.
   *
   * Defaults to **null**.
   */
  trailingBlockType: PropTypes__default["default"].oneOf(["", "icon", "input", "text"]),
  /**
   * The current value of the slider. If the slider is a range slider, it will be the max value of the slider.
   *
   * Defaults to **null**.
   */
  value: PropTypes__default["default"].oneOfType([PropTypes__default["default"].number, PropTypes__default["default"].string, PropTypes__default["default"].object])
};
const SliderDefaultProps = {
  ariaLabel: null,
  ariaLabelledBy: null,
  ariaValuetext: null,
  className: undefined,
  disabled: false,
  discrete: false,
  displayMarkers: false,
  id: null,
  leadingBlock: null,
  leadingBlockProps: null,
  leadingBlockStyle: null,
  leadingBlockType: null,
  max: 100,
  min: 0,
  minValue: "0",
  range: false,
  step: 1,
  themeColor: "primary",
  trailingBlock: null,
  trailingBlockProps: null,
  trailingBlockStyle: null,
  trailingBlockType: null,
  value: null
};

const Slider = /*#__PURE__*/React.forwardRef((props, externalRef) => {
  var _mdcSlider$current10, _mdcSlider$current11;
  const {
    ariaLabel,
    ariaLabelledBy,
    ariaValuetext,
    className,
    disabled,
    discrete,
    displayMarkers,
    id,
    leadingBlock,
    leadingBlockProps,
    leadingBlockStyle,
    leadingBlockType,
    max,
    min,
    minValue,
    onChange,
    onInput,
    range,
    step,
    themeColor,
    trailingBlock,
    trailingBlockProps,
    trailingBlockStyle,
    trailingBlockType,
    value,
    ...customProps
  } = props;
  const ref = React.useRef();
  const mdcSlider = React.useRef();
  React.useImperativeHandle(externalRef, () => ref.current, []);
  const isMinInputValid = React.useCallback(val => {
    if (range) return val >= min && val <= value;
    return val >= min && val <= max;
  }, [min, value, max, range]);
  const isMaxInputValid = React.useCallback(val => {
    if (range) return val <= max && val >= minValue;
    return val <= max && val >= min;
  }, [max, minValue, min, range]);
  React.useEffect(() => {
    mdcSlider.current = slider.MDCSlider.attachTo(ref.current);
    return () => {
      var _mdcSlider$current;
      (_mdcSlider$current = mdcSlider.current) === null || _mdcSlider$current === void 0 ? void 0 : _mdcSlider$current.destroy();
    };
  }, [mdcSlider]);
  React.useEffect(() => {
    mdcSlider.current.foundation.min = min;
    mdcSlider.current.foundation.max = max;
    mdcSlider.current.foundation.step = step;
    mdcSlider.current.foundation.layout();
  }, [mdcSlider, discrete, displayMarkers, max, min, step]);
  React.useEffect(() => {
    mdcSlider.current.foundation.layout();
  }, [mdcSlider, leadingBlockType, trailingBlockType]);
  const handleChange = React.useCallback(e => {
    onChange && onChange(e.detail, e);
  }, [onChange]);
  const minInputOnChange = React.useCallback(e => {
    const val = e.target.value;
    leadingBlockProps.onChange && leadingBlockProps.onChange({
      value: val && parseInt(val, 10),
      thumb: 1
    });
  }, [leadingBlockProps]);
  const maxInputOnChange = React.useCallback(e => {
    const val = e.target.value;
    trailingBlockProps.onChange && trailingBlockProps.onChange({
      value: val && parseInt(val, 10),
      thumb: 2
    });
  }, [trailingBlockProps]);
  React.useEffect(() => {
    var _mdcSlider$current2;
    (_mdcSlider$current2 = mdcSlider.current) === null || _mdcSlider$current2 === void 0 ? void 0 : _mdcSlider$current2.listen('MDCSlider:change', handleChange);
    return () => {
      var _mdcSlider$current3;
      (_mdcSlider$current3 = mdcSlider.current) === null || _mdcSlider$current3 === void 0 ? void 0 : _mdcSlider$current3.unlisten('MDCSlider:change', handleChange);
    };
  }, [mdcSlider, handleChange]);
  const handleInput = React.useCallback(e => {
    onInput && onInput(e.detail, e);
  }, [onInput]);
  React.useEffect(() => {
    var _mdcSlider$current4;
    (_mdcSlider$current4 = mdcSlider.current) === null || _mdcSlider$current4 === void 0 ? void 0 : _mdcSlider$current4.listen('MDCSlider:input', handleInput);
    return () => {
      var _mdcSlider$current5;
      (_mdcSlider$current5 = mdcSlider.current) === null || _mdcSlider$current5 === void 0 ? void 0 : _mdcSlider$current5.unlisten('MDCSlider:input', handleInput);
    };
  }, [mdcSlider, handleInput]);
  React.useEffect(() => {
    if (!range) {
      var _mdcSlider$current6;
      (_mdcSlider$current6 = mdcSlider.current) === null || _mdcSlider$current6 === void 0 ? void 0 : _mdcSlider$current6.setValue(value);
    } else {
      if (isMaxInputValid(value)) {
        var _mdcSlider$current7;
        (_mdcSlider$current7 = mdcSlider.current) === null || _mdcSlider$current7 === void 0 ? void 0 : _mdcSlider$current7.setValue(value);
      }
      if (isMinInputValid(minValue)) {
        var _mdcSlider$current8;
        (_mdcSlider$current8 = mdcSlider.current) === null || _mdcSlider$current8 === void 0 ? void 0 : _mdcSlider$current8.setValueStart(minValue);
      }
    }
  }, [mdcSlider, value, minValue, range, isMinInputValid, isMaxInputValid]);
  React.useEffect(() => {
    var _mdcSlider$current9;
    (_mdcSlider$current9 = mdcSlider.current) === null || _mdcSlider$current9 === void 0 ? void 0 : _mdcSlider$current9.setDisabled(disabled);
  }, [mdcSlider, disabled]);
  const leadingBlockToUse = React.useMemo(() => {
    const maxInputValue = range ? value - 1 : max;
    switch (leadingBlockType) {
      case 'icon':
        return leadingBlock && typeof leadingBlock === 'string' ? /*#__PURE__*/React__default["default"].createElement(reactIcon.Icon, _extends__default["default"]({
          icon: leadingBlock
        }, leadingBlockProps)) : leadingBlock;
      case 'input':
        if (leadingBlock) {
          return (range || trailingBlockType !== 'input') && reactCommon.addProps(leadingBlock, {
            min,
            max: maxInputValue,
            step,
            type: 'number',
            valid: isMinInputValid(leadingBlockProps === null || leadingBlockProps === void 0 ? void 0 : leadingBlockProps.value)
          });
        }
        return (range || trailingBlockType !== 'input') && /*#__PURE__*/React__default["default"].createElement(reactTextfield.Textfield, _extends__default["default"]({
          variant: "outlined"
        }, leadingBlockProps, {
          dense: true,
          type: "number",
          min: min,
          max: maxInputValue,
          step: step,
          onChange: minInputOnChange,
          valid: isMinInputValid(leadingBlockProps === null || leadingBlockProps === void 0 ? void 0 : leadingBlockProps.value)
        }));
      default:
        return leadingBlock;
    }
  }, [leadingBlockType, leadingBlock, trailingBlockType, min, value, step, leadingBlockProps, range, minInputOnChange, isMinInputValid, max]);
  const trailingBlockToUse = React.useMemo(() => {
    const minInputValue = range ? minValue : min;
    switch (trailingBlockType) {
      case 'icon':
        return trailingBlockType && typeof trailingBlock === 'string' ? /*#__PURE__*/React__default["default"].createElement(reactIcon.Icon, {
          icon: trailingBlock
        }) : trailingBlock;
      case 'input':
        if (trailingBlock) {
          return trailingBlockType && reactCommon.addProps(trailingBlock, {
            min: minInputValue,
            max,
            step,
            type: 'number',
            valid: isMaxInputValid(trailingBlockProps === null || trailingBlockProps === void 0 ? void 0 : trailingBlockProps.value)
          });
        }
        return /*#__PURE__*/React__default["default"].createElement(reactTextfield.Textfield, _extends__default["default"]({
          variant: "outlined"
        }, trailingBlockProps, {
          dense: true,
          type: "number",
          min: minInputValue,
          max: max,
          step: step,
          onChange: maxInputOnChange,
          valid: isMaxInputValid(trailingBlockProps === null || trailingBlockProps === void 0 ? void 0 : trailingBlockProps.value)
        }));
      default:
        return trailingBlock;
    }
  }, [trailingBlockType, trailingBlock, trailingBlockProps, minValue, min, max, step, maxInputOnChange, range, isMaxInputValid]);
  const showLeadingBlock = leadingBlockType !== 'input' || (range || trailingBlockType !== 'input') && leadingBlockType === 'input';
  const showTrailingBlock = trailingBlockType || trailingBlock !== null || trailingBlock !== undefined;
  return /*#__PURE__*/React__default["default"].createElement("div", {
    className: clsx__default["default"]('lmnt', 'lmnt-slider-container', disabled && 'lmnt-slider--disabled')
  }, showLeadingBlock && /*#__PURE__*/React__default["default"].createElement("div", {
    className: clsx__default["default"]('lmnt-slider-info', 'lmnt-slider-info-leading', leadingBlockType === 'input' && 'lmnt-slider-info-with-input', themeColor === 'primary' && 'lmnt-slider-info--primary', themeColor === 'secondary' && 'lmnt-slider-info--secondary'),
    style: leadingBlockStyle
  }, leadingBlockToUse), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "lmnt lmnt-slider-inner"
  }, /*#__PURE__*/React__default["default"].createElement("div", _extends__default["default"]({
    className: clsx__default["default"]('lmnt', 'mdc-slider', range && 'mdc-slider--range', discrete && 'mdc-slider--discrete', discrete && displayMarkers && 'mdc-slider--tick-marks', themeColor === 'primary' && 'mdc-slider--primary', themeColor === 'secondary' && 'mdc-slider--secondary', className),
    id: id,
    ref: ref
  }, customProps), range && /*#__PURE__*/React__default["default"].createElement("input", {
    className: "mdc-slider__input",
    name: "rangeStart",
    type: "range",
    step: step,
    min: min,
    max: max,
    defaultValue: minValue,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-valuetext": ariaValuetext,
    "aria-disabled": disabled,
    disabled: disabled,
    tabIndex: disabled ? -1 : '0',
    readOnly: true
  }), /*#__PURE__*/React__default["default"].createElement("input", {
    className: "mdc-slider__input",
    type: "range",
    name: "rangeEnd",
    step: step,
    min: min,
    max: max,
    defaultValue: value,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-valuetext": ariaValuetext,
    "aria-disabled": disabled,
    disabled: disabled,
    tabIndex: disabled ? -1 : '0',
    readOnly: true
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__track"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__track--inactive"
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__track--active"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__track--active_fill"
  })), discrete && displayMarkers && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__tick-marks"
  })), range && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__thumb"
  }, discrete && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__value-indicator-container",
    "aria-hidden": "true"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__value-indicator"
  }, /*#__PURE__*/React__default["default"].createElement("span", {
    className: "mdc-slider__value-indicator-text"
  }, (_mdcSlider$current10 = mdcSlider.current) === null || _mdcSlider$current10 === void 0 ? void 0 : _mdcSlider$current10.getValueStart()))), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__thumb-knob"
  })), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__thumb"
  }, discrete && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__value-indicator-container",
    "aria-hidden": "true"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__value-indicator"
  }, /*#__PURE__*/React__default["default"].createElement("span", {
    className: "mdc-slider__value-indicator-text"
  }, (_mdcSlider$current11 = mdcSlider.current) === null || _mdcSlider$current11 === void 0 ? void 0 : _mdcSlider$current11.getValue()))), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-slider__thumb-knob"
  })))), showTrailingBlock && /*#__PURE__*/React__default["default"].createElement("div", {
    className: clsx__default["default"]('lmnt-slider-info', 'lmnt-slider-info-trailing', trailingBlockType === 'input' && 'lmnt-slider-info-with-input', themeColor === 'primary' && 'lmnt-slider-info--primary', themeColor === 'secondary' && 'lmnt-slider-info--secondary'),
    style: trailingBlockStyle
  }, trailingBlockToUse));
});
Slider.displayName = 'Slider';
Slider.propTypes = SliderPropTypes;
Slider.defaultProps = SliderDefaultProps;

exports.Slider = Slider;
//# sourceMappingURL=index.js.map
