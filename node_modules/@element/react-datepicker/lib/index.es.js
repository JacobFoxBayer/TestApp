import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { forwardRef, useRef, useImperativeHandle, useState, useEffect, useCallback, useMemo, cloneElement, useContext } from 'react';
import { TypoCaption } from '@element/react-typography';
import { IconButton } from '@element/react-icon-button';
import { Select } from '@element/react-select';
import { deprecatedProp, usePrevious, useIsomorphicLayoutEffect, edsRandomId, HoistingContext } from '@element/react-common';
import { Portal } from '@element/react-portal';
import clsx from 'clsx';
import { format, parse, isValid, add, getDaysInMonth, getDay } from 'date-fns';
import PropTypes from 'prop-types';
import { enUS } from 'date-fns/locale';
import useKey from '@rooks/use-key';
import { Icon } from '@element/react-icon';
import { Textfield } from '@element/react-textfield';
import { createPopper } from '@popperjs/core';

const getYear = (date, useUtc) => useUtc ? date.getUTCFullYear() : date.getFullYear();
const getMonth = (date, useUtc) => useUtc ? date.getUTCMonth() : date.getMonth();
const getDayOfMonth = (date, useUtc) => {
  const d = date || new Date();
  return useUtc ? d.getUTCDate() : d.getDate();
};
const getDayOfWeek = (date, useUtc) => {
  const d = date || new Date();
  return useUtc ? d.getUTCDay() : d.getDay();
};
const setFullYear = (date, value, useUtc) => {
  const d = new Date(date);
  if (useUtc) d.setUTCFullYear(value);else d.setFullYear(value);
  return d;
};
const setMonth = (date, value, useUtc) => {
  const d = new Date(date);
  if (useUtc) d.setUTCMonth(value);else d.setMonth(value);
  return d;
};
const setDate = (date, value, useUtc) => {
  const d = new Date(date);
  if (useUtc) d.setUTCDate(value);else d.setDate(value);
  return d;
};
const dateWithoutTime = (dateRaw, useUtc) => {
  const date = dateRaw || new Date();
  return useUtc ? new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate())) : new Date(date.getFullYear(), date.getMonth(), date.getDate());
};
const compareDates = (date1, date2, useUtc) => {
  const d1 = dateWithoutTime(date1, useUtc);
  const d2 = dateWithoutTime(date2, useUtc);
  return d1.getTime() === d2.getTime();
};

// this is just a passthrough to the date-fns `format()` method
const formatDate = (date, formatString, locale) => format(date, formatString, {
  locale
});
const getCurrentYearBase = () => (Math.ceil(new Date().getFullYear() / 100) - 1) * 100;

// To make entering an age easier (which will often extend into the previous century),
// we should anticipate and adjust the year. This is done by calculating a cutoff year based on the current date and
// an arbitrary, but configurable age (say 76), use that as the point with which to roll back the year. For example
// typing `02` should become `2002` while typing `76` should become `1976`.
//
// This may be undesirable for a datepicker doing long forecasts, so passing a cutoff year of 0 will defeat the behavior.
//
// maybe it's a dumb idea, but I got annoyed when trying to type in my birthday ðŸ™ƒ
//
const getSlidingCutoffYear = previousCenturyOffset => new Date(new Date().getFullYear() - previousCenturyOffset, 1, 1).getYear();

// Typed date parsing breaks as years are partially, forcing them through a new date works around the issue. We can also
// make adjustments for century as prescribed.
const fixInvalidTypedYear = (val, centurySlidingOffset) => {
  const reference = val || new Date();
  const century = getCurrentYearBase();
  let year = reference.getFullYear();
  const month = reference.getMonth();
  const date = reference.getDate();
  if (year < 1000) year = centurySlidingOffset && year >= getSlidingCutoffYear(centurySlidingOffset) ? year + century - 100 : year + century;
  return new Date(year, month, date);
};
const parseDate = (value, formats, outputFormat, locale, centurySlidingOffset) => {
  const initialParsed = parse(value, outputFormat, new Date(), {
    locale
  });
  if (isValid(initialParsed)) return fixInvalidTypedYear(initialParsed, centurySlidingOffset);
  for (let i = 0; i < formats.length; i += 1) {
    const parsed = parse(value, formats[i], new Date(), {
      locale
    });
    if (isValid(parsed)) return fixInvalidTypedYear(parsed, centurySlidingOffset);
  }
  return null;
};
const isValidDate = (date, formats, locale) => {
  if (typeof date === 'string') return isValid(parseDate(date, formats, locale));
  return isValid(date);
};
const matchMonthByVal = (val, months) => (val || val === 0) && months ? months.find(m => m.value === val) : null;
const firstOfMonth = (val, useUtc) => {
  const date = val || new Date();
  return useUtc ? new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1)) : new Date(date.getFullYear(), date.getMonth(), 1);
};
const createArrayWithRange = range =>
// eslint-disable-next-line prefer-spread
Array.apply(null, {
  length: range
}).map(Number.call, Number);
const getBlankDays = _ref => {
  let {
    visibleMonthYear,
    useUtc,
    mondayFirst
  } = _ref;
  const adjustedDate = firstOfMonth(visibleMonthYear, useUtc);
  const dayOfWeek = getDayOfWeek(adjustedDate, useUtc);
  if (mondayFirst) {
    return dayOfWeek > 0 ? createArrayWithRange(dayOfWeek - 1) : createArrayWithRange(6);
  }
  return createArrayWithRange(dayOfWeek);
};
const isSelectedDate = (dObj, _ref2) => {
  let {
    selectedDate,
    useUtc
  } = _ref2;
  return selectedDate && compareDates(selectedDate, dObj, useUtc);
};
const isInRange = (date, fromRaw, toRaw, useUtc) => {
  if (!date || !(fromRaw || toRaw)) return false;

  // throw away time
  const from = fromRaw ? dateWithoutTime(fromRaw, useUtc) : undefined;
  const to = toRaw ? dateWithoutTime(toRaw, useUtc) : undefined;

  // check entire range
  if (to && from) return date >= from && date <= to;

  // check if from infinity `to` date is implied
  if (!from && to) return date <= to;

  // check if `from` date to infinity is implied
  if (!to && from) return date >= from;
  return false;
};

// This is the shared logic for isDisabledDate and isHighlightedDate
const isDateWithinSpecifiedConfig = (dateRaw, config, minDate, maxDate, useUtc) => {
  if (!dateRaw) return false;

  // throw away time
  const date = dateWithoutTime(dateRaw, useUtc);
  if (minDate && date <= minDate) return false;
  if (maxDate && date >= maxDate) return false;
  if (!config) return false;
  if (config.dates && config.dates.some(d => compareDates(date, d, useUtc))) return true;
  if (isInRange(date, config.from, config.to, useUtc)) return true;
  if (config.ranges && config.ranges.some(range => isInRange(date, range.from, range.to, useUtc))) return true;
  if (config.days && config.days.indexOf(getDay(date, useUtc)) > -1) return true;
  if (config.daysOfMonth && config.daysOfMonth.indexOf(getDayOfMonth(date, useUtc)) > -1) return true;
  if (config.customPredictor && typeof config.customPredictor === 'function' && config.customPredictor(date)) return true;
  return false;
};
const incrementMonth = (incrementBy, startDate) => add(startDate, {
  months: incrementBy
});
const isDisabledDate = isDateWithinSpecifiedConfig;

// Whether a day is highlighted (only if it is not disabled already except when highlighted.includeDisabled is true)
const isHighlightedDate = (date, highlightedDates, isDisabled, minDate, maxDate, useUtc) => {
  if (!highlightedDates) return false;
  const {
    includeDisabled
  } = highlightedDates;
  if (includeDisabled && isDisabled) return false;
  return isDateWithinSpecifiedConfig(date, highlightedDates, minDate, maxDate, useUtc);
};
const getCalendarDateObject = (day, selectedDate, disabledDates, highlightedDates, minDate, maxDate, useUtc) => {
  const isDisabled = isDisabledDate(day, disabledDates, minDate, maxDate, useUtc);
  const dayOfWeek = getDayOfWeek(day, useUtc);
  return {
    date: getDayOfMonth(day, useUtc),
    dayOfWeek,
    timestamp: day.getTime(),
    isSelected: isSelectedDate(day, {
      useUtc,
      selectedDate
    }),
    isDisabled,
    isHighlighted: !!isHighlightedDate(day, highlightedDates, isDisabled, minDate, maxDate, useUtc),
    isToday: compareDates(day, new Date(), useUtc),
    isWeekend: dayOfWeek === 0 || dayOfWeek === 6,
    isSaturday: dayOfWeek === 6,
    isSunday: dayOfWeek === 0
  };
};

// TODO: fixed start boundary
const setHighlightBoundaries = days => {
  const output = [...days];
  let lastDayIsHighlighted = false;
  for (let i = 0; i < days.length; i += 1) {
    const day = output[i];
    day.isHighlightStart = !lastDayIsHighlighted;
    day.isHighlightEnd = output.length === i + 1 || !output[i + 1].isHighlighted;
    lastDayIsHighlighted = day.isHighlighted;
  }
  return output;
};
const getCalendarDays = _ref3 => {
  let {
    disabledDates,
    highlightedDates,
    maxDate,
    minDate,
    selectedDate,
    useUtc,
    visibleMonthYear
  } = _ref3;
  const days = [];
  // set up a new date object to the beginning of the current 'page'
  let dt = firstOfMonth(visibleMonthYear, useUtc);
  const monthDays = getDaysInMonth(dt);
  for (let i = 0; i < monthDays; i += 1) {
    days.push(getCalendarDateObject(dt, selectedDate, disabledDates, highlightedDates, minDate, maxDate, useUtc));
    dt = setDate(dt, getDayOfMonth(dt, useUtc) + 1, useUtc);
  }
  return setHighlightBoundaries(days);
};
const getCalendarDaysOfWeek = (locale, mondayFirst) => {
  const daysInOrder = mondayFirst ? [1, 2, 3, 4, 5, 0] : [0, 1, 2, 3, 4, 5, 6];
  return daysInOrder.map(i => ({
    label: locale.localize.day(i, {
      width: 'abbreviated'
    }),
    value: i
  }));
};
const getQuickSelectYears = _ref4 => {
  let {
    maxQuickSelectYear,
    minQuickSelectYear,
    useUtc,
    visibleMonthYear
  } = _ref4;
  const selectedYear = getYear(visibleMonthYear, useUtc);
  const start = minQuickSelectYear || selectedYear - 10;
  const end = maxQuickSelectYear || selectedYear + 10;
  const ys = [];
  for (let year = start; year <= end; year += 1) {
    ys.push(year);
  }
  return ys;
};
const getQuickSelectMonths = (locale, fullMonthName) => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(i => ({
  label: locale.localize.month(i, {
    width: fullMonthName ? 'long' : 'narrow'
  }),
  value: i
}));
const yearsMatch = (date1, date2, useUtc) => getYear(date1, useUtc) === getYear(date2, useUtc);
const some = (array, predicate) => {
  if (!array || !(array instanceof Array)) return false;
  return array.some(predicate);
};
const find = (array, predicate) => {
  if (!array || !(array instanceof Array)) return false;
  return array.find(predicate) || {};
};
const isPreviousMonthDisabled = (disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleMonthYear) => {
  if (disableChangeMonth || !visibleMonthYear) return true;
  const beginningOfCurrentMonth = new Date(visibleMonthYear.getFullYear(), visibleMonthYear.getMonth(), 1);
  const lastDayOfPrevMonth = add(beginningOfCurrentMonth, {
    days: -1
  });

  // make sure changing the month does not change the year if disableChangeYear is true
  if (disableChangeYear && !yearsMatch(visibleMonthYear, lastDayOfPrevMonth, useUtc)) return true;
  if (
  // check if there are no disabled dates
  !disabledDates ||
  // check if no `to` dates
  !disabledDates.to && !some(disabledDates.ranges, range => range.to && !range.from) ||
  // any finite range should not be disabled from changing months
  disabledDates.from && disabledDates.to) return false;
  return (
    // if the previous month exists entirely within the `to` date return true
    lastDayOfPrevMonth <= disabledDates.to ||
    // if the previous month exists entirely within the `to`of a "ranges" date return true
    lastDayOfPrevMonth <= find(disabledDates.ranges, range => range.to && !range.from).to
  );
};
const isNextMonthDisabled = (disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleMonthYear) => {
  if (disableChangeMonth || !visibleMonthYear) return true;
  const nextMonth = add(visibleMonthYear, {
    months: 1
  });
  const firstDayOfNextMonth = new Date(nextMonth.getFullYear(), nextMonth.getMonth(), 1);

  // make sure changing the month does not allow changing the year if disableChangeYear is true
  if (disableChangeYear && !yearsMatch(visibleMonthYear, firstDayOfNextMonth, useUtc)) return true;
  if (
  // check if there are no disabled dates
  !disabledDates ||
  // check if no `from` dates
  !disabledDates.from && !some(disabledDates.ranges, range => range.from && !range.to) ||
  // any finite range should not be disabled from changing months
  disabledDates.from && disabledDates.to) return false;

  // if the previous month exists entirely within the `to` date return true
  return firstDayOfNextMonth >= disabledDates.from ||
  // if the previous month exists entirely within the `to`of a "ranges" date return true
  firstDayOfNextMonth >= find(disabledDates.ranges, range => range.from && !range.to).from;
};
const getVariant = (primary, filled, secondary, outlined, variant) => {
  if (primary || filled) return 'filled';
  if (secondary || outlined) return 'outlined';
  return variant;
};
const getReadonly = (typeable, readOnly) => typeable === false ? true : readOnly;
const getContainerClasses = (className, props) => clsx('lmnt', 'lmnt-datepicker', props && props.textfieldProps && props.textfieldProps.fullWidth && 'lmnt-datepicker--fullWidth', className);
const getCalendarContainerClasses = (floating, sideContent, className) => clsx('lmnt', 'lmnt-datepicker__calendar', floating && 'lmnt-datepicker--floating', sideContent && 'lmnt-datepicker__calendar--with-side-content', className);
const getCalendarDayClasses = day => clsx('lmnt-datepicker__cell', 'lmnt-datepicker__cell--day', day.isSelected && 'lmnt-datepicker__cell--selected', day.isDisabled && 'lmnt-datepicker__cell--disabled', day.isToday && 'lmnt-datepicker__cell--today', day.isWeekend && 'lmnt-datepicker__cell--weekend', day.isSaturday && 'lmnt-datepicker__cell--sat', day.isSunday && 'lmnt-datepicker__cell--sun', day.isHighlighted && 'lmnt-datepicker__cell--highlighted', day.isHighlighted && day.isHighlightStart && 'lmnt-datepicker__cell--highlight-start', day.isHighlighted && day.isHighlightEnd && 'lmnt-datepicker__cell--highlight-end');
const getInitialDate = (openDate, selectedDate, useUtc) => setDate(openDate || selectedDate || new Date(), 1, useUtc) || new Date();
const getVisibleMonthYear = (date, useUtc) => {
  if (!date) return firstOfMonth(null, useUtc);
  return firstOfMonth(date, useUtc);
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const DatepickerPropTypes = {
  /**
   * Keep the calendar visible at all times.
   *
   * Defaults to **false**.
   */
  alwaysOpen: PropTypes.bool,
  /**
   * @deprecated _Use `leadingContent` instead._
   *
   * Content to appear before the header.
   *
   * Defaults to **undefined**.
   */
  beforeCalendarHeader: deprecatedProp(PropTypes.node, "Datepicker", "Use `leadingContent` instead."),
  /**
   * Custom props to be passed to the calendar.
   *
   * Defaults to **undefined**.
   */
  calendarProps: PropTypes.object,
  /**
   * When typing a date, this will determine 2-digit year parsing behavior. A value of `forward-only` will always use current century, so `02/08/02` will parse to `02/08/2002`. A value of `age`, on the other hand is meant to assist age entry. It will use the current century until a certain point (see `centurySlidingOffset`), and then will revert to the previous century. For example `05/25/01` will parse to `05/25/2001`, while `02/08/76` will parse to `02/08/1976`.
   *
   * Defaults to **'age'**.
   */
  centuryBehavior: PropTypes.oneOf(["age", "forward-only"]),
  /**
   * Only used when `centuryBehavior` is set to `age`. This will adjust the cutoff point where 2 digit dates will revert to the previous century to aid in typed age entry. The formula for the cutoff is `last 2 digits of the result of current year minus centuryCutoffOffset`. For example, using the year 2022 and the default value of 76 we would have `lastTwoDigits(2022 - 76) = 46`. So any 2 digit year of `45` or less will become `20XX` and any 2 digit year of `46` or more will become `19XX`. A value of `0` will disable the behavior, regardless of `centuryBehavior`. In 2023, the cutoff will be `47`, and so forth.
   *
   * Defaults to **76**.
   */
  centurySlidingOffset: PropTypes.number,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * A function for formatting the individual days of the calendar. It takes the date being rendered and returns content.
   *
   * Defaults to **day => day.date**.
   */
  dayCellTemplate: PropTypes.func,
  /**
   * Prevents the user from changing the month. Often used in conjunction with `disableChangeYear` to allow the user to only choose a date within the current month.
   *
   * Defaults to **false**.
   */
  disableChangeMonth: PropTypes.bool,
  /**
   * Prevents the user from changing the year. Often used in conjunction with `disableChangeMonth` to allow the user to only choose a date within the current month.
   *
   * Defaults to **false**.
   */
  disableChangeYear: PropTypes.bool,
  /**
   * Prevent the datePicker from being cleared. It is suggested to use `readOnly` in conjunction with `disableClearing`.
   *
   * Defaults to **false**.
   */
  disableClearing: PropTypes.bool,
  /**
   * If true, disable datePicker completely.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * An object describing dates to be disabled and non-interactive. The schema includes the following: `{ dates, days, daysOfMonth, from, to, ranges, customPredictor }`. Please see README for full schema description and examples. Note: All dates are _inclusive_ and date comparisons ignore time.
   *
   * Defaults to **undefined**.
   */
  disabledDates: PropTypes.shape({
    to: PropTypes.instanceOf(Date),
    from: PropTypes.instanceOf(Date),
    days: PropTypes.arrayOf(PropTypes.number),
    daysOfMonth: PropTypes.arrayOf(PropTypes.number),
    dates: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
    ranges: PropTypes.arrayOf(PropTypes.object),
    customPredictor: PropTypes.func
  }),
  /**
   * @deprecated _Use `variant='filled'` instead._
   *
   * Apply filled style to the date picker input. Previously called primary.
   *
   * Defaults to **undefined**.
   */
  filled: deprecatedProp(PropTypes.bool, "Datepicker", 'Use `variant="filled"` instead.'),
  /**
   * Date formatting string or function. For format strings we use `date-fns.format()`. See https://date-fns.org/v2.23.0/docs/format for more details.
   *
   * Defaults to **'dd MMM yyyy'**.
   */
  format: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
  /**
   * Display the full month name in the calendar interface. Note, this does not effect the date format.
   *
   * Defaults to **true**.
   */
  fullMonthName: PropTypes.bool,
  /**
   * Content to appear immediately after the `Calendar` header.
   *
   * Defaults to **undefined**.
   */
  headerContent: PropTypes.node,
  /**
   * An object describing dates to be highlighted. The schema includes the following: `{ includeDisabled, dates, days, daysOfMonth, from, to, ranges, customPredictor }`. Please see README for full schema description and examples. Note: All dates are _inclusive_ and date comparisons ignore time.
   *
   * Defaults to **undefined**.
   */
  highlightedDates: PropTypes.shape({
    includeDisabled: PropTypes.bool,
    to: PropTypes.instanceOf(Date),
    from: PropTypes.instanceOf(Date),
    days: PropTypes.arrayOf(PropTypes.number),
    daysOfMonth: PropTypes.arrayOf(PropTypes.number),
    dates: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
    ranges: PropTypes.arrayOf(PropTypes.object),
    customPredictor: PropTypes.func
  }),
  /**
   * Controls if the component is rendered outside of the parent element (aka hoisted). This is now managed automatically and no longer needs to be explicitly set unless using a custom (non-element) components with a parent that has `overflow: hidden`.
   *
   * Defaults to **undefined**.
   */
  hoisted: PropTypes.bool,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * The timezone that the input date is provided in (see `value`). If `outputTimeZone` is not set, the date will be returned as UTC. Supports international timezones. See https://www.iana.org/time-zones.
   *
   * Defaults to **undefined**.
   */
  inputTimeZone: PropTypes.string,
  /**
   * The input label.
   *
   * Defaults to **undefined**.
   */
  label: PropTypes.string,
  /**
   * Content to appear before the `Calendar` header.
   *
   * Defaults to **undefined**.
   */
  leadingContent: PropTypes.node,
  /**
   * Language support object in the `i18n` format. A number of pre-built languages can be imported from the npm package `date-fns`.
   *
   * Defaults to **enUS**.
   */
  locale: PropTypes.object,
  /**
   * The maximum date selectable. Dates later than this will be disabled.
   *
   * Defaults to **undefined**.
   */
  maxDate: PropTypes.instanceOf(Date),
  /**
   * The maximum year that will be visible in the year select dropdown. Note, This *does not* disable dates later than this from being able to be selected (see `minDate`), it only affects what years are visible in the Select. Defaults to current year + 10.
   *
   * Defaults to **undefined**.
   */
  maxQuickSelectYear: PropTypes.number,
  /**
   * The minimum date selectable. Dates earlier than this will be disabled.
   *
   * Defaults to **undefined**.
   */
  minDate: PropTypes.instanceOf(Date),
  /**
   * The minimum year visible in the year select dropdown. Note, This *does not* disable dates earlier than this from being able to be selected (see `minDate`), it only affects what years are visible in the Select. Defaults to current year - 10.
   *
   * Defaults to **undefined**.
   */
  minQuickSelectYear: PropTypes.number,
  /**
   * Overrides the first day of the week to start on Monday.
   *
   * Defaults to **false**.
   */
  mondayFirst: PropTypes.bool,
  /**
   * Fired when character is entered into text field and on select.
   *
   * Defaults to **undefined**.
   */
  onChange: PropTypes.func,
  /**
   * Fired when input is cleared with the 'x' button.
   *
   * Defaults to **undefined**.
   */
  onClear: PropTypes.func,
  /**
   * Fired when calendar is closed.
   *
   * Defaults to **undefined**.
   */
  onClose: PropTypes.func,
  /**
   * Fired when calendar is opened.
   *
   * Defaults to **undefined**.
   */
  onOpen: PropTypes.func,
  /**
   * Fired when date is selected.
   *
   * Defaults to **undefined**.
   */
  onSelect: PropTypes.func,
  /**
   * @deprecated _This has been renamed to `onSelectDisabled` for consistency_
   *
   * Fired when disabled date is clicked
   *
   * Defaults to **undefined**.
   */
  onSelectDisable: deprecatedProp(PropTypes.func, "Datepicker", "This has been renamed to `onSelectDisabled` for consistency"),
  /**
   * Fired when disabled date is clicked
   *
   * Defaults to **undefined**.
   */
  onSelectDisabled: PropTypes.func,
  /**
   * Fired when month is selected
   *
   * Defaults to **undefined**.
   */
  onSelectMonth: PropTypes.func,
  /**
   * Fired when year is selected
   *
   * Defaults to **undefined**.
   */
  onSelectYear: PropTypes.func,
  /**
   * If set, open on that date. Must be either a valid date object or a string that can be parsed by the date constructor.
   *
   * Defaults to **undefined**.
   */
  openDate: PropTypes.instanceOf(Date),
  /**
   * @deprecated _Replaced by `variant='outlined'`_
   *
   * Apply outlined style to the date picker input. Previously called secondary.
   *
   * Defaults to **undefined**.
   */
  outlined: deprecatedProp(PropTypes.bool, "Datepicker", 'Replaced by `variant="outlined"`'),
  /**
   * The timezone the date will be converted to and formatted as when using `useUtc`. If `inputTimeZone` is not set, the date is assumed to already be in UTC time. Supports international timezones. See https://www.iana.org/time-zones.
   *
   * Defaults to **undefined**.
   */
  outputTimeZone: PropTypes.string,
  /**
   * One or more acceptable formats for typed input. The default value 'P' will accept a short locale formatted date. See https://date-fns.org/v2.28.0/docs/parse for parsing options. Note, the value of the `format` prop will automatically be accepted.
   *
   * Defaults to **["P"]**.
   */
  parseFormats: PropTypes.arrayOf(PropTypes.string),
  /**
   * Placeholder text for the input.
   *
   * Defaults to **undefined**.
   */
  placeholder: PropTypes.string,
  /**
   * The DOM element the children will render in. If a string is sent it should be a valid DOM query selector. If one is not sent, Portal will default to `document.body`.
   *
   * Defaults to **'document.body'**.
   */
  portalContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * @deprecated _Replaced by `variant='outlined'`_
   *
   * Applies a filled style.
   *
   * Defaults to **undefined**.
   */
  primary: deprecatedProp(PropTypes.bool, "Datepicker", 'Replaced by `variant="outlined"`'),
  /**
   * User will not be allowed to type the date and must select it from the calendar.
   *
   * Defaults to **false**.
   */
  readOnly: PropTypes.bool,
  /**
   * Sets html required attribute on input
   *
   * Defaults to **false**.
   */
  required: PropTypes.bool,
  /**
   * This will reset the `Calendar` view to the selected date (or today's date when no date has been selected). By default the calendar will remember the last visible date shown until the page is refreshed.
   *
   * Defaults to **false**.
   */
  resetCalendarOnClose: PropTypes.bool,
  /**
   * @deprecated _Replaced by `variant='outlined'`_
   *
   * Applies outlined style.
   *
   * Defaults to **undefined**.
   */
  secondary: deprecatedProp(PropTypes.bool, "Datepicker", 'Replaced by `variant="outlined"`'),
  /**
   * Content to appear to the side of the `Calendar`. Can be used to display details for a selected date. Normally will appear to the right of the calendar, except when `rtl` is true, where it will appear to the left of the calendar.
   *
   * Defaults to **undefined**.
   */
  sideContent: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func]),
  /**
   * Props to be passed to the `Textfield` component. Accepts any valid `Textfield` props.
   *
   * Defaults to **undefined**.
   */
  textfieldProps: PropTypes.object,
  /**
   * Content to appear after the `Calendar`.
   *
   * Defaults to **undefined**.
   */
  trailingContent: PropTypes.node,
  /**
   * @deprecated _Please use `readOnly` instead._
   *
   * The user will not be allowed to type the date and must select it from the calendar.
   *
   * Defaults to **undefined**.
   */
  typeable: deprecatedProp(PropTypes.bool, "Datepicker", "Please use `readOnly` instead."),
  /**
   * Use UTC for time calculations.
   *
   * Defaults to **false**.
   */
  useUtc: PropTypes.bool,
  /**
   * Current value of the datePicker.
   *
   * Defaults to **undefined**.
   */
  value: PropTypes.instanceOf(Date),
  /**
   * Applies the selected style to the internal textfield.
   *
   * Defaults to **'filled'**.
   */
  variant: PropTypes.oneOf(["filled", "outlined"])
};
const DatepickerDefaultProps = {
  alwaysOpen: false,
  beforeCalendarHeader: undefined,
  calendarProps: undefined,
  centuryBehavior: "age",
  centurySlidingOffset: 76,
  className: undefined,
  dayCellTemplate: day => day.date,
  disableChangeMonth: false,
  disableChangeYear: false,
  disableClearing: false,
  disabled: false,
  disabledDates: undefined,
  filled: undefined,
  format: "dd MMM yyyy",
  fullMonthName: true,
  headerContent: undefined,
  highlightedDates: undefined,
  hoisted: undefined,
  id: undefined,
  inputTimeZone: undefined,
  label: undefined,
  leadingContent: undefined,
  locale: enUS,
  maxDate: undefined,
  maxQuickSelectYear: undefined,
  minDate: undefined,
  minQuickSelectYear: undefined,
  mondayFirst: false,
  openDate: undefined,
  outlined: undefined,
  outputTimeZone: undefined,
  parseFormats: ["P"],
  placeholder: undefined,
  portalContainer: "document.body",
  primary: undefined,
  readOnly: false,
  required: false,
  resetCalendarOnClose: false,
  secondary: undefined,
  sideContent: undefined,
  textfieldProps: undefined,
  trailingContent: undefined,
  typeable: undefined,
  useUtc: false,
  value: undefined,
  variant: "filled"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const CalendarPropTypes = {
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * A function for formatting the individual days of the calendar. It takes the date being rendered and returns content.
   *
   * Defaults to **day => day.date**.
   */
  dayCellTemplate: PropTypes.func,
  /**
   * Prevents the user from changing the month. Often used in conjunction with `disableChangeYear` to allow the user to only choose a date within the current month. An alternative to disabled dates.
   *
   * Defaults to **false**.
   */
  disableChangeMonth: PropTypes.bool,
  /**
   * Prevents the user from changing the year. Often used in conjunction with `disableChangeMonth` to allow the user to only choose a date within the current year. An alternative to disabled dates.
   *
   * Defaults to **false**.
   */
  disableChangeYear: PropTypes.bool,
  /**
   * One or more date ranges that are not selectable. Must be in the format: `{ranges: [{ from, to }]}` where from/to are valid javascript date objects.
   *
   * Defaults to **undefined**.
   */
  disabledDates: PropTypes.shape({
    to: PropTypes.instanceOf(Date),
    from: PropTypes.instanceOf(Date),
    days: PropTypes.arrayOf(PropTypes.number),
    daysOfMonth: PropTypes.arrayOf(PropTypes.number),
    dates: PropTypes.instanceOf(Date),
    ranges: PropTypes.arrayOf(PropTypes.object),
    customPredictor: PropTypes.func
  }),
  /**
   * Make the calendar float using absolute positioning.
   *
   * Defaults to **true**.
   */
  floating: PropTypes.bool,
  /**
   * To show the full month name.
   *
   * Defaults to **true**.
   */
  fullMonthName: PropTypes.bool,
  /**
   * Content to appear immediately after the header.
   *
   * Defaults to **undefined**.
   */
  headerContent: PropTypes.node,
  /**
   * An object describing pre-highlighted dates of the currently visible month. The object can include the following fields: `includeDisabled` = include dates that are outside of the current month in the highlighting. `dates` = an array of valid date objects to highlight, most useful for scattered highlighted dates. `from` and `to` = a valid start and end date range to highlight, most useful for a contiguous block of highlighted dates.
   *
   * Defaults to **undefined**.
   */
  highlightedDates: PropTypes.shape({
    includeDisabled: PropTypes.bool,
    to: PropTypes.instanceOf(Date),
    from: PropTypes.instanceOf(Date),
    days: PropTypes.arrayOf(PropTypes.number),
    daysOfMonth: PropTypes.arrayOf(PropTypes.number),
    dates: PropTypes.arrayOf(PropTypes.instanceOf(Date)),
    ranges: PropTypes.arrayOf(PropTypes.object),
    customPredictor: PropTypes.func
  }),
  /**
   * Controls if the component is rendered outside of the parent element (aka hoisted). This is now managed automatically and no longer needs to be explicitly set unless using a custom (non-Element) component with a parent that has `overflow: hidden`.
   *
   * Defaults to **undefined**.
   */
  hoisted: PropTypes.bool,
  /**
   * The current language is right-to-left.
   *
   * Defaults to **false**.
   */
  isRtl: PropTypes.bool,
  /**
   * Content to appear before the header.
   *
   * Defaults to **undefined**.
   */
  leadingContent: PropTypes.node,
  /**
   * Language support object in the `i18n` format. A number of pre-built languages can be imported from the npm package `date-fns`.
   *
   * Defaults to **enUS**.
   */
  locale: PropTypes.object,
  /**
   * The maximum date selectable. Dates later than this will be disabled.
   *
   * Defaults to **undefined**.
   */
  maxDate: PropTypes.instanceOf(Date),
  /**
   * Note, This *does not* disable dates later than this from being able to be selected (see `minDate`), it only affects what years are visible in the Select. Defaults to current year + 10.
   *
   * Defaults to **undefined**.
   */
  maxQuickSelectYear: PropTypes.number,
  /**
   * The minimum date selectable. Dates earlier than this will be disabled.
   *
   * Defaults to **undefined**.
   */
  minDate: PropTypes.instanceOf(Date),
  /**
   * Note, This *does not* disable dates earlier than this from being able to be selected (see `minDate`), it only affects what years are visible in the Select. Defaults to current year - 10.
   *
   * Defaults to **undefined**.
   */
  minQuickSelectYear: PropTypes.number,
  /**
   * Overrides the first day of the week to start on Monday.
   *
   * Defaults to **false**.
   */
  mondayFirst: PropTypes.bool,
  /**
   * Fired when the user selects a date.
   *
   * Defaults to **undefined**.
   */
  onSelectDate: PropTypes.func,
  /**
   * Fired when a disabled date is selected.
   *
   * Defaults to **undefined**.
   */
  onSelectDisabled: PropTypes.func,
  /**
   * Fired when the user selects a month.
   *
   * Defaults to **undefined**.
   */
  onSelectMonth: PropTypes.func,
  /**
   * The DOM element the children will render in. If a string is sent it should be a valid DOM query selector. If one is not sent, Portal will default to `document.body`.
   *
   * Defaults to **'document.body'**.
   */
  portalContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * The currently selected date.
   *
   * Defaults to **undefined**.
   */
  selectedDate: PropTypes.instanceOf(Date),
  /**
   * Content to appear to the side of the calendar. Normally will appear to the right of the calendar, except when `rtl` is true, where it will appear to the left of the calendar.
   *
   * Defaults to **undefined**.
   */
  sideContent: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.func]),
  /**
   * Content to appear after the header.
   *
   * Defaults to **undefined**.
   */
  trailingContent: PropTypes.node,
  /**
   * Use UTC for time calculations.
   *
   * Defaults to **false**.
   */
  useUtc: PropTypes.bool,
  /**
   * The date currently displayed on the calendar.
   *
   * Defaults to **new Date()**.
   */
  visibleDate: PropTypes.instanceOf(Date),
  /**
   * @deprecated _Renamed for consistency. See `visibleDate` instead._
   *
   * The date of the month and year currently displayed on the calendar.
   *
   * Defaults to **undefined**.
   */
  visibleMonthYear: deprecatedProp(PropTypes.instanceOf(Date), "Calendar", "Renamed for consistency. See `visibleDate` instead.")
};
const CalendarDefaultProps = {
  className: undefined,
  dayCellTemplate: day => day.date,
  disableChangeMonth: false,
  disableChangeYear: false,
  disabledDates: undefined,
  floating: true,
  fullMonthName: true,
  headerContent: undefined,
  highlightedDates: undefined,
  hoisted: undefined,
  isRtl: false,
  leadingContent: undefined,
  locale: enUS,
  maxDate: undefined,
  maxQuickSelectYear: undefined,
  minDate: undefined,
  minQuickSelectYear: undefined,
  mondayFirst: false,
  portalContainer: "document.body",
  selectedDate: undefined,
  sideContent: undefined,
  trailingContent: undefined,
  useUtc: false,
  visibleDate: new Date(),
  visibleMonthYear: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const DateInputPropTypes = {
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Prevent the datePicker from being cleared.
   *
   * Defaults to **false**.
   */
  disableClearing: PropTypes.bool,
  /**
   * If true, disable datePicker on screen.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * Date formatting string or function. For string formatting, valid placeholders include: `D` = day name. `dd` = day of month as 2 digits (leading zero). `d` = day of the month. `MMMM` = month name. `MMM` = abbreviated month name. `MM` month number as 2 digits (leading zero). `M` number of the month. `su` = day of month with ordinal suffix (1st, 2nd, 3rd, 10th). `yyyy` 4 digit year. `yy` 2 digit year. A function may also be used. It will receive the date as the only parameter and must return a valid string.
   *
   * Defaults to **'dd MMM yyyy'**.
   */
  format: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * The input label.
   *
   * Defaults to **null**.
   */
  label: PropTypes.string,
  /**
   * Language support object in the `i18n` format. A number of pre-built languages can be imported from the npm package `date-fns`.
   *
   * Defaults to **enUS**.
   */
  locale: PropTypes.object,
  /**
   * Fired when character is entered into text field and on select.
   *
   * Defaults to **null**.
   */
  onChange: PropTypes.func,
  /**
   * Fired when input is cleared with the 'x' button.
   *
   * Defaults to **null**.
   */
  onClear: PropTypes.func,
  /**
   * Fired when calendar is closed.
   *
   * Defaults to **null**.
   */
  onClose: PropTypes.func,
  /**
   * Fired when calendar is opened.
   *
   * Defaults to **null**.
   */
  onOpen: PropTypes.func,
  /**
   * Fired when date is selected.
   *
   * Defaults to **null**.
   */
  onSelect: PropTypes.func,
  /**
   * Fired when disabled date is clicked
   *
   * Defaults to **null**.
   */
  onSelectDisable: PropTypes.func,
  /**
   * Fired when month is selected
   *
   * Defaults to **null**.
   */
  onSelectMonth: PropTypes.func,
  /**
   * Fired when calendar is opened.
   *
   * Defaults to **null**.
   */
  onShowCalendar: PropTypes.func,
  /**
   * Fired when user types a date.
   *
   * Defaults to **null**.
   */
  onTypedDate: PropTypes.func,
  /**
   * Placeholder text for the input.
   *
   * Defaults to **null**.
   */
  placeholder: PropTypes.string,
  /**
   * If true, the use will not be allowed to type the date and must select it from the calendar.
   *
   * Defaults to **false**.
   */
  readOnly: PropTypes.bool,
  /**
   * Sets html required attribute on input
   *
   * Defaults to **false**.
   */
  required: PropTypes.bool,
  /**
   * The currently selected date.
   *
   * Defaults to **undefined**.
   */
  selectedDate: PropTypes.instanceOf(Date),
  /**
   * Props to be passed to the `Textfield` component. Accepts any valid `Textfield` props.
   *
   * Defaults to **null**.
   */
  textfieldProps: PropTypes.object,
  /**
   * The value typed into the date input. Note: state management for this field has been elevated outside of date input for the time being.
   *
   * Defaults to **empty string**.
   */
  typedDate: PropTypes.string,
  /**
   * Use UTC for time calculations.
   *
   * Defaults to **false**.
   */
  useUtc: PropTypes.bool,
  /**
   * Applies the selected style to the internal textfield.
   *
   * Defaults to **'filled'**.
   */
  variant: PropTypes.oneOf(["filled", "outlined"])
};
const DateInputDefaultProps = {
  className: undefined,
  disableClearing: false,
  disabled: false,
  format: "dd MMM yyyy",
  id: undefined,
  label: null,
  locale: enUS,
  placeholder: null,
  readOnly: false,
  required: false,
  selectedDate: undefined,
  textfieldProps: null,
  typedDate: "",
  useUtc: false,
  variant: "filled"
};

const Calendar = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    className,
    dayCellTemplate,
    disableChangeMonth,
    disableChangeYear,
    disabledDates,
    floating,
    fullMonthName,
    headerContent,
    highlightedDates,
    hoisted,
    isRtl,
    leadingContent,
    locale,
    maxDate,
    maxQuickSelectYear,
    minQuickSelectYear,
    mondayFirst,
    onSelectDate,
    onSelectDisabled,
    onSelectMonth,
    onSelectYear,
    portalContainer,
    selectedDate,
    sideContent,
    trailingContent,
    minDate,
    useUtc,
    visibleDate,
    visibleMonthYear,
    ...customProps
  } = props;
  const ref = useRef();
  const daysRef = useRef();
  useImperativeHandle(externalRef, () => ref.current);

  // Remove in v6 when visibleMonthYear is removed.
  const visibleDateActual = visibleMonthYear || visibleDate;
  const [leftNavDisabled, setLeftNavDisabled] = useState(false);
  const [rightNavDisabled, setRightNavDisabled] = useState(false);
  const [blankDays, setBlankDays] = useState([]);
  const [daysOfWeek, setDaysOfWeek] = useState([]);
  const [months, setMonths] = useState([]);
  const [daysOfMonth, setDaysOfMonth] = useState([]);
  const [years, setYears] = useState([]);
  const [selectedMonth, setSelectedMonth] = useState();
  const [selectedYear, setSelectedYear] = useState();
  const [lastDayFocus, setLastDayFocus] = useState();
  const [firstDayFocus, setFirstDayFocus] = useState();
  useEffect(() => {
    setYears(getQuickSelectYears({
      maxQuickSelectYear,
      minQuickSelectYear,
      useUtc,
      visibleMonthYear: visibleDateActual
    }));
  }, [maxQuickSelectYear, minQuickSelectYear, useUtc, visibleDateActual]);
  useEffect(() => {
    setMonths(getQuickSelectMonths(locale, fullMonthName));
  }, [locale, fullMonthName]);
  useEffect(() => {
    setDaysOfWeek(getCalendarDaysOfWeek(locale, mondayFirst));
  }, [locale, mondayFirst]);
  useEffect(() => {
    // wait until months and years are loaded before setting selected values, otherwise we get an error with Select
    if ((months === null || months === void 0 ? void 0 : months.length) === 0 || (years === null || years === void 0 ? void 0 : years.length) === 0) return;
    setSelectedMonth(getMonth(visibleDateActual, useUtc));
    setSelectedYear(getYear(visibleDateActual, useUtc));
  }, [months, useUtc, visibleDateActual, years]);
  const handleSelectDate = (date, event) => {
    if (date.isDisabled) {
      onSelectDisabled === null || onSelectDisabled === void 0 ? void 0 : onSelectDisabled(date, event);
      return;
    }
    onSelectDate === null || onSelectDate === void 0 ? void 0 : onSelectDate(new Date(date.timestamp), event);
  };
  const handleChangeMonth = useCallback((incrementBy, event, doSetLastDayFocus, doSetFirstDayFocus) => {
    onSelectMonth && onSelectMonth(incrementMonth(incrementBy, visibleDateActual), event);
    if (doSetLastDayFocus) setLastDayFocus(true);
    if (doSetFirstDayFocus) setFirstDayFocus(true);
  }, [onSelectMonth, visibleDateActual]);
  const daysOfMonthPrev = usePrevious(daysOfMonth, daysOfMonth);
  useIsomorphicLayoutEffect(() => {
    if (lastDayFocus) {
      if (daysOfMonthPrev[0].month !== daysOfMonth[0].month) {
        var _daysRef$current, _daysRef$current$quer;
        (_daysRef$current = daysRef.current) === null || _daysRef$current === void 0 ? void 0 : (_daysRef$current$quer = _daysRef$current.querySelector(`#date-${daysOfMonth.length}`)) === null || _daysRef$current$quer === void 0 ? void 0 : _daysRef$current$quer.focus();
        setLastDayFocus(false);
        return;
      }
    }
    if (firstDayFocus) {
      if (daysOfMonthPrev[0].month !== daysOfMonth[0].month) {
        var _daysRef$current2, _daysRef$current2$que;
        (_daysRef$current2 = daysRef.current) === null || _daysRef$current2 === void 0 ? void 0 : (_daysRef$current2$que = _daysRef$current2.querySelector(`#date-1`)) === null || _daysRef$current2$que === void 0 ? void 0 : _daysRef$current2$que.focus();
        setFirstDayFocus(false);
      }
    }
  }, [daysOfMonth, daysOfMonthPrev, firstDayFocus, lastDayFocus]);
  const handleShowPreviousMonth = useCallback((event, doSetLastDayFocus) => {
    if (!isPreviousMonthDisabled(disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleDateActual)) {
      handleChangeMonth(-1, event, doSetLastDayFocus);
    }
  }, [handleChangeMonth, disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleDateActual]);
  const handleShowNextMonth = useCallback((event, doSetLastDayFocus, doSetFirstDayFocus) => {
    if (!isNextMonthDisabled(disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleDateActual)) {
      handleChangeMonth(+1, event, doSetLastDayFocus, doSetFirstDayFocus);
    }
  }, [handleChangeMonth, disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleDateActual]);
  const handleSelectMonth = useCallback((newMonth, event) => {
    onSelectMonth(setMonth(visibleDateActual, newMonth.value, useUtc), event);
  }, [onSelectMonth, visibleDateActual, useUtc]);
  const handleSelectYear = useCallback((newYear, event) => {
    if (!newYear) return;
    onSelectYear(setFullYear(visibleDateActual, newYear, useUtc), event);
  }, [onSelectYear, visibleDateActual, useUtc]);

  // This prevents the calendar from closing when the user clicks on it
  const handlePreventDefault = useCallback(e => {
    var _ref$current;
    if (ref !== null && ref !== void 0 && (_ref$current = ref.current) !== null && _ref$current !== void 0 && _ref$current.contains(e.target)) return;
    e.preventDefault();
  }, []);
  useEffect(() => {
    const days = getCalendarDays({
      disabledDates,
      highlightedDates,
      maxDate,
      minDate,
      selectedDate,
      useUtc,
      visibleMonthYear: visibleDateActual
    });
    setDaysOfMonth(days);
  }, [disabledDates, highlightedDates, maxDate, minDate, selectedDate, useUtc, visibleDateActual]);
  useEffect(() => {
    setBlankDays(getBlankDays({
      visibleMonthYear: visibleDateActual,
      useUtc,
      mondayFirst
    }) || []);
  }, [mondayFirst, visibleDateActual, useUtc]);
  useEffect(() => {
    setLeftNavDisabled(isRtl ? isNextMonthDisabled(disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleDateActual) : isPreviousMonthDisabled(disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleDateActual));
  }, [disableChangeMonth, disableChangeYear, disabledDates, isRtl, useUtc, visibleDateActual]);
  useEffect(() => {
    setRightNavDisabled(isRtl ? isPreviousMonthDisabled(disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleDateActual) : isNextMonthDisabled(disableChangeMonth, disableChangeYear, disabledDates, useUtc, visibleDateActual));
  }, [disableChangeMonth, disableChangeYear, disabledDates, isRtl, useUtc, visibleDateActual]);

  // We can give some flexibility to how they want to handle the side content of the calendar
  const SideContentContainer = useMemo(() => () => {
    if (typeof sideContent === 'function') {
      return sideContent({
        date: selectedDate
      });
    }
    if (typeof sideContent === 'object') {
      return /*#__PURE__*/cloneElement(sideContent, {
        date: selectedDate
      });
    }
    return sideContent;
  }, [selectedDate, sideContent]);
  const handleGoToNextDay = e => {
    var _daysRef$current3;
    e.preventDefault();
    const currentDay = parseInt(e.target.id.split('-')[1], 10);
    if (currentDay + 1 > daysOfMonth.length) {
      handleShowNextMonth(e, false, true);
      return;
    }
    const nextDay = (_daysRef$current3 = daysRef.current) === null || _daysRef$current3 === void 0 ? void 0 : _daysRef$current3.querySelector(`#date-${currentDay + 1}`);
    nextDay.focus();
  };
  const handleGoToPrevDay = e => {
    var _daysRef$current4;
    e.preventDefault();
    const currentDay = parseInt(e.target.id.split('-')[1], 10);
    if (currentDay - 1 < 1) {
      handleShowPreviousMonth(e, true);
      return;
    }
    const previousDay = (_daysRef$current4 = daysRef.current) === null || _daysRef$current4 === void 0 ? void 0 : _daysRef$current4.querySelector(`#date-${currentDay - 1}`);
    previousDay.focus();
  };
  const handleGoToNextWeek = e => {
    var _daysRef$current5, _daysRef$current5$que;
    e.preventDefault();
    const currentDay = parseInt(e.target.id.split('-')[1], 10);
    const nextDate = currentDay + 7;
    if (nextDate > daysOfMonth.length) {
      handleShowNextMonth(e, false, true);
      return;
    }
    (_daysRef$current5 = daysRef.current) === null || _daysRef$current5 === void 0 ? void 0 : (_daysRef$current5$que = _daysRef$current5.querySelector(`#date-${nextDate}`)) === null || _daysRef$current5$que === void 0 ? void 0 : _daysRef$current5$que.focus();
  };
  const handleGoToPreviousWeek = e => {
    var _daysRef$current6, _daysRef$current6$que;
    e.preventDefault();
    const currentDay = parseInt(e.target.id.split('-')[1], 10);
    const prevDate = currentDay - 7;
    if (prevDate < 1) {
      handleShowPreviousMonth(e, true);
      return;
    }
    (_daysRef$current6 = daysRef.current) === null || _daysRef$current6 === void 0 ? void 0 : (_daysRef$current6$que = _daysRef$current6.querySelector(`#date-${prevDate}`)) === null || _daysRef$current6$que === void 0 ? void 0 : _daysRef$current6$que.focus();
  };
  const handleDayKeyPress = e => {
    switch (e.key) {
      case 'ArrowLeft':
        handleGoToPrevDay(e);
        break;
      case 'ArrowRight':
        handleGoToNextDay(e);
        break;
      case 'ArrowDown':
        handleGoToNextWeek(e);
        break;
      case 'ArrowUp':
        handleGoToPreviousWeek(e);
        break;
    }
  };
  return /*#__PURE__*/React.createElement(Portal, {
    disabled: !hoisted,
    container: portalContainer
  }, /*#__PURE__*/React.createElement("div", _extends({
    ref: ref,
    className: getCalendarContainerClasses(floating, sideContent, className),
    onMouseDownCapture: handlePreventDefault
  }, customProps), /*#__PURE__*/React.createElement("div", {
    className: "lmnt-datepicker__content"
  }, leadingContent, /*#__PURE__*/React.createElement("header", {
    className: "lmnt-datepicker__calendar-header"
  }, /*#__PURE__*/React.createElement(IconButton, {
    type: "button",
    className: "lmnt-datepicker__calendar-header-nav",
    dense: true,
    icon: "keyboard_arrow_left",
    disabled: leftNavDisabled,
    onClick: handleShowPreviousMonth
  }), /*#__PURE__*/React.createElement(Select, {
    value: matchMonthByVal(selectedMonth, months),
    dense: true,
    label: "",
    variant: "outlined",
    onChange: handleSelectMonth,
    disabled: disableChangeMonth,
    menuMaxHeight: "250px",
    options: months,
    textKey: "label",
    valueKey: "value",
    className: "lmnt-datepicker-calender__month-select"
  }), /*#__PURE__*/React.createElement(Select, {
    dense: true,
    label: "",
    value: selectedYear,
    variant: "outlined",
    onChange: handleSelectYear,
    disabled: disableChangeYear,
    menuMaxHeight: "250px",
    options: years,
    className: "lmnt-datepicker-calender__year-select"
  }), /*#__PURE__*/React.createElement(IconButton, {
    type: "button",
    dense: true,
    icon: "keyboard_arrow_right",
    disabled: rightNavDisabled,
    onClick: handleShowNextMonth
  }), headerContent), /*#__PURE__*/React.createElement("div", {
    className: "lmnt-datepicker__calendar-surface",
    ref: daysRef
  }, daysOfWeek.map(d => /*#__PURE__*/React.createElement(TypoCaption, {
    className: "lmnt-datepicker__day-header",
    key: `dp-dow-${d.value}`
  }, d.label)), blankDays.map(day => /*#__PURE__*/React.createElement("span", {
    className: "lmnt-datepicker__cell lmnt-datepicker__cell--day lmnt-datepicker__cell--blank",
    key: `dp-bd-${day}`
  })), daysOfMonth.map(day => /*#__PURE__*/React.createElement("button", {
    key: `dp-dow-${day.timestamp}`,
    "data-day": day.date,
    type: "button",
    id: `date-${day.date}`,
    onClick: event => handleSelectDate(day, event),
    onKeyDown: handleDayKeyPress,
    className: getCalendarDayClasses(day)
  }, dayCellTemplate(day)))), trailingContent), sideContent && /*#__PURE__*/React.createElement("div", {
    className: "lmnt-datepicker__side-content"
  }, /*#__PURE__*/React.createElement(SideContentContainer, null))));
});
Calendar.displayName = 'Calendar';
Calendar.propTypes = CalendarPropTypes;
Calendar.defaultProps = CalendarDefaultProps;

const DateInput = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    // calendarIsOpen,
    className,
    disableClearing,
    disabled,
    format,
    id,
    label,
    onClear,
    onClose,
    // onOpen,
    onArrowDown,
    onFocus,
    onMouseDown,
    onTypedDate,
    // openOnFocus,
    parseFormats,
    placeholder,
    readOnly,
    required,
    selectedDate,
    textfieldProps,
    typedDate,
    locale,
    useUtc,
    variant,
    ...customProps
  } = props;
  const textfieldRef = useRef();
  const [formattedValue, setFormattedValue] = useState('');
  const [idActual] = useState(() => id || edsRandomId());
  const clearDate = event => {
    onClear === null || onClear === void 0 ? void 0 : onClear(event);
  };
  const handleClearableOnKeyDown = event => {
    if (event.key === 'Enter') clearDate(event);
  };
  useImperativeHandle(externalRef, () => textfieldRef.current);

  // Attempt to parse a typed date
  const handleChanged = event => {
    onTypedDate === null || onTypedDate === void 0 ? void 0 : onTypedDate(event.target.value, event);
  };
  const showClearAction = () => !disableClearing && formattedValue;
  useEffect(() => {
    if (!selectedDate && !typedDate) {
      setFormattedValue('');
      return;
    }
    if (typedDate) {
      setFormattedValue(typedDate);
      return;
    }
    setFormattedValue(typeof format === 'function' ? format(selectedDate) : formatDate(selectedDate, format, locale));
  }, [format, locale, selectedDate, typedDate]);
  useKey(['ArrowDown'], e => {
    onArrowDown === null || onArrowDown === void 0 ? void 0 : onArrowDown(e);
  });
  const handleFocus = e => {
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
  };
  const handleMouseDown = e => {
    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(e);
  };
  return /*#__PURE__*/React.createElement(Textfield, _extends({
    autoComplete: "off",
    className: clsx('lmnt', 'lmnt-datepicker-input', className),
    disabled: disabled,
    id: idActual,
    label: label,
    leadingIcon: /*#__PURE__*/React.createElement(Icon, {
      icon: "event",
      tabIndex: -1
    }),
    onChange: handleChanged,
    onFocus: handleFocus,
    onMouseDown: handleMouseDown,
    placeholder: placeholder,
    readOnly: readOnly,
    ref: textfieldRef,
    required: required,
    tabIndex: 0,
    value: formattedValue,
    variant: variant,
    trailingIcon: showClearAction() ? /*#__PURE__*/React.createElement(IconButton, {
      type: "button",
      icon: "clear",
      dense: true,
      onClick: clearDate,
      onKeyDown: handleClearableOnKeyDown
    }) : undefined
  }, textfieldProps, customProps));
});
DateInput.displayName = 'DateInput';
DateInput.propTypes = DateInputPropTypes;
DateInput.defaultProps = DateInputDefaultProps;

const Datepicker = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alwaysOpen,
    beforeCalendarHeader,
    calendarProps,
    centuryBehavior,
    centurySlidingOffset,
    className,
    dayCellTemplate,
    disableChangeMonth,
    disableChangeYear,
    disableClearing,
    disabled,
    disabledDates,
    filled,
    format,
    fullMonthName,
    headerContent,
    highlightedDates,
    hoisted,
    id,
    inputTimeZone,
    // TODO: Unfinished feature
    label,
    leadingContent,
    locale,
    maxDate,
    maxQuickSelectYear,
    minDate,
    minQuickSelectYear,
    mondayFirst,
    onChange,
    onClear,
    onClose,
    onOpen,
    onSelect,
    onSelectDisable,
    onSelectDisabled,
    onSelectMonth,
    onSelectYear,
    openDate,
    outlined,
    outputTimeZone,
    // TODO: Unfinished feature
    parseFormats,
    placeholder,
    portalContainer,
    primary,
    readOnly,
    required,
    resetCalendarOnClose,
    secondary,
    sideContent,
    style,
    textfieldProps,
    trailingContent,
    typeable,
    useUtc,
    value,
    variant,
    ...customProps
  } = props;
  const hoistingContext = useContext(HoistingContext);
  const initialDate = getInitialDate(openDate || value, value, useUtc);
  const [idActual] = useState(() => id || edsRandomId());
  const [isOpen, setIsOpen] = useState(false);
  const [selectedDate, setSelectedDate] = useState(value);
  const [variantActual, setVariantActual] = useState(variant);
  const [typedDate, setTypedDate] = useState('');
  const calendarRef = useRef();
  const containerRef = useRef();
  const dateInputRef = useRef();
  const popperRef = useRef();
  const [visibleDate, setVisibleDate] = useState(initialDate);
  const [openOnFocus, setOpenOnFocus] = useState(true);
  const hoistedActual = hoisted || (hoistingContext === null || hoistingContext === void 0 ? void 0 : hoistingContext.enabled);
  useIsomorphicLayoutEffect(() => {
    const modifiers = [{
      name: 'flip',
      options: {
        enabled: true,
        fallbackPlacements: ['bottom-start', 'top-start', 'bottom-end', 'top-end']
      }
    }];
    popperRef.current = createPopper(dateInputRef.current.container, calendarRef.current, {
      placement: 'bottom-start',
      modifiers
    });
    return () => {
      var _popperRef$current;
      popperRef === null || popperRef === void 0 ? void 0 : (_popperRef$current = popperRef.current) === null || _popperRef$current === void 0 ? void 0 : _popperRef$current.destroy();
    };
  }, []);
  const showCalendar = useCallback(() => {
    var _calendarRef$current, _popperRef$current2, _popperRef$current3;
    setIsOpen(true);
    (_calendarRef$current = calendarRef.current) === null || _calendarRef$current === void 0 ? void 0 : _calendarRef$current.setAttribute('data-show', '');
    (_popperRef$current2 = popperRef.current) === null || _popperRef$current2 === void 0 ? void 0 : _popperRef$current2.setOptions(options => ({
      ...options,
      modifiers: [...options.modifiers, {
        name: 'eventListeners',
        enabled: true
      }]
    }));
    (_popperRef$current3 = popperRef.current) === null || _popperRef$current3 === void 0 ? void 0 : _popperRef$current3.update();
  }, []);
  const hideCalendar = useCallback(() => {
    var _calendarRef$current2, _popperRef$current4;
    setIsOpen(false);
    (_calendarRef$current2 = calendarRef.current) === null || _calendarRef$current2 === void 0 ? void 0 : _calendarRef$current2.removeAttribute('data-show');
    (_popperRef$current4 = popperRef.current) === null || _popperRef$current4 === void 0 ? void 0 : _popperRef$current4.setOptions(options => ({
      ...options,
      modifiers: [...options.modifiers, {
        name: 'eventListeners',
        enabled: false
      }]
    }));
  }, []);
  const handleClosed = useCallback((emitEvent, doSetFocus) => {
    var _dateInputRef$current;
    if (alwaysOpen) return;
    setTypedDate('');
    hideCalendar();
    onClose === null || onClose === void 0 ? void 0 : onClose(emitEvent);
    if (doSetFocus) (_dateInputRef$current = dateInputRef.current) === null || _dateInputRef$current === void 0 ? void 0 : _dateInputRef$current.focus();
    setOpenOnFocus(true);
    if (resetCalendarOnClose) setVisibleDate(firstOfMonth(selectedDate, useUtc));
  }, [alwaysOpen, hideCalendar, onClose, resetCalendarOnClose, selectedDate, useUtc]);
  useKey(['Escape'], event => {
    setOpenOnFocus(false);
    handleClosed(event, true);
  });
  const handleBlur = useCallback(event => {
    var _calendarRef$current3, _dateInputRef$current2;
    // Prevent the datepicker from automatically closing the calendar
    // when it is clicked on. This allows the Select controls to work
    // as well as any customized content to be interacted with.
    if (calendarRef !== null && calendarRef !== void 0 && (_calendarRef$current3 = calendarRef.current) !== null && _calendarRef$current3 !== void 0 && _calendarRef$current3.contains(event.relatedTarget) || dateInputRef !== null && dateInputRef !== void 0 && (_dateInputRef$current2 = dateInputRef.current) !== null && _dateInputRef$current2 !== void 0 && _dateInputRef$current2.input.parentElement.contains(event.relatedTarget)) return;
    handleClosed(event);
  }, [handleClosed]);
  const handleClear = useCallback(event => {
    setTypedDate('');
    setSelectedDate(null);
    setVisibleDate(firstOfMonth(null, useUtc));
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(null, event);
    onChange === null || onChange === void 0 ? void 0 : onChange(null, event);
    onClear === null || onClear === void 0 ? void 0 : onClear(event);
  }, [onChange, onClear, onSelect, useUtc]);
  const handleSetDate = useCallback((timestamp, event) => {
    const date = new Date(timestamp);
    setSelectedDate(date);
    setVisibleDate(firstOfMonth(date, useUtc));
    onSelect === null || onSelect === void 0 ? void 0 : onSelect(date, event);
    onChange === null || onChange === void 0 ? void 0 : onChange(date, event);
  }, [onChange, onSelect, useUtc]);
  const handleTypedDate = useCallback((val, event) => {
    if (!val) {
      handleClear(event);
      return;
    }
    setTypedDate(val);
    const parsed = parseDate(val, parseFormats, format, locale, centuryBehavior === 'age' ? centurySlidingOffset : -1);
    if (isValidDate(parsed, parseFormats, format)) {
      handleSetDate(parsed.getTime(), event);
    }
  }, [centuryBehavior, centurySlidingOffset, format, handleClear, handleSetDate, locale, parseFormats]);
  const handleSelectDate = useCallback((date, event) => {
    setTypedDate('');
    handleSetDate(date.getTime(), event);
    handleClosed(event);
  }, [handleClosed, handleSetDate]);
  const handleSelectMonth = useCallback((date, event) => {
    setVisibleDate(firstOfMonth(date, useUtc));
    onSelectMonth === null || onSelectMonth === void 0 ? void 0 : onSelectMonth(date, event);
  }, [onSelectMonth, useUtc]);
  const handleSelectYear = useCallback((date, event) => {
    setVisibleDate(firstOfMonth(date, useUtc));
    onSelectYear === null || onSelectYear === void 0 ? void 0 : onSelectYear(date, event);
  }, [onSelectYear, useUtc]);
  const handleSelectDisabledDate = useCallback((date, event) => {
    (onSelectDisable === null || onSelectDisable === void 0 ? void 0 : onSelectDisable(date, event)) || (onSelectDisabled === null || onSelectDisabled === void 0 ? void 0 : onSelectDisabled(date, event));
  }, [onSelectDisable, onSelectDisabled]);
  useEffect(() => {
    if (alwaysOpen) showCalendar();
    setIsOpen(alwaysOpen);
  }, [alwaysOpen, showCalendar]);
  useEffect(() => {
    setSelectedDate(value);
    setVisibleDate(getVisibleMonthYear(value, useUtc));
  }, [useUtc, value]);
  useEffect(() => {
    if (openDate === undefined) return;
    setVisibleDate(firstOfMonth(openDate, useUtc));
  }, [openDate, useUtc]);
  useImperativeHandle(externalRef, () => ({
    openCalendar: () => showCalendar(),
    closeCalendar: () => hideCalendar(),
    container: containerRef.current,
    input: dateInputRef.current,
    calendar: calendarRef.current
  }));
  useEffect(() => {
    setVariantActual(getVariant(primary, filled, secondary, outlined, variant));
  }, [variant, primary, filled, secondary, outlined]);
  useEffect(() => {
    /* eslint-disable no-undef */
    window.addEventListener('reset', handleClear);
    return () => {
      window.removeEventListener('reset', handleClear);
    };
    /* eslint-enable no-undef */
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const handleMouseDown = () => {
    showCalendar();
  };
  const handleArrowDown = () => {
    if (!isOpen) showCalendar();
  };
  const handleFocus = () => {
    if (openOnFocus && !isOpen) onOpen === null || onOpen === void 0 ? void 0 : onOpen();
  };
  return /*#__PURE__*/React.createElement("div", {
    ref: containerRef,
    className: getContainerClasses(className, props),
    onBlur: handleBlur,
    style: {
      position: 'relative',
      ...style
    }
  }, /*#__PURE__*/React.createElement(DateInput, _extends({
    disableClearing: disableClearing,
    disabled: disabled,
    format: format,
    id: idActual,
    label: label,
    locale: locale,
    onClear: handleClear,
    onClose: handleClosed,
    onMouseDown: handleMouseDown,
    onArrowDown: handleArrowDown,
    onFocus: handleFocus,
    onTypedDate: handleTypedDate,
    placeholder: placeholder,
    readOnly: getReadonly(typeable, readOnly),
    ref: dateInputRef,
    required: required,
    selectedDate: selectedDate,
    textfieldProps: textfieldProps,
    typedDate: typedDate,
    useUtc: useUtc,
    variant: variantActual
  }, customProps)), /*#__PURE__*/React.createElement(Calendar, _extends({
    dayCellTemplate: dayCellTemplate,
    disableChangeMonth: disableChangeMonth,
    disableChangeYear: disableChangeYear,
    disabledDates: disabledDates,
    floating: true,
    fullMonthName: fullMonthName,
    headerContent: headerContent,
    highlightedDates: highlightedDates,
    hoisted: hoistedActual,
    leadingContent: beforeCalendarHeader || leadingContent,
    locale: locale,
    maxDate: maxDate,
    maxQuickSelectYear: maxQuickSelectYear,
    minDate: minDate,
    minQuickSelectYear: minQuickSelectYear,
    mondayFirst: mondayFirst,
    onSelectDate: handleSelectDate,
    onSelectDisabled: handleSelectDisabledDate,
    onSelectMonth: handleSelectMonth,
    onSelectYear: handleSelectYear,
    portalContainer: portalContainer,
    ref: calendarRef,
    selectedDate: selectedDate,
    sideContent: sideContent,
    style: {
      display: isOpen ? 'block' : 'none'
    },
    trailingContent: trailingContent,
    useUtc: useUtc,
    visibleDate: visibleDate
  }, calendarProps)));
});
Datepicker.displayName = 'Datepicker';
Datepicker.propTypes = DatepickerPropTypes;
Datepicker.defaultProps = DatepickerDefaultProps;

export { Calendar, DateInput, Datepicker };
//# sourceMappingURL=index.es.js.map
