import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { forwardRef, useMemo, useState, useRef, useImperativeHandle, useEffect, useCallback } from 'react';
import { MDCDialog } from '@material/dialog';
import clsx from 'clsx';
import { deprecatedProp, deprecatedOneOf, edsRandomId, returnFocusAfterClosing } from '@element/react-common';
import capitalize from 'lodash/capitalize';
import omitBy from 'lodash/omitBy';
import { useEvent } from 'react-use';
import PropTypes from 'prop-types';
import { Button } from '@element/react-button';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const DialogPropTypes = {
  /**
   * Button for the approving action of the dialog. When pressed, the dialog will close.
   *
   * Defaults to **null**.
   */
  acceptButton: PropTypes.node,
  /**
   * slot/element for adding action buttons
   *
   * Defaults to **null**.
   */
  actions: PropTypes.node,
  /**
   * Button for the cancel/close action of the dialog. When pressed, the dialog will close.
   *
   * Defaults to **null**.
   */
  cancelButton: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Primary content of the dialog. Optional, children may be used instead.
   *
   * Defaults to **null**.
   */
  content: PropTypes.node,
  /**
   * Custom id for the content container. If one is not specified a random id will be generated.
   *
   * Defaults to **empty string**.
   */
  contentId: PropTypes.string,
  /**
   * Title information displayed at the top of the dialog.
   *
   * Defaults to **null**.
   */
  header: PropTypes.node,
  /**
   * Custom id for the header container. If one is not specified a random id will be generated.
   *
   * Defaults to **empty string**.
   */
  headerId: PropTypes.string,
  /**
   * Fired only when the closing action was triggered via dialog interaction.
   *
   * Defaults to **null**.
   */
  onAction: PropTypes.func,
  /**
   * Fired when the Dialog finishes its closing animation. Where `action` is the action which closed the dialog.
   *
   * Defaults to **null**.
   */
  onClosed: PropTypes.func,
  /**
   * Fired when the dialog begins its closing animation. action represents the action which closed the dialog.
   *
   * Defaults to **null**.
   */
  onClosing: PropTypes.func,
  /**
   * Fired when the dialog finishes its opening animation.
   *
   * Defaults to **null**.
   */
  onOpened: PropTypes.func,
  /**
   * Fired when the dialog begins its opening animation.
   *
   * Defaults to **null**.
   */
  onOpening: PropTypes.func,
  /**
   * If true, the dialog will be visible on screen.
   *
   * Defaults to **false**.
   */
  open: PropTypes.bool,
  /**
   * Prevents the user from closing the dialog by hitting escape or clicking the scrim.
   *
   * Defaults to **false**.
   */
  preventClose: PropTypes.bool,
  /**
   * DOM selector to provide a target to return focus. Accepts any valid _query_ (see mdn docs for Element.querySelector). If omitted focus will return to the last focused element upon closing.
   *
   * Defaults to **null**.
   */
  returnFocusSelector: PropTypes.string,
  /**
   * If true, the cancel button will be rendered beneath the accept button instead of side-by-side. Stacking of buttons happens automatically in cases where the button text is too long for all buttons to fit on a single line. Setting this prop to true is only required if you want to override this behavior.
   *
   * Defaults to **false**.
   */
  stackedButtons: PropTypes.bool
};
const DialogDefaultProps = {
  acceptButton: null,
  actions: null,
  cancelButton: null,
  className: undefined,
  content: null,
  contentId: "",
  header: null,
  headerId: "",
  open: false,
  preventClose: false,
  returnFocusSelector: null,
  stackedButtons: false
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const DialogActionPropTypes = {
  /**
   * Dialog action
   *
   * Defaults to **empty string**.
   */
  action: PropTypes.string,
  /**
   * children
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Focus element on dialog upon open
   *
   * Defaults to **null**.
   */
  focused: PropTypes.bool,
  /**
   * Base component that will be rendered
   *
   * Defaults to **'div'**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType, PropTypes.instanceOf(React.Component)]).isRequired
};
const DialogActionDefaultProps = {
  action: "",
  children: null,
  focused: null,
  tag: "div"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const DialogButtonPropTypes = {
  /**
   * @deprecated _Use `themeColor='secondary'` instead._
   *
   * Preview feature, this may change. Apply alternative button color scheme (defined by the individual theme).
   *
   * Defaults to **undefined**.
   */
  altColor: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `themeColor="secondary"` instead.'),
  /**
   * One of 'xsmall', 'small', 'medium', 'large' and 'xlarge' will change the size of the button. Defaults according to your theme.
   *
   * Defaults to **'themeDefault'**.
   */
  buttonSize: PropTypes.oneOf(["xsmall", "small", "medium", "large", "xlarge", "themeDefault"]),
  /**
   * Content to be rendered inside the button. Can be used instead `label` of to provide more flexibility. Accepts any valid markup. _Warning, if Label is set, it will be used instead of child content._
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * @deprecated _forwardRef has been implemented for Button._
   *
   * Reference to the DOM button. This enables a greater level of integration.
   *
   * Defaults to **undefined**.
   */
  customRef: deprecatedProp(PropTypes.oneOfType([PropTypes.func,
  // eslint-disable-next-line react/forbid-prop-types
  PropTypes.shape({
    current: PropTypes.any
  })]), "DialogButton", "forwardRef has been implemented for Button."),
  /**
   * @deprecated _Use `variant='danger'` instead._
   *
   * Apply danger style to the button.
   *
   * Defaults to **undefined**.
   */
  danger: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `variant="danger"` instead.'),
  /**
   * Prevent the user from interacting with the component.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * Sets elevation of the button. Default will be the theme default.
   *
   * Defaults to **'default'**.
   */
  elevation: PropTypes.oneOf(["default", "elevated", "flat"]),
  /**
   * @deprecated _Use `variant='filled'` instead._
   *
   * Apply a filled-in style. Previously called `primary`.
   *
   * Defaults to **undefined**.
   */
  filled: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `variant="filled"` instead.'),
  /**
   * Applies a full-width style where the textfield will fill it's container.
   *
   * Defaults to **false**.
   */
  fullWidth: PropTypes.bool,
  /**
   * The button will render as an anchor tag. If the tag prop is set, that prop will take precedence.
   *
   * Defaults to **null**.
   */
  href: PropTypes.string,
  /**
   * The displayed text. Expects a valid string. If label and children are both set, label will take priority.
   *
   * Defaults to **null**.
   */
  label: PropTypes.string,
  /**
   * Adds the given Icon to the left of the button text. May not be used with `trailingIcon` - if `leadingIcon` and `trailingIcon` are both set, `leadingIcon` will take priority. Expects the name of a valid Material.io icon, however an icon component may be passed in instead for more control,
   *
   * Defaults to **undefined**.
   */
  leadingIcon: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.node]),
  /**
   * The primary interaction event for button.
   *
   * Defaults to **null**.
   */
  onClick: PropTypes.func,
  /**
   * @deprecated _Use `variant='outlined'`._
   *
   * Apply outlined style to the button. Previously called `secondary`.
   *
   * Defaults to **undefined**.
   */
  outlined: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `variant="outlined"`.'),
  /**
   * @deprecated _Use `variant='filled'` instead._
   *
   * Apply primary style to the Button.
   *
   * Defaults to **undefined**.
   */
  primary: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `variant="filled"` instead.'),
  /**
   * @deprecated _Use `'variant=outlined'` instead._
   *
   * Apply secondary style to the Button.
   *
   * Defaults to **undefined**.
   */
  secondary: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `"variant=outlined"` instead.'),
  /**
   * By default a button or anchor tag will be rendered, this allows another tag/component to be used instead. A block type element/component is suggested.
   *
   * Defaults to **null**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType, PropTypes.instanceOf(React.Component)]),
  /**
   * @deprecated _Use `variant='embedded'` instead._
   *
   * Apply tertiary style to the Button.
   *
   * Defaults to **undefined**.
   */
  tertiary: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `variant="embedded"` instead.'),
  /**
   * @deprecated _Use `variant='text'` instead._
   *
   * Apply unfilled, un-outlined style to the Button. Previously called `tertiary`.
   *
   * Defaults to **undefined**.
   */
  text: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `variant="text"` instead.'),
  /**
   * Sets the theme color for the button. Most commonly used when the control is placed on a darker surface.
   *
   * Defaults to **'primary'**.
   */
  themeColor: deprecatedOneOf(PropTypes.oneOf(["primary", "secondary", "on-unknown-black", "on-unknown-white", "on-primary", "on-secondary", "on-success", "on-danger"]), ["onUnknownBlack", "onUnknownWhite"], "DialogButton", "Please use one of 'primary','secondary','on-unknown-black','on-unknown-white','on-primary','on-secondary','on-success','on-danger'."),
  /**
   * Adds the given Icon to the right of the button text. May not be used with `leadingIcon` - if `leadingIcon` and `trailingIcon` are both set, `leadingIcon` will take priority. Expects the name of a valid Material.io icon, however an icon component may be passed in instead for more control.
   *
   * Defaults to **undefined**.
   */
  trailingIcon: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.node]),
  /**
   * This applies the html button type (button, submit, reset) or the anchor media type when used with the href property.
   *
   * Defaults to **'button'**.
   */
  type: PropTypes.oneOf(["button", "submit", "reset"]),
  /**
   * @deprecated _Use `elevation='flat' instead._
   *
   * Remove elevation.
   *
   * Defaults to **undefined**.
   */
  unelevated: deprecatedProp(PropTypes.bool, "DialogButton", 'Use `elevation="flat" instead.'),
  /**
   * Applies the selected style to the button. `rounded-small` and `rounded-micro` are only available on select themes.
   *
   * Defaults to **'filled'**.
   */
  variant: PropTypes.oneOf(["filled", "outlined", "danger", "text", "rounded-small", "rounded-micro"])
};
const DialogButtonDefaultProps = {
  altColor: undefined,
  buttonSize: "themeDefault",
  children: null,
  className: undefined,
  customRef: undefined,
  danger: undefined,
  disabled: false,
  elevation: "default",
  filled: undefined,
  fullWidth: false,
  href: null,
  label: null,
  leadingIcon: undefined,
  outlined: undefined,
  primary: undefined,
  secondary: undefined,
  tag: null,
  tertiary: undefined,
  text: undefined,
  themeColor: "primary",
  trailingIcon: undefined,
  type: "button",
  unelevated: undefined,
  variant: "filled"
};

const Dialog = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    acceptButton,
    actions,
    cancelButton,
    children,
    className,
    content,
    contentId,
    header,
    headerId,
    onAction,
    onClosed,
    onClosing,
    onOpened,
    onOpening,
    open,
    preventClose,
    returnFocusSelector,
    scrollable,
    stackedButtons,
    ...customProps
  } = props;
  const filteredCustomProps = useMemo(() => omitBy(customProps, (value, key) => key.startsWith('onAction')), [customProps]);
  const [dialogRef, setDialogRef] = useState();
  const [mdcDialog, setMdcDialog] = useState();
  const [computedHeaderId] = useState(() => headerId || edsRandomId());
  const [computedContentId] = useState(() => contentId || edsRandomId());
  const ref = useRef();
  useImperativeHandle(externalRef, () => ref.current, []);
  const hasActions = cancelButton || acceptButton || actions;
  useEffect(() => {
    if (!dialogRef) {
      return;
    }
    const dialog = MDCDialog.attachTo(dialogRef);
    setMdcDialog(dialog);
    return () => {
      dialog.destroy();
    };
  }, [dialogRef]);
  useEffect(() => {
    if (!mdcDialog) {
      return;
    }
    let action = 'close';
    if (preventClose) {
      action = '';
    }
    mdcDialog.scrimClickAction = action;
    mdcDialog.escapeKeyAction = action;
  }, [mdcDialog, preventClose]);
  const onClosedCallback = useCallback(event => {
    if (returnFocusSelector) {
      returnFocusAfterClosing(returnFocusSelector);
    }
    if (onClosed) {
      onClosed(event);
    }
    const eventDetail = event.detail;
    const method = customProps[`onAction${capitalize(eventDetail.action)}`];
    if (method) {
      method();
    }
    if (eventDetail.action !== 'close' && onAction) {
      onAction(eventDetail);
    }
  }, [customProps, onAction, onClosed, returnFocusSelector]);
  useEvent('MDCDialog:closed', onClosedCallback, dialogRef);
  useEvent('MDCDialog:closing', onClosing, dialogRef);
  useEvent('MDCDialog:opening', onOpening, dialogRef);
  useEvent('MDCDialog:opened', onOpened, dialogRef);
  useEffect(() => {
    if (open) {
      mdcDialog === null || mdcDialog === void 0 ? void 0 : mdcDialog.open();
    } else {
      mdcDialog === null || mdcDialog === void 0 ? void 0 : mdcDialog.close();
    }
  }, [mdcDialog, open]);
  const onKeyDown = useCallback(event => {
    if (event.key !== 'Enter' || hasActions) {
      return;
    }

    // trigger a click event when user hits enter. For some reason material doesn't trigger an action on enter.
    // This is used for dialogs in which there are no action buttons, clicking on the items should close the dialog
    // TODO: look into removing this logic in the future if material fixes this
    if (dialogRef.contains(document.activeElement)) {
      document.activeElement.click();
    }
  }, [dialogRef, hasActions]);
  const dialogClasses = useMemo(() => clsx('lmnt', 'lmnt-dialog', 'mdc-dialog', stackedButtons && 'mdc-dialog--stacked', className), [className, stackedButtons]);
  return /*#__PURE__*/React.createElement("div", _extends({
    className: dialogClasses,
    ref: setDialogRef
  }, filteredCustomProps), /*#__PURE__*/React.createElement("div", {
    className: "mdc-dialog__container container"
  }, /*#__PURE__*/React.createElement("div", {
    className: "mdc-dialog__surface",
    role: "alertdialog",
    "aria-modal": "true",
    "aria-labelledby": computedHeaderId,
    "aria-describedby": computedContentId
  }, header && /*#__PURE__*/React.createElement("div", {
    className: "mdc-dialog__title",
    id: computedHeaderId
  }, header), /*#__PURE__*/React.createElement("div", {
    className: "mdc-dialog__content",
    id: computedContentId,
    onKeyDown: onKeyDown,
    role: "presentation"
  }, content || children), hasActions && /*#__PURE__*/React.createElement("div", {
    className: "mdc-dialog__actions"
  }, actions, cancelButton, acceptButton))), /*#__PURE__*/React.createElement("div", {
    className: "mdc-dialog__scrim"
  }));
});
Dialog.displayName = 'Dialog';
Dialog.propTypes = DialogPropTypes;
Dialog.defaultProps = DialogDefaultProps;
var Dialog$1 = /*#__PURE__*/React.memo(Dialog);

// eslint-disable-next-line no-undef
const DialogAction = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    action,
    focused,
    tag: Tag,
    children,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    "data-mdc-dialog-action": action,
    "data-mdc-dialog-initial-focus": focused
  }, customProps), children);
});
DialogAction.displayName = 'DialogAction';
DialogAction.propTypes = DialogActionPropTypes;
DialogAction.defaultProps = DialogActionDefaultProps;
var DialogAction$1 = /*#__PURE__*/React.memo(DialogAction);

const DialogButton = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    tag,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement(DialogAction$1, _extends({
    ref: externalRef,
    tag: tag || Button,
    className: clsx('mdc-dialog__button', className)
  }, customProps), children);
});
DialogButton.displayName = 'DialogButton';
DialogButton.propTypes = DialogButtonPropTypes;
DialogButton.defaultProps = DialogButtonDefaultProps;
var DialogButton$1 = /*#__PURE__*/React.memo(DialogButton);

export { Dialog$1 as Dialog, DialogAction$1 as DialogAction, DialogButton$1 as DialogButton };
//# sourceMappingURL=index.es.js.map
