import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { createContext, forwardRef, useRef, useState, useContext, useMemo, useEffect, useCallback, useImperativeHandle, Fragment } from 'react';
import { edsRandomId, getListVariant, getRole, getSelectedItemIndex } from '@element/shared';
import { requiredIfPropType, edsRandomId as edsRandomId$1, edsWarning } from '@element/react-common';
import { MenuContext } from '@element/react-menu';
import isEqual from 'lodash/isEqual';
import clsx from 'clsx';
import { Ripple } from '@element/react-ripple';
import { Radio } from '@element/react-radio';
import { Checkbox } from '@element/react-checkbox';
import { Switch } from '@element/react-switch';
import { Icon } from '@element/react-icon';
import { TypoSubtitle, TypoCaption } from '@element/react-typography';
import { LabelBadge } from '@element/react-badge';
import PropTypes from 'prop-types';
import { MDCList } from '@material/list';

const ListContext = /*#__PURE__*/createContext({});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListPropTypes = {
  /**
   * Name of the key for category ID in `items`.
   *
   * Defaults to **'id'**.
   */
  categoryIdKey: PropTypes.string,
  /**
   * Name of the key for category name in `items`.
   *
   * Defaults to **'categoryName'**.
   */
  categoryNameKey: PropTypes.string,
  /**
   * List content. Expects a 'ListItem'.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Name of the key for group ID in `items`. custom props to apply to each list item.
   *
   * Defaults to **'componentProps'**.
   */
  componentPropsKey: PropTypes.string,
  /**
   * Reduced height of list items.
   *
   * Defaults to **false**.
   */
  dense: PropTypes.bool,
  /**
   * Variant of divider padding.
   *
   * Defaults to **'full'**.
   */
  dividerVariant: PropTypes.oneOf(["full", "padded", "inset", "insetPadded"]),
  /**
   * Name of the key for group ID in `items`.
   *
   * Defaults to **'id'**.
   */
  groupIdKey: PropTypes.string,
  /**
   * Name of the key for group name in `items`.
   *
   * Defaults to **'groupName'**.
   */
  groupNameKey: PropTypes.string,
  /**
   * Name of the key for the id of the item in `items`.
   *
   * Defaults to **'id'**.
   */
  itemIdKey: PropTypes.string,
  /**
   * An array of objects to be rendered as `ListItems`. If `items` is set children will be ignored.
   *
   * Defaults to **null**.
   */
  items: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.object), PropTypes.arrayOf(PropTypes.string)]),
  /**
   * Name of the key for `items` in list schema.
   *
   * Defaults to **'items'**.
   */
  itemsKey: PropTypes.string,
  /**
   * The type of media that will render in the leading block of the `ListItems`. See README for size constraints. If `leadingBlockType` and `trailingBlockType` are both set to a control type (checkbox, radio or switch) `trailingBlockType` will be ignored.
   *
   * Defaults to **undefined**.
   */
  leadingBlockType: PropTypes.oneOf(["", "avatar", "checkbox", "icon", "image", "lgImage", "radio", "switch", "thumbnail"]),
  /**
   * Enables support for lists of navigation links. Each list item will be rendered as an anchor element by default unless overridden via the `component` prop on each list item.
   *
   * Defaults to **false**.
   */
  navigation: PropTypes.bool,
  /**
   * Use for a list that does not require interaction.
   *
   * Defaults to **false**.
   */
  nonInteractive: PropTypes.bool,
  /**
   * Fired when a List Item is activated.
   *
   * Defaults to **null**.
   */
  onAction: PropTypes.func,
  /**
   * Name of the key for `overlineText` in `items`.
   *
   * Defaults to **'overlineText'**.
   */
  overlineTextKey: PropTypes.string,
  /**
   * Name of the key for `primaryText` in `items`.
   *
   * Defaults to **'primaryText'**.
   */
  primaryTextKey: PropTypes.string,
  /**
   * The aria role of the list. For selection list use  `listbox`. For menu list use `menu`. For radio list use `radiogroup`. For checkbox list use `group`. For non-interactive list do not set.
   *
   * Defaults to **'listbox'**.
   */
  role: PropTypes.oneOf(["", "listbox", "menu", "radiogroup", "group"]),
  /**
   * Name of the key for `secondaryText` in `items`.
   *
   * Defaults to **'secondaryText'**.
   */
  secondaryTextKey: PropTypes.string,
  /**
   * Item or array of selected `ListItems`.
   *
   * Defaults to **null**.
   */
  selected: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.object, PropTypes.arrayOf(PropTypes.string), PropTypes.arrayOf(PropTypes.number), PropTypes.arrayOf(PropTypes.object)]),
  /**
   * Whether or not to show a divider between list items, groups, or categories.
   *
   * Defaults to **true**.
   */
  showDivider: PropTypes.bool,
  /**
   * When true group and category lists will be treated like one list for single selection type lists.
   *
   * Defaults to **true**.
   */
  singleList: PropTypes.bool,
  /**
   * Customized background color.
   *
   * Defaults to **empty string**.
   */
  themeColor: PropTypes.oneOf(["", "surface", "primary", "secondary"]),
  /**
   * The type of media that will render in the trailing block of the `ListItems`. See README for size constraints. If `leadingBlockType` and `trailingBlockType` are both set to a control type (checkbox, radio or switch) `trailingBlockType` will be ignored.
   *
   * Defaults to **undefined**.
   */
  trailingBlockType: PropTypes.oneOf(["", "avatar", "badge", "checkbox", "icon", "image", "lgImage", "meta", "radio", "switch", "thumbnail"]),
  /**
   * Allows keyboard navigation to jump to the top or bottom of the list to enable continuous navigation.
   *
   * Defaults to **true**.
   */
  wrapFocus: PropTypes.bool
};
const ListDefaultProps = {
  categoryIdKey: "id",
  categoryNameKey: "categoryName",
  children: null,
  componentPropsKey: "componentProps",
  dense: false,
  dividerVariant: "full",
  groupIdKey: "id",
  groupNameKey: "groupName",
  itemIdKey: "id",
  items: null,
  itemsKey: "items",
  leadingBlockType: undefined,
  navigation: false,
  nonInteractive: false,
  overlineTextKey: "overlineText",
  primaryTextKey: "primaryText",
  role: "listbox",
  secondaryTextKey: "secondaryText",
  selected: null,
  showDivider: true,
  singleList: true,
  themeColor: "",
  trailingBlockType: undefined,
  wrapFocus: true
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListDividerPropTypes = {
  /**
   * Variant of the divider padding.
   *
   * Defaults to **'full'**.
   */
  variant: PropTypes.oneOf(["full", "padded", "inset", "insetPadded"])
};
const ListDividerDefaultProps = {
  variant: "full"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListGroupPropTypes = {
  /**
   * Expects one or more List or ListGroupSubHeader.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
};
const ListGroupDefaultProps = {
  children: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListGroupDividerPropTypes = {};
const ListGroupDividerDefaultProps = {};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Expects a string but accepts any valid markup or components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListItemPropTypes = {
  /**
   * Alternate styling for selected interactive items without a control. Activation represents a status with more permanence (e.g., current page in a navigation list).
   *
   * Defaults to **false**.
   */
  activated: PropTypes.bool,
  /**
   * Whether or not the list item's radio or checkbox is selected for radio or checkbox lists.
   *
   * Defaults to **false**.
   */
  ariaChecked: PropTypes.bool,
  /**
   * Content to be rendered inside the list item content block. Most often a string, but accepts any valid markup. When using primaryText, secondaryText or overlineText the children will be ignored.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Tells list item not to put selected class to add background to the list item.
   *
   * Defaults to **false**.
   */
  disableHighlight: PropTypes.bool,
  /**
   * Disable interaction for the ListItem within an interactive List.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * Used with Select.
   *
   * Defaults to **false**.
   */
  isChildOption: PropTypes.bool,
  /**
   * Content to be displayed in the leading block container. See README for types supported. If a string is sent for a control type, it will used for the `name` attribute on the control. For radio type controls, send the same name for every item.
   *
   * Defaults to **null**.
   */
  leadingBlock: requiredIfPropType(PropTypes.node, "ListItem", "leadingBlockType"),
  /**
   * The type of media that will render in the leading block. See README for size constraints. If `leadingBlockType` is set on the parent List, it will take precedence. If `leadingBlockType` and `trailingBlockType` are both set to a control type (checkbox, radio or switch) `trailingBlockType` will be ignored.
   *
   * Defaults to **empty string**.
   */
  leadingBlockType: PropTypes.oneOf(["", "avatar", "checkbox", "icon", "image", "lgImage", "radio", "switch", "thumbnail"]),
  /**
   * A hover style will not be applied.
   *
   * Defaults to **false**.
   */
  noHover: PropTypes.bool,
  /**
   * Used within a list that does not require interaction. See `disabled` for disabling an item within an interactive list.
   *
   * Defaults to **false**.
   */
  nonInteractive: PropTypes.node,
  /**
   * Fired when the user clicks the ListItem. Returns the event as the first argument and any specified value as the second argument.
   *
   * Defaults to **null**.
   */
  onClick: PropTypes.func,
  /**
   * Fired when the user presses a key down.
   *
   * Defaults to **null**.
   */
  onKeyPress: PropTypes.func,
  /**
   * Text that will appear above the standard text.
   *
   * Defaults to **null**.
   */
  overlineText: PropTypes.node,
  /**
   * Standard list text.
   *
   * Defaults to **null**.
   */
  primaryText: PropTypes.node,
  /**
   * Text that will appear below the standard text.
   *
   * Defaults to **null**.
   */
  secondaryText: PropTypes.node,
  /**
   * A selected style will be applied. Selection represents a choice that might change frequently (e.g., option in a list). Required by selected interactive items without a control.
   *
   * Defaults to **false**.
   */
  selected: PropTypes.bool,
  /**
   * Component to be rendered as each list item. Normal lists use `li` elements, nav lists use `a` elements. You would use this for example if you want to use a router link component as each list item.
   *
   * Defaults to **null**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType, PropTypes.instanceOf(React.Component)]),
  /**
   * Customized background color.
   *
   * Defaults to **empty string**.
   */
  themeColor: PropTypes.oneOf(["", "surface", "primary", "secondary"]),
  /**
   * Content to be displayed in the trailing block container. See README for types supported. If a string is sent for a control type, it will used for the `name` attribute on the control. For radio type controls, send the same name for every item.
   *
   * Defaults to **null**.
   */
  trailingBlock: requiredIfPropType(PropTypes.node, "ListItem", "trailingBlockType"),
  /**
   * The type of media that will render in the trailing block. See README for size constraints. If `trailingBlockType` is set on the parent List, it will take precedence. If `leadingBlockType` and `trailingBlockType` are both set to a control type (checkbox, radio or switch) `trailingBlockType` will be ignored.
   *
   * Defaults to **undefined**.
   */
  trailingBlockType: PropTypes.oneOf(["", "avatar", "badge", "checkbox", "icon", "image", "lgImage", "meta", "radio", "switch", "thumbnail"]),
  /**
   * A custom value to be returned as the second onClick argument.
   *
   * Defaults to **null**.
   */
  value: PropTypes.node,
  /**
   * Used to adjust the padding of the `ListItem` when used as a category or group header.
   *
   * Defaults to **'standard'**.
   */
  variant: PropTypes.oneOf(["standard", "category", "group"]),
  /**
   * Determines the text wrapping mode of the list item: `wrap` will wrap text like normal, `truncate` will truncate text with an ellipsis and `noWrap` will truncate the text by clipping.
   *
   * Defaults to **'wrap'**.
   */
  wrapMode: PropTypes.oneOf(["wrap", "noWrap", "truncate"])
};
const ListItemDefaultProps = {
  activated: false,
  ariaChecked: false,
  children: null,
  disableHighlight: false,
  disabled: false,
  isChildOption: false,
  leadingBlock: null,
  leadingBlockType: "",
  noHover: false,
  nonInteractive: false,
  overlineText: null,
  primaryText: null,
  secondaryText: null,
  selected: false,
  tag: null,
  themeColor: "",
  trailingBlock: null,
  trailingBlockType: undefined,
  value: null,
  variant: "standard",
  wrapMode: "wrap"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListItemContentPropTypes = {
  /**
   * Content to be rendered inside the list item primary text content block. Most often a string, but accepts any valid markup. When using primaryText, secondaryText or overlineText the children will be ignored.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Text that will appear above the standard text.
   *
   * Defaults to **null**.
   */
  overlineText: PropTypes.node,
  /**
   * Standard list text. `children` may also be used but will require additional styling. Use `primaryText` instead of `children` when using overline or secondary text.
   *
   * Defaults to **null**.
   */
  primaryText: PropTypes.node,
  /**
   * Text that will appear below the standard text.
   *
   * Defaults to **null**.
   */
  secondaryText: PropTypes.node
};
const ListItemContentDefaultProps = {
  children: null,
  overlineText: null,
  primaryText: null,
  secondaryText: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListItemLeadingBlockPropTypes = {
  /**
   * Media or control to be rendered in the List Item's Leading Block
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
};
const ListItemLeadingBlockDefaultProps = {
  children: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListItemOverlinePropTypes = {
  /**
   * Expects a string but accepts any valid markup or components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
};
const ListItemOverlineDefaultProps = {
  children: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListItemPrimaryTextPropTypes = {
  /**
   * Expects a string but accepts any valid markup or components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
};
const ListItemPrimaryTextDefaultProps = {
  children: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListItemSecondaryTextPropTypes = {
  /**
   * Expects a string but accepts any valid markup or components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
};
const ListItemSecondaryTextDefaultProps = {
  children: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListItemTrailingBlockPropTypes = {
  /**
   * Media, control or text to be rendered in the List Item's Trailing Block
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
};
const ListItemTrailingBlockDefaultProps = {
  children: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListItemsListPropTypes = {
  /**
   * The List Items to be rendered in the Lists. If `items` is set children will be ignored.
   *
   * Defaults to **null**.
   */
  items: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.object), PropTypes.arrayOf(PropTypes.string)])
};
const ListItemsListDefaultProps = {
  items: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ListWrapperPropTypes = {};
const ListWrapperDefaultProps = {};

const ListItemOverline = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("span", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'mdc-list-item__overline-text', className)
  }, customProps), children);
});
ListItemOverline.displayName = 'ListItemOverline';
ListItemOverline.propTypes = ListItemOverlinePropTypes;
ListItemOverline.defaultProps = ListItemOverlineDefaultProps;

const ListItemSecondaryText = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("span", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'mdc-list-item__secondary-text', className)
  }, customProps), children);
});
ListItemSecondaryText.displayName = 'ListItemSecondaryText';
ListItemSecondaryText.defaultProps = ListItemSecondaryTextDefaultProps;
ListItemSecondaryText.propTypes = ListItemSecondaryTextPropTypes;

const ListItemPrimaryText = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("span", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'mdc-list-item__primary-text', className)
  }, customProps), children);
});
ListItemPrimaryText.displayName = 'ListItemPrimaryText';
ListItemPrimaryText.propTypes = ListItemPrimaryTextPropTypes;
ListItemPrimaryText.defaultProps = ListItemPrimaryTextDefaultProps;

const ListItemContent = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    overlineText,
    primaryText,
    secondaryText,
    children,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("span", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'mdc-list-item__content', className)
  }, customProps), overlineText && /*#__PURE__*/React.createElement(ListItemOverline, null, overlineText), primaryText && /*#__PURE__*/React.createElement(ListItemPrimaryText, null, primaryText), secondaryText && /*#__PURE__*/React.createElement(ListItemSecondaryText, null, secondaryText));
});
ListItemContent.displayName = 'ListItemContent';
ListItemContent.propTypes = ListItemContentPropTypes;
ListItemContent.defaultProps = ListItemContentDefaultProps;

const ListItemLeadingBlock = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("span", _extends({
    ref: externalRef,
    className: clsx('mdc-list-item__start', className)
  }, customProps), children);
});
ListItemLeadingBlock.displayName = 'ListItemLeadingBlock';
ListItemLeadingBlock.propTypes = ListItemLeadingBlockPropTypes;
ListItemLeadingBlock.defaultProps = ListItemLeadingBlockDefaultProps;

const ListItemTrailingBlock = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("span", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'mdc-list-item__end', className)
  }, customProps), children);
});
ListItemTrailingBlock.displayName = 'ListItemTrailingBlock';
ListItemTrailingBlock.propTypes = ListItemTrailingBlockPropTypes;
ListItemTrailingBlock.defaultProps = ListItemTrailingBlockDefaultProps;

const ListItem = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    activated,
    ariaChecked,
    children,
    className,
    disableHighlight,
    disabled,
    id,
    isChildOption,
    leadingBlock,
    leadingBlockType,
    noHover,
    nonInteractive,
    onClick,
    onKeyPress,
    onMouseMove,
    onMouseOver,
    overlineText,
    primaryText,
    secondaryText,
    selected,
    tag,
    themeColor,
    trailingBlock,
    trailingBlockType,
    value,
    variant,
    wrapMode,
    ...customProps
  } = props;
  const ref = useRef();
  const [lineClass, setLineClass] = useState('mdc-list-item--with-one-line');
  const listState = useContext(ListContext);
  const leadingBlockTypeToUse = listState.leadingBlockType || leadingBlockType;
  const trailingBlockTypeToUse = listState.trailingBlockType || trailingBlockType;
  const content = primaryText || children;

  //
  // Note: To prevent a mouse scrolling issue with grouped lists we need to
  // keep onMouseOver and onMouseMove (created by react-select) in state to
  // prevent unnecessary re-renders. This works by making sure we set
  // onMouseMoveActual and onMouseOverActual once and only once, otherwise it
  // will trigger a re-render every time. The dependency array is
  // intentionally left empty.
  //
  // Addendum: Further testing has shown that even with this optimization, the
  // issue can still appear with grouped menus in certain cases. The mouse
  // over and mouse move functionality will now be disabled for those cases.
  // Any side effects are unknown at this time.
  //
  const onMouseOverActual = useMemo(() => listState.role !== 'group' ? onMouseOver : undefined,
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  const onMouseMoveActual = useMemo(() => listState.role !== 'group' ? onMouseMove : undefined,
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  const Tag = useMemo(() => {
    if (variant !== 'standard') {
      return 'h3';
    }
    if (tag) {
      return tag;
    }
    if (listState.navigation) {
      return 'a';
    }
    return 'li';
  }, [variant, listState.navigation, tag]);
  useEffect(() => {
    if (primaryText && overlineText && secondaryText) {
      setLineClass('mdc-list-item--with-three-lines');
    } else if (primaryText && secondaryText || overlineText && secondaryText) setLineClass('mdc-list-item--with-two-lines');
  }, [primaryText, overlineText, secondaryText]);
  const getRole = (roleLocal, leadingBlockTypeLocal, trailingBlockTypeLocal) => {
    if (roleLocal === 'radiogroup' || leadingBlockTypeLocal === 'radio' || trailingBlockTypeLocal === 'radio') return 'radio';
    if (roleLocal === 'group' || leadingBlockTypeLocal === 'switch' || leadingBlockTypeLocal === 'checkbox' || trailingBlockTypeLocal === 'switch ' || trailingBlockTypeLocal === 'checkbox') return 'checkbox';
    if (roleLocal === 'listbox') return 'option';
    if (roleLocal === 'menu') return 'menuItem';
    return null;
  };
  const handleOnClick = useCallback(e => {
    !listState.nonInteractive && !disabled && (onClick === null || onClick === void 0 ? void 0 : onClick(e, value));
  }, [listState.nonInteractive, disabled, onClick, value]);
  const getBlock = (type, block, contentLocal, ariaCheckedLocal, randomId, suppressIfLeading) => {
    switch (type) {
      case 'checkbox':
        if (suppressIfLeading) return null;
        return !block || typeof block === 'string' ? /*#__PURE__*/React.createElement(Checkbox, {
          hideLabel: true,
          label: contentLocal,
          checked: ariaCheckedLocal
        }) : block;
      case 'icon':
        return typeof block === 'string' ? /*#__PURE__*/React.createElement(Icon, {
          icon: block
        }) : block;
      case 'radio':
        if (suppressIfLeading) return null;
        return !block || typeof block === 'string' ? /*#__PURE__*/React.createElement(Radio, {
          hideLabel: true,
          label: contentLocal,
          name: block || randomId,
          checked: ariaCheckedLocal
        }) : block;
      case 'switch':
        if (suppressIfLeading) return null;
        return !block || typeof block === 'string' ? /*#__PURE__*/React.createElement(Switch, {
          hideLabel: true,
          label: contentLocal
        }) : block;
      case 'badge':
        return typeof block === 'string' ? /*#__PURE__*/React.createElement(LabelBadge, {
          label: block
        }) : block;
      default:
        if (!type) return null;
        return block;
    }
  };
  const leadingBlockToUse = useMemo(() => {
    const type = leadingBlockTypeToUse;
    return getBlock(type, leadingBlock, content, ariaChecked, listState.randomId, false);
  }, [leadingBlockTypeToUse, leadingBlock, content, ariaChecked, listState.randomId]);
  const trailingBlockToUse = useMemo(() => {
    const type = listState.trailingBlockType || trailingBlockType;
    const isLeadingControl = leadingBlockTypeToUse === 'checkbox' || leadingBlockTypeToUse === 'radio' || leadingBlockTypeToUse === 'switch';
    return getBlock(type, trailingBlock, content, ariaChecked, listState.randomId, isLeadingControl);
  }, [ariaChecked, content, leadingBlockTypeToUse, listState.randomId, listState.trailingBlockType, trailingBlock, trailingBlockType]);
  const getBlockClasses = (blockName, blockType) => {
    switch (blockType) {
      case 'avatar':
        return `mdc-list-item--with-${blockName}-avatar`;
      case 'checkbox':
        return `mdc-list-item--with-${blockName}-checkbox`;
      case 'icon':
        return `mdc-list-item--with-${blockName}-icon`;
      case 'image':
        return `mdc-list-item--with-${blockName}-image`;
      case 'radio':
        return `mdc-list-item--with-${blockName}-radio`;
      case 'switch':
        return `mdc-list-item--with-${blockName}-switch`;
      case 'thumbnail':
        return `mdc-list-item--with-${blockName}-thumbnail`;
      case 'lgImage':
        return `mdc-list-item--with-${blockName}-video`;
      case 'badge':
        return `mdc-list-item--with-${blockName}-badge`;
      default:
        return null;
    }
  };
  const standardClasses = useMemo(() => {
    let classes;
    if (!variant || variant === 'standard') {
      const leadingBlockClasses = getBlockClasses('leading', leadingBlockTypeToUse);
      const trailingBlockClasses = getBlockClasses('trailing', trailingBlockTypeToUse);
      classes = clsx(['mdc-list-item', `lmnt-theme-${themeColor}-bg`, lineClass, (listState.nonInteractive || nonInteractive) && 'mdc-list-item--non-interactive', leadingBlockClasses, trailingBlockClasses]);
    }
    return classes;
  }, [variant, leadingBlockTypeToUse, trailingBlockTypeToUse, themeColor, lineClass, listState.nonInteractive, nonInteractive]);
  const classes = clsx(['lmnt', standardClasses, (!listState.nonInteractive || nonInteractive) && listState.navigation && (ariaChecked || activated) && 'mdc-list-item--activated', (!listState.nonInteractive || nonInteractive) && (!disableHighlight || isChildOption) && (ariaChecked || selected) && 'mdc-list-item--selected', (listState.nonInteractive || noHover || nonInteractive) && 'lmnt-list-item__no-hover', disabled && 'mdc-list-item--disabled', wrapMode === 'truncate' && 'lmnt-list-item--truncate', wrapMode === 'noWrap' && 'lmnt-list-item--no-wrap', wrapMode === 'wrap' && 'lmnt-list-item--wrap ', variant === 'group' && 'mdc-list-group__subheader lmnt-list-group__subheader', variant === 'category' && 'lmnt-list-group__category-header', className]);
  const role = getRole(listState.role, leadingBlockTypeToUse, trailingBlockTypeToUse);
  useImperativeHandle(externalRef, () => ref.current, []);
  return /*#__PURE__*/React.createElement(Ripple, {
    componentRef: ref
  }, /*#__PURE__*/React.createElement(Tag, _extends({
    id: id,
    "aria-checked": ariaChecked,
    ref: ref,
    role: role,
    onClick: handleOnClick,
    className: classes,
    onKeyPress: onKeyPress,
    onMouseMove: onMouseMoveActual,
    onMouseOver: onMouseOverActual
  }, customProps), /*#__PURE__*/React.createElement("span", {
    className: "mdc-list-item__ripple"
  }), variant === 'standard' && leadingBlockToUse && /*#__PURE__*/React.createElement(ListItemLeadingBlock, null, leadingBlockToUse), variant !== 'standard' && variant === 'category' && /*#__PURE__*/React.createElement(TypoSubtitle, {
    level: 0
  }, content), variant !== 'standard' && variant === 'group' && listState.listType === 'group' && /*#__PURE__*/React.createElement(TypoSubtitle, {
    level: 2
  }, content), variant !== 'standard' && variant === 'group' && listState.listType === 'category' && /*#__PURE__*/React.createElement(TypoCaption, null, content), variant === 'standard' && /*#__PURE__*/React.createElement(ListItemContent, {
    primaryText: content,
    overlineText: variant === 'standard' && overlineText,
    secondaryText: variant === 'standard' && secondaryText
  }), variant === 'standard' && trailingBlockToUse && /*#__PURE__*/React.createElement(ListItemTrailingBlock, null, trailingBlockToUse)));
});
ListItem.displayName = 'ListItem';
ListItem.propTypes = ListItemPropTypes;
ListItem.defaultProps = ListItemDefaultProps;

const ListDivider = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    variant,
    className,
    ...customProps
  } = props;
  const {
    leadingBlockType,
    navigation
  } = useContext(ListContext);
  const Tag = useMemo(() => {
    if (navigation) {
      return 'hr';
    }
    return 'li';
  }, [navigation]);
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    role: "separator",
    className: clsx('mdc-list-divider', 'lmnt-list-divider', (variant === 'padded' || variant === 'insetPadded') && 'lmnt-list-divider--with-padding', (variant === 'insetPadded' || variant === 'inset') && 'lmnt-list-divider--with-inset', leadingBlockType === 'avatar' && ' mdc-list-divider--with-leading-avatar', leadingBlockType === 'checkbox' && ' mdc-list-divider--with-leading-checkbox', leadingBlockType === 'icon' && ' mdc-list-divider--with-leading-icon', leadingBlockType === 'image' && ' mdc-list-divider--with-leading-image', leadingBlockType === 'largeImage' && ' mdc-list-divider--with-leading-video', leadingBlockType === 'radio' && ' mdc-list-divider--with-leading-radio', leadingBlockType === 'switch' && ' mdc-list-divider--with-leading-switch', leadingBlockType === 'thumbnail' && ' mdc-list-divider--with-leading-thumbnail', className)
  }, customProps));
});
ListDivider.displayName = 'ListDivider';
ListDivider.propTypes = ListDividerPropTypes;
ListDivider.defaultProps = ListDividerDefaultProps;

const ListItemsList = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    items,
    group,
    selectedIndex
  } = props;
  const {
    showDivider,
    dividerVariant,
    categoryNameKey,
    secondaryTextKey,
    overlineTextKey,
    groupNameKey,
    primaryTextKey,
    role,
    singleList,
    componentPropsKey
  } = useContext(ListContext);
  const [randomId] = useState(() => edsRandomId());
  if (!Array.isArray(items)) {
    return children;
  }
  return items === null || items === void 0 ? void 0 : items.map((item, itemIndex) => {
    let itemText = item[primaryTextKey];
    if (!itemText && typeof item === 'string') itemText = item;
    const secondaryText = item[secondaryTextKey];
    const overlineText = item[overlineTextKey];
    const listVariant = getListVariant(item, groupNameKey, categoryNameKey);
    let isChecked;
    if (role === 'group') {
      if (Array.isArray(selectedIndex) && selectedIndex.length) {
        isChecked = selectedIndex.indexOf(itemIndex) !== -1;
      }
    } else {
      isChecked = selectedIndex === itemIndex;
    }
    let leadingBlockToSend;
    let trailingBlockToSend;
    if ((!item.leadingBlock || typeof item.trailingBlock !== 'string') && role === 'radiogroup' && !singleList) {
      leadingBlockToSend = randomId;
    } else {
      leadingBlockToSend = item.leadingBlock;
    }
    if ((!item.trailingBlock || typeof item.trailingBlock !== 'string') && role === 'radiogroup' && !singleList) {
      trailingBlockToSend = randomId;
    } else {
      trailingBlockToSend = item.trailingBlock;
    }
    const componentProps = item[componentPropsKey] || {};
    return /*#__PURE__*/React.createElement(Fragment, {
      key: itemText || secondaryText || overlineText
    }, /*#__PURE__*/React.createElement(ListItem, _extends({
      ref: externalRef,
      key: itemText,
      tabIndex: itemIndex === 0 ? 0 : -1,
      variant: listVariant,
      secondaryText: secondaryText,
      primaryText: itemText,
      overlineText: overlineText,
      leadingBlock: leadingBlockToSend,
      trailingBlock: trailingBlockToSend,
      ariaChecked: isChecked
    }, componentProps)), !group && showDivider && items.length > itemIndex + 1 && /*#__PURE__*/React.createElement(ListDivider, {
      variant: dividerVariant
    }));
  });
});
ListItemsList.displayName = 'ListItemsList';
ListItemsList.propTypes = ListItemsListPropTypes;
ListItemsList.defaultProps = ListItemsListDefaultProps;

const ListGroupDivider = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("hr", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'lmnt-list-divider', 'mdc-list-divider', className)
  }, customProps));
});
ListGroupDivider.displayName = 'ListGroupDivider';
ListGroupDivider.propTypes = ListGroupDividerPropTypes;
ListGroupDivider.defaultProps = ListGroupDividerDefaultProps;

const ListRoot = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    categoryId,
    categoryIdKey,
    categoryNameKey,
    children,
    className,
    componentPropsKey,
    customRef,
    dense,
    dividerVariant,
    groupId,
    groupIdKey,
    groupItems,
    groupNameKey,
    groupSelectedIndex,
    inMenu,
    itemIdKey,
    items,
    itemsKey,
    leadingBlockType,
    listType,
    navigation,
    nonInteractive,
    onAction,
    overlineTextKey,
    primaryTextKey,
    role,
    roleToUse,
    secondaryTextKey,
    selected,
    showDivider,
    singleList,
    themeColor,
    trailingBlockType,
    wrapFocus,
    ...customProps
  } = props;
  const ref = useRef(customRef || null);
  const mdcList = useRef();
  const formatSelectedGroup = useCallback((group, groupIndex, selectedIndex) => {
    const name = group[groupNameKey];
    const selectedItem = group[itemsKey][selectedIndex];
    return {
      selectedGroup: name,
      selectedGroupIndex: groupIndex,
      selectedGroupId: group[groupIdKey] || name,
      selectedIndex,
      selectedItem: typeof selectedItem === 'string' ? selectedItem : selectedItem[itemIdKey] || selectedItem[primaryTextKey]
    };
  }, [groupIdKey, groupNameKey, itemIdKey, itemsKey, primaryTextKey]);
  const getGroupIndex = useCallback((selectedGroupId, list) => list.findIndex(group => selectedGroupId === group[groupIdKey] || selectedGroupId === group[groupNameKey]), [groupIdKey, groupNameKey]);
  const getCatIndex = useCallback((selectedCategoryId, list) => list.findIndex(cat => selectedCategoryId === cat[categoryIdKey] || selectedCategoryId === cat[categoryNameKey]), [categoryIdKey, categoryNameKey]);
  const getSingleSelectedGroupId = useCallback((list, selectedGroupId, selectedIndex) => {
    const groupIndex = getGroupIndex(selectedGroupId, list);
    if (groupIndex === -1) return {};
    const group = items[groupIndex];
    return formatSelectedGroup(group, groupIndex, selectedIndex);
  }, [formatSelectedGroup, getGroupIndex, items]);
  const formatSelectedCategory = useCallback((cat, catIndex) => {
    const catName = cat[categoryNameKey];
    return {
      selectedCategory: catName,
      selectedCategoryIndex: catIndex,
      selectedCategoryId: cat[categoryIdKey] || catName
    };
  }, [categoryIdKey, categoryNameKey]);
  const getCategoryActivatedId = useCallback((selectedCategoryId, selectedGroupId, index) => {
    const catIndex = getCatIndex(selectedCategoryId, items);
    if (catIndex === -1) return {};
    const cat = items[catIndex];
    return {
      ...formatSelectedCategory(cat, catIndex),
      ...getSingleSelectedGroupId(cat[itemsKey], selectedGroupId, index)
    };
  }, [formatSelectedCategory, getCatIndex, getSingleSelectedGroupId, items, itemsKey]);
  const getActivated = useCallback((index, selectedGroupId, selectedCategoryId) => {
    if (listType === 'category') return getCategoryActivatedId(selectedCategoryId, selectedGroupId, index);
    if (listType === 'group') return getSingleSelectedGroupId(items, selectedGroupId, index);
    return items ? items[index][itemIdKey] || items[index] : index;
  }, [listType, getCategoryActivatedId, getSingleSelectedGroupId, items, itemIdKey]);
  const getSelectedCategoryIds = useCallback((selectedCategoryId, selectedGroupId, selectedIndex) => {
    const catIndex = getCatIndex(selectedCategoryId, items);
    if (catIndex === -1) return [];
    const cat = items[catIndex];
    const groups = cat[itemsKey];
    const groupIndex = getGroupIndex(selectedGroupId, groups);
    if (groupIndex === -1) return [];
    const group = groups[groupIndex];

    // Does this check still need to be performed?
    if (group[itemsKey].length <= selectedIndex) return [];
    return [{
      ...formatSelectedCategory(cat, catIndex),
      ...formatSelectedGroup(group, groupIndex, selectedIndex)
    }];
  }, [formatSelectedCategory, formatSelectedGroup, getCatIndex, getGroupIndex, items, itemsKey]);
  const getSelectedGroupIds = useCallback((selectedGroupId, selectedIndex) => {
    const selectedIds = [];
    const groupIndex = getGroupIndex(selectedGroupId, items);
    if (groupIndex === -1) return [];
    const group = items[groupIndex];
    selectedIds.push(formatSelectedGroup(group, groupIndex, selectedIndex));
    return selectedIds;
  }, [formatSelectedGroup, getGroupIndex, items]);
  const getMultiSelectedIds = useCallback((selectedIndex, selectedGroupId, selectedCategoryId) => {
    const selectedIds = selectedIndex.reduce((output, si) => {
      if (listType === 'simple') {
        output.push(items[si][itemIdKey] || items[si]);
      }
      if (listType === 'category') {
        output.splice(output.length - 1, 0, ...getSelectedCategoryIds(selectedCategoryId, selectedGroupId, si));
      }
      if (listType === 'group') {
        const selectedGroupIds = getSelectedGroupIds(selectedGroupId, si);
        output.splice(output.length - 1, 0, ...selectedGroupIds);
      }
      return output;
    }, []);
    return selectedIds;
  }, [getSelectedCategoryIds, getSelectedGroupIds, itemIdKey, items, listType]);
  const getSingleSelectedCategoryId = useCallback((selectedCategoryId, selectedGroupId, selectedIndex) => {
    const catIndex = getCatIndex(selectedCategoryId, items);
    if (catIndex === -1) return {};
    const cat = items[catIndex];
    const groups = cat[itemsKey];
    const groupIndex = getGroupIndex(selectedGroupId, groups);
    if (groupIndex === -1) return {};
    const group = groups[groupIndex];
    return {
      ...formatSelectedCategory(cat, catIndex),
      ...formatSelectedGroup(group, groupIndex, selectedIndex)
    };
  }, [formatSelectedCategory, formatSelectedGroup, getCatIndex, getGroupIndex, items, itemsKey]);
  const getBasicSelectedId = useCallback(selectedIndex => items && selectedIndex > -1 ? items[selectedIndex][itemIdKey] || items[selectedIndex] : selectedIndex, [itemIdKey, items]);
  const getSingleSelectedId = useCallback((selectedCategoryId, selectedGroupId, selectedIndex) => {
    if (listType === 'category') {
      return getSingleSelectedCategoryId(selectedCategoryId, selectedGroupId, selectedIndex);
    }
    if (listType === 'group') {
      return getSingleSelectedGroupId(items, selectedGroupId, selectedIndex);
    }
    return getBasicSelectedId(selectedIndex);
  }, [getBasicSelectedId, getSingleSelectedCategoryId, getSingleSelectedGroupId, items, listType]);
  const getSelected = useCallback((selectedIndex, selectedGroupId, selectedCategoryId) => {
    if (roleToUse === 'group') {
      return getMultiSelectedIds(selectedIndex, selectedGroupId, selectedCategoryId);
    }
    if (singleList) {
      return getSingleSelectedId(selectedCategoryId, selectedGroupId, selectedIndex);
    }
    return getBasicSelectedId(selectedIndex);
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [groupIdKey, groupNameKey, itemIdKey, items, itemsKey, listType, primaryTextKey, roleToUse, singleList, categoryIdKey, categoryNameKey]);
  const handleOnAction = useCallback(e => {
    var _mdcList$current;
    onAction && onAction(getActivated(e.detail.index, groupId, categoryId), getSelected((_mdcList$current = mdcList.current) === null || _mdcList$current === void 0 ? void 0 : _mdcList$current.foundation.getSelectedIndex(), groupId, categoryId), groupId, categoryId, e);
  }, [categoryId, onAction, getActivated, getSelected, groupId]);
  useEffect(() => {
    if (inMenu) return undefined;
    mdcList.current = new MDCList(ref.current);
    return () => {
      var _mdcList$current2;
      (_mdcList$current2 = mdcList.current) === null || _mdcList$current2 === void 0 ? void 0 : _mdcList$current2.destroy();
    };
  }, [inMenu, mdcList]);
  useEffect(() => {
    var _mdcList$current3;
    (_mdcList$current3 = mdcList.current) === null || _mdcList$current3 === void 0 ? void 0 : _mdcList$current3.listen('MDCList:action', handleOnAction);
    return () => {
      var _mdcList$current4;
      (_mdcList$current4 = mdcList.current) === null || _mdcList$current4 === void 0 ? void 0 : _mdcList$current4.unlisten('MDCList:action', handleOnAction);
    };
  }, [handleOnAction]);
  useEffect(() => {
    if (mdcList.current) mdcList.current.wrapFocus = wrapFocus;
  }, [wrapFocus]);
  useEffect(() => {
    var _mdcList$current5, _mdcList$current6;
    const singleSelect = roleToUse === 'listbox' || roleToUse === 'radiogroup';
    (_mdcList$current5 = mdcList.current) === null || _mdcList$current5 === void 0 ? void 0 : _mdcList$current5.foundation.setSingleSelection(singleSelect);
    if (roleToUse && !singleSelect && ((_mdcList$current6 = mdcList.current) === null || _mdcList$current6 === void 0 ? void 0 : _mdcList$current6.foundation.getSelectedIndex()) === -1) {
      mdcList.current.foundation.isCheckboxList_ = true;
      mdcList.current.foundation.setSelectedIndex([]);
    }
    if (singleSelect && mdcList.current) mdcList.current.foundation.isCheckboxList_ = false;
  }, [roleToUse]);
  const Tag = navigation ? 'nav' : 'ul';
  useImperativeHandle(externalRef, () => ref.current, []);
  return /*#__PURE__*/React.createElement(Tag, _extends({
    "aria-multiselectable": leadingBlockType === 'checkbox' || trailingBlockType === 'checkbox' || leadingBlockType === 'switch' || trailingBlockType === 'switch' || roleToUse === 'group',
    "data-evolution": "true",
    ref: ref,
    role: roleToUse,
    "aria-orientation": "vertical",
    className: clsx('lmnt', 'lmnt-list', 'mdc-list', `lmnt-theme-${themeColor}-bg`, dense && 'lmnt-list--dense', listType === 'category' && 'lmnt-nested-list', className)
  }, customProps), children);
});
ListRoot.displayName = 'ListRoot';
ListRoot.propTypes = ListPropTypes;
ListRoot.defaultProps = ListDefaultProps;

const ListWrapper = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    variant
  } = props;
  if (variant === 'group') return /*#__PURE__*/React.createElement("div", {
    ref: externalRef,
    className: clsx('mdc-list-group', className)
  }, children);
  if (variant === 'category') return /*#__PURE__*/React.createElement("div", {
    ref: externalRef,
    className: clsx('lmnt-list-category', className)
  }, children);
  // eslint-disable-next-line react/jsx-no-useless-fragment
  return /*#__PURE__*/React.createElement(React.Fragment, null, children);
});
ListWrapper.displayName = 'ListWrapper';
ListWrapper.propTypes = ListWrapperPropTypes;
ListWrapper.defaultProps = ListWrapperDefaultProps;

const List = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    categoryIdKey,
    categoryNameKey,
    children,
    className,
    componentPropsKey,
    customRef,
    dense,
    dividerVariant,
    groupIdKey,
    groupNameKey,
    itemIdKey,
    items,
    itemsKey,
    leadingBlockType,
    listType,
    multiSelect,
    navigation,
    nonInteractive,
    onAction,
    overlineTextKey,
    primaryTextKey,
    role,
    secondaryTextKey,
    selected,
    showDivider,
    singleList,
    themeColor,
    trailingBlockType,
    wrapFocus,
    ...customProps
  } = props;
  const ref = useRef(customRef || null);
  useImperativeHandle(externalRef, () => ref.current, []);
  const [allSelected, setAllSelected] = useState(selected);
  const [randomId] = useState(() => edsRandomId$1());
  const {
    inMenu
  } = useContext(MenuContext);
  useEffect(() => {
    if (items && items.length > 0 && children) {
      edsWarning('List: Items should not be used with children. If both are sent children will be ignored.');
    }
  }, [items, children]);
  const listTypeToUse = useMemo(() => {
    if (Array.isArray(items) && items[0] && typeof items[0] === 'object' && items[0][categoryNameKey]) return 'category';
    if (Array.isArray(items) && items[0] && typeof items[0] === 'object' && items[0][groupNameKey]) return 'group';
    return listType || 'simple';
  }, [categoryNameKey, groupNameKey, items, listType]);
  const [roleToUse, setRoleToUse] = useState(() => getRole(props));
  useEffect(() => {
    setRoleToUse(getRole({
      leadingBlockType,
      trailingBlockType,
      nonInteractive,
      role
    }));
  }, [leadingBlockType, trailingBlockType, nonInteractive, role]);
  const handleOnAction = useCallback((activated, selectedItems) => {
    if (onAction && roleToUse) {
      if (listTypeToUse === 'simple') {
        onAction(activated, selectedItems);
        setAllSelected(selectedItems);
      } else if (singleList) {
        if (roleToUse !== 'group') {
          onAction(activated, selectedItems);
        } else {
          if (!allSelected) {
            setAllSelected(selectedItems);
            onAction(activated, selectedItems);
            return;
          }
          const newAllSelected = [...allSelected];
          const deactivation = allSelected.findIndex(ai => {
            if (listTypeToUse === 'category') {
              return ai.selectedCategoryId === activated.selectedCategoryId && ai.selectedGroupId === activated.selectedGroupId && ai.selectedItem === activated.selectedItem;
            }
            return ai.selectedGroupId === activated.selectedGroupId && ai.selectedItem === activated.selectedItem;
          });
          if (deactivation !== -1) {
            newAllSelected.splice(deactivation, 1);
            setAllSelected(newAllSelected);
            onAction(activated, newAllSelected);
            return;
          }
          newAllSelected.push(activated);
          setAllSelected(newAllSelected);
          onAction(activated, newAllSelected);
        }
      } else {
        onAction(activated, selectedItems);
      }
    }
  }, [allSelected, listTypeToUse, onAction, roleToUse, singleList]);
  const createGroup = useCallback((RootElement, item, groupIndex, divider, categoryId, categoryIndex) => {
    const itemText = item[groupNameKey];
    if (!itemText) return null;
    const variant = getListVariant(item, groupNameKey, categoryNameKey);
    const id = item[groupIdKey] || itemText;
    const groupSelectedIndex = getSelectedItemIndex(groupIndex, categoryIndex, roleToUse, singleList ? selected : selected[id], singleList);
    return /*#__PURE__*/React.createElement(Fragment, {
      key: id
    }, /*#__PURE__*/React.createElement(ListItem, {
      variant: variant,
      primaryText: itemText
    }), /*#__PURE__*/React.createElement(RootElement, _extends({
      inMenu: inMenu,
      ref: ref,
      categoryId: categoryId,
      groupId: id,
      itemsKey: itemsKey,
      primaryTextKey: primaryTextKey,
      onAction: handleOnAction,
      showDivider: showDivider,
      className: className,
      dense: dense,
      items: items,
      leadingBlockType: leadingBlockType,
      listType: listTypeToUse,
      roleToUse: roleToUse,
      trailingBlockType: trailingBlockType,
      groupNameKey: groupNameKey,
      groupIdKey: groupIdKey,
      categoryNameKey: categoryNameKey,
      selected: selected,
      groupItems: item[itemsKey],
      groupSelectedIndex: groupSelectedIndex,
      componentPropsKey: componentPropsKey
    }, customProps), /*#__PURE__*/React.createElement(ListItemsList, {
      items: item[itemsKey],
      selectedIndex: groupSelectedIndex,
      group: true
    }), divider && items.length > groupIndex + 1 && /*#__PURE__*/React.createElement(ListGroupDivider, null)));
  }, [categoryNameKey, singleList, className, customProps, dense, groupIdKey, groupNameKey, handleOnAction, inMenu, items, itemsKey, leadingBlockType, listTypeToUse, primaryTextKey, roleToUse, selected, showDivider, trailingBlockType, componentPropsKey]);
  const content = useMemo(() => {
    if (!items && children) {
      return /*#__PURE__*/React.createElement(ListRoot, _extends({
        inMenu: inMenu,
        ref: ref,
        itemsKey: itemsKey,
        onAction: handleOnAction,
        showDivider: showDivider,
        className: className,
        dense: dense,
        items: items,
        leadingBlockType: leadingBlockType,
        listType: listTypeToUse,
        roleToUse: roleToUse,
        trailingBlockType: trailingBlockType,
        groupNameKey: groupNameKey,
        categoryNameKey: categoryNameKey,
        categoryIdKey: categoryIdKey,
        componentPropsKey: componentPropsKey,
        navigation: navigation
      }, customProps), children);
    }
    if (listTypeToUse === 'simple') {
      let selectedIndex;
      if (roleToUse === 'group') {
        selectedIndex = [];
        if (Array.isArray(selected)) {
          selected === null || selected === void 0 ? void 0 : selected.forEach(s => {
            items === null || items === void 0 ? void 0 : items.forEach((item, i) => {
              if (s === item || s === item[itemIdKey] || s === i[primaryTextKey]) selectedIndex.push(i);
            });
          });
        }
      } else {
        selectedIndex = items === null || items === void 0 ? void 0 : items.findIndex(item => {
          if (typeof item === 'string') {
            return item === selected;
          }
          if (typeof item === 'object') {
            if (item[itemIdKey] || item[itemIdKey] === 0) {
              return item[itemIdKey] === selected;
            }
            return isEqual(item, selected);
          }
          return null;
        });
      }
      return /*#__PURE__*/React.createElement(ListRoot, _extends({
        inMenu: inMenu,
        ref: ref,
        itemsKey: itemsKey,
        onAction: handleOnAction,
        showDivider: showDivider,
        className: className,
        dense: dense,
        themeColor: themeColor,
        items: items,
        leadingBlockType: leadingBlockType,
        listType: listTypeToUse,
        roleToUse: roleToUse,
        trailingBlockType: trailingBlockType,
        groupNameKey: groupNameKey,
        categoryNameKey: categoryNameKey,
        categoryIdKey: categoryIdKey,
        componentPropsKey: componentPropsKey,
        navigation: navigation
      }, customProps), /*#__PURE__*/React.createElement(ListItemsList, {
        items: items,
        selectedIndex: selectedIndex
      }, !items && children));
    }
    if (listTypeToUse === 'group') {
      return items === null || items === void 0 ? void 0 : items.map((item, itemIndex) => createGroup(ListRoot, item, itemIndex, showDivider));
    }
    if (listTypeToUse === 'category') {
      return items === null || items === void 0 ? void 0 : items.map((item, itemIndex) => {
        const itemText = item[categoryNameKey];
        if (!itemText) return null;
        const variant = getListVariant(item, groupNameKey, categoryNameKey);
        const id = item[categoryIdKey] || itemText;
        return /*#__PURE__*/React.createElement(Fragment, {
          key: id
        }, /*#__PURE__*/React.createElement(ListWrapper, {
          variant: "group",
          className: `lmnt-nested-list mdc-list lmnt-theme-${themeColor}-bg`
        }, /*#__PURE__*/React.createElement(ListItem, {
          variant: variant,
          primaryText: itemText
        }), item[itemsKey].map((group, groupIndex) => createGroup(ListRoot, group, groupIndex, false, id, itemIndex))), showDivider && items.length > itemIndex + 1 && /*#__PURE__*/React.createElement(ListGroupDivider, null));
      });
    }
    return null;
  }, [createGroup, inMenu, itemsKey, showDivider, children, className, customProps, dense, items, leadingBlockType, listTypeToUse, roleToUse, trailingBlockType, groupNameKey, categoryNameKey, selected, categoryIdKey, handleOnAction, primaryTextKey, itemIdKey, componentPropsKey, navigation, themeColor]);
  const value = useMemo(() => ({
    role: roleToUse,
    nonInteractive,
    leadingBlockType,
    trailingBlockType,
    showDivider,
    dividerVariant,
    selected,
    listType: listTypeToUse,
    categoryNameKey,
    secondaryTextKey,
    overlineTextKey,
    groupNameKey,
    primaryTextKey,
    randomId,
    singleList,
    navigation,
    componentPropsKey
  }), [categoryNameKey, componentPropsKey, dividerVariant, groupNameKey, leadingBlockType, listTypeToUse, navigation, nonInteractive, overlineTextKey, primaryTextKey, randomId, roleToUse, secondaryTextKey, selected, showDivider, singleList, trailingBlockType]);
  return /*#__PURE__*/React.createElement(ListContext.Provider, {
    value: value
  }, /*#__PURE__*/React.createElement(ListWrapper, {
    variant: listTypeToUse
  }, content));
});
List.displayName = 'List';
List.propTypes = ListPropTypes;
List.defaultProps = ListDefaultProps;

const ListGroup = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'lmnt-list-group', 'mdc-list-group', className)
  }, customProps), children);
});
ListGroup.displayName = 'ListGroup';
ListGroup.propTypes = ListGroupPropTypes;
ListGroup.defaultProps = ListGroupDefaultProps;

const ListGroupSubHeader = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    className,
    children,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("h3", _extends({
    ref: externalRef,
    className: clsx('mdc-list-group__subheader lmnt-list-group__subheader', className)
  }, customProps), /*#__PURE__*/React.createElement(TypoSubtitle, {
    level: 2
  }, children));
});
ListGroupSubHeader.displayName = 'ListGroupSubHeader';
ListGroupSubHeader.propTypes = {
  className: PropTypes.string,
  children: PropTypes.node
};
ListGroupSubHeader.defaultProps = {
  children: null,
  className: ''
};

export { List, ListContext, ListDivider, ListGroup, ListGroupDivider, ListGroupSubHeader as ListGroupSubheader, ListItem, ListItemContent, ListItemLeadingBlock, ListItemOverline, ListItemPrimaryText, ListItemSecondaryText, ListItemsList, ListWrapper };
//# sourceMappingURL=index.es.js.map
