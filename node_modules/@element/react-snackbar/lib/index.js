'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime-corejs3/helpers/extends');
var React = require('react');
var clsx = require('clsx');
var snackbar = require('@material/snackbar');
var reactCommon = require('@element/react-common');
var PropTypes = require('prop-types');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefault(_extends);
var React__default = /*#__PURE__*/_interopDefault(React);
var clsx__default = /*#__PURE__*/_interopDefault(clsx);
var PropTypes__default = /*#__PURE__*/_interopDefault(PropTypes);

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const SnackbarPropTypes = {
  /**
   * Optional action button label. If set, an action button will be shown.
   *
   * Defaults to **null**.
   */
  actionLabel: PropTypes__default["default"].string,
  /**
   * Most commonly a string, but will accept any valid components or markup. If `label` and `children` are both set, `label` will take priority.
   *
   * Defaults to **null**.
   */
  children: PropTypes__default["default"].node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes__default["default"].string,
  /**
   * Sets whether the Snackbar closes when it is focused and the user presses the ESC key.
   *
   * Defaults to **true**.
   */
  closeOnEscape: PropTypes__default["default"].bool,
  /**
   * Optional dismiss button label. If set, an button button will be shown.
   *
   * Defaults to **null**.
   */
  dismissLabel: PropTypes__default["default"].string,
  /**
   * The snackbar text. If `label` and `children` are both set, `label` will take priority.
   *
   * Defaults to **null**.
   */
  label: PropTypes__default["default"].string,
  /**
   * Positions the Snackbar on the leading edge of the screen (left in LTR, right in RTL) instead of centered.
   *
   * Defaults to **false**.
   */
  leading: PropTypes__default["default"].bool,
  /**
   * Fired when the Snackbar action button is clicked.
   *
   * Defaults to **null**.
   */
  onClick: PropTypes__default["default"].func,
  /**
   * Fired when the Snackbar finishes its closing animation.
   *
   * Defaults to **null**.
   */
  onClose: PropTypes__default["default"].func,
  /**
   * Fired when the Snackbar begins it's closing animation.
   *
   * Defaults to **null**.
   */
  onClosing: PropTypes__default["default"].func,
  /**
   * Fired when the Snackbar finishes its opening animation.
   *
   * Defaults to **null**.
   */
  onOpen: PropTypes__default["default"].func,
  /**
   * Fired when the Snackbar begins it's opening animation.
   *
   * Defaults to **null**.
   */
  onOpening: PropTypes__default["default"].func,
  /**
   * Indicates that the Snackbar is open and visible.
   *
   * Defaults to **false**.
   */
  open: PropTypes__default["default"].bool,
  /**
   * Positions the action button/icon below the label instead of alongside it.
   *
   * Defaults to **false**.
   */
  stacked: PropTypes__default["default"].bool,
  /**
   * The time the snackbar will remain visible. The value must be between `4000` and `10000` or set to `-1` to disable the timeout.
   *
   * Defaults to **5000**.
   */
  timeout: PropTypes__default["default"].number
};
const SnackbarDefaultProps = {
  actionLabel: null,
  children: null,
  className: undefined,
  closeOnEscape: true,
  dismissLabel: null,
  label: null,
  leading: false,
  open: false,
  stacked: false,
  timeout: 5000
};

const Snackbar = /*#__PURE__*/React.forwardRef((props, externalRef) => {
  const {
    actionLabel,
    children,
    className,
    closeOnEscape,
    dismissLabel,
    label,
    leading,
    onClick,
    onClose,
    onClosing,
    onOpen,
    onOpening,
    open,
    stacked,
    timeout,
    ...customProps
  } = props;
  const mdcSnackbar = React.useRef();
  const ref = React.useRef();
  React.useImperativeHandle(externalRef, () => ref.current, []);
  React.useEffect(() => {
    mdcSnackbar.current = snackbar.MDCSnackbar.attachTo(ref.current);
    return () => {
      mdcSnackbar.current.destroy();
    };
  }, []);
  React.useEffect(() => {
    mdcSnackbar.current.listen('MDCSnackbar:closed', onClose);
    return () => {
      mdcSnackbar.current.unlisten('MDCSnackbar:closed', onClose);
    };
  }, [onClose]);
  React.useEffect(() => {
    mdcSnackbar.current.listen('MDCSnackbar:closed', onClosing);
    return () => {
      mdcSnackbar.current.unlisten('MDCSnackbar:closed', onClosing);
    };
  }, [onClosing]);
  React.useEffect(() => {
    mdcSnackbar.current.listen('MDCSnackbar:closed', onOpen);
    return () => {
      mdcSnackbar.current.unlisten('MDCSnackbar:closed', onOpen);
    };
  }, [onOpen]);
  React.useEffect(() => {
    mdcSnackbar.current.listen('MDCSnackbar:closed', onOpening);
    return () => {
      mdcSnackbar.current.unlisten('MDCSnackbar:closed', onOpening);
    };
  }, [onOpening]);
  React.useEffect(() => {
    if (actionLabel) mdcSnackbar.current.actionButtonText = actionLabel;
  }, [actionLabel]);
  React.useEffect(() => {
    if (label) mdcSnackbar.current.labelText = label;
  }, [label]);
  React.useEffect(() => {
    if (open) mdcSnackbar.current.open();
    if (!open) mdcSnackbar.current.close();
  }, [open]);
  React.useEffect(() => {
    mdcSnackbar.current.closeOnEscape = closeOnEscape;
  }, [closeOnEscape]);
  React.useEffect(() => {
    if (timeout && (timeout === -1 || timeout >= 4000 && timeout <= 10000)) {
      mdcSnackbar.current.timeoutMs = timeout;
    } else {
      reactCommon.edsWarning('Timeout must be between `4000` and `10000` or set to `-1` to disable.');
    }
  }, [timeout]);
  return /*#__PURE__*/React__default["default"].createElement("div", _extends__default["default"]({
    ref: ref,
    className: clsx__default["default"]('lmnt', 'mdc-snackbar', 'lmnt-snackbar', leading && 'mdc-snackbar--leading', stacked && 'mdc-snackbar--stacked', className)
  }, customProps), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-snackbar__surface",
    role: "status",
    "aria-relevant": "additions"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-snackbar__label",
    "aria-atomic": "false"
  }, children), (actionLabel || dismissLabel) && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-snackbar__actions",
    "aria-atomic": "true"
  }, actionLabel && /*#__PURE__*/React__default["default"].createElement("button", {
    tabIndex: 0,
    className: "mdc-button mdc-snackbar__action",
    type: "button",
    onClick: onClick
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-button__ripple"
  }), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "mdc-button__label"
  }, actionLabel)), dismissLabel && /*#__PURE__*/React__default["default"].createElement("button", {
    tabIndex: 0,
    className: "mdc-button mdc-snackbar__action",
    type: "button"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-button__ripple"
  }), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "mdc-button__label"
  }, dismissLabel)))));
});
Snackbar.displayName = 'Snackbar';
Snackbar.propTypes = SnackbarPropTypes;
Snackbar.defaultProps = SnackbarDefaultProps;

exports.Snackbar = Snackbar;
//# sourceMappingURL=index.js.map
