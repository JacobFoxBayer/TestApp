import _extends from '@babel/runtime-corejs3/helpers/extends';
import clsx from 'clsx';
import React, { createContext, forwardRef, useContext, useEffect, useState, useRef, useCallback, useMemo, useImperativeHandle, Fragment } from 'react';
import { TextBubble } from '@element/react-text-bubble';
import { TypoSubtitle, TypoCaption } from '@element/react-typography';
import { Icon } from '@element/react-icon';
import PropTypes from 'prop-types';
import { Button } from '@element/react-button';
import { Divider } from '@element/react-divider';
import { ConditionalWrapper } from '@element/react-common';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const StepperPropTypes = {
  /**
   * Change the default border. The Stepper will normally have a bottom border in horizontal mode and a trailing border in vertical mode.
   *
   * Defaults to **'default'**.
   */
  border: PropTypes.oneOf(["none", "default"]),
  /**
   * Steps to be rendered inside the Stepper when managing Stepper state in a parent application. Not needed when using the `steps` prop.
   *
   * Defaults to **undefined**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * The steps will be closer together with smaller icons.
   *
   * Defaults to **false**.
   */
  dense: PropTypes.bool,
  /**
   * Non-linear will allow the user to navigate steps in any order by making the individual steps clickable.
   *
   * Defaults to **false**.
   */
  nonLinear: PropTypes.bool,
  /**
   * Optionally override the current active step. Only used when tracking Stepper progress in the parent application.
   *
   * Defaults to **undefined**.
   */
  progress: PropTypes.number,
  /**
   * Improves layout for right-to-left languages.
   *
   * Defaults to **false**.
   */
  rtl: PropTypes.bool,
  /**
   * An array of objects describing the steps to show. See readme for full schema.
   *
   * Defaults to **undefined**.
   */
  steps: PropTypes.arrayOf(PropTypes.object),
  /**
   * By default StepButton will render a div, this allow another tag to be used instead. A block type component is suggested.
   *
   * Defaults to **'div'**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),
  /**
   * Stacks steps vertically.
   *
   * Defaults to **false**.
   */
  vertical: PropTypes.bool
};
const StepperDefaultProps = {
  border: "default",
  children: undefined,
  className: undefined,
  dense: false,
  nonLinear: false,
  progress: undefined,
  rtl: false,
  steps: undefined,
  tag: "div",
  vertical: false
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const StepPropTypes = {
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Optionally override the global Stepper density. The step will be smaller with smaller icons.
   *
   * Defaults to **false**.
   */
  dense: PropTypes.bool,
  /**
   * Set this flag to have a step display incomplete or in error/danger while maintaining internal variant logic. It is commonly useful with form validation. This will only show when a linear Stepper has moved beyond the flagged step. For non-linear Steppers, it will always show if the flag is set except for the active step.
   *
   * Defaults to **undefined**.
   */
  errorState: PropTypes.oneOf(["incomplete", "danger"]),
  /**
   * A unique id used to associate the step with StepContent when using StepperContainer.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * Fired when the step is clicked. Primarily used in non-linear mode.
   *
   * Defaults to **undefined**.
   */
  onClick: PropTypes.func,
  /**
   * Fired when the step becomes visible. Note: the order of the parameters follows the Stepper convention of the step being entered followed by the step being left.
   *
   * Defaults to **undefined**.
   */
  onStepEnter: PropTypes.func,
  /**
   * Fired when the step becomes invisible. Note: the order of the parameters follows the Stepper convention of the step being entered followed by the step being left.
   *
   * Defaults to **undefined**.
   */
  onStepLeave: PropTypes.func,
  /**
   * Secondary text for the given step.
   *
   * Defaults to **undefined**.
   */
  secondaryText: PropTypes.node,
  /**
   * Optionally override the stepIndex. Normally, this is automatically calculated when using Stepper with a StepperContainer.
   *
   * Defaults to **undefined**.
   */
  stepIndex: PropTypes.number,
  /**
   * Optionally override the default component of `button`. If using a tag other than `button` or `input`, keyboard events (such as onKeyUp) will need to be added for accessability compliance.
   *
   * Defaults to **'button'**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType]),
  /**
   * Optional custom props to be passed to the TextBubble. See the Element TextBubble for more information.
   *
   * Defaults to **undefined**.
   */
  textBubbleProps: PropTypes.object,
  /**
   * Optionally override the text for the TextBubble. This is normally managed by the parent Stepper.
   *
   * Defaults to **undefined**.
   */
  textBubbleText: PropTypes.object,
  /**
   * Optionally override the TextBubble themeColor. This is normally managed by the parent Stepper.
   *
   * Defaults to **undefined**.
   */
  textBubbleThemeColor: PropTypes.object,
  /**
   * Primary text for the given step.
   *
   * Defaults to **undefined**.
   */
  title: PropTypes.node,
  /**
   * Optionally override the step variant - the step will ignore any internal variant logic. This is normally managed by the parent Stepper except for error/validation cases.
   *
   * Defaults to **undefined**.
   */
  variant: PropTypes.oneOf(["inactive", "completed", "active", "incomplete", "danger"])
};
const StepDefaultProps = {
  className: undefined,
  dense: false,
  errorState: undefined,
  id: undefined,
  secondaryText: undefined,
  stepIndex: undefined,
  tag: "button",
  textBubbleProps: undefined,
  textBubbleText: undefined,
  textBubbleThemeColor: undefined,
  title: undefined,
  variant: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const StepButtonPropTypes = {
  /**
   * Additional props to be passed to the underlying button. See the Element Button documentation for more information.
   *
   * Defaults to **undefined**.
   */
  buttonProps: PropTypes.object,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Prevent user interaction with the button on the last step*. Can be used with form validation.
   *
   * Defaults to **false**.
   */
  confirmDisabled: PropTypes.bool,
  /**
   * Override the default button label of 'next' or 'prev'.
   *
   * Defaults to **undefined**.
   */
  customLabel: PropTypes.node,
  /**
   * The type of button, next or previous. Will automatically become a confirm button on the last step
   *
   * Defaults to **'next'**.
   */
  direction: PropTypes.oneOf(["next", "prev"]),
  /**
   * Prevent user interaction with the button. Can be used with form validation.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * An optional custom event handler to be executed after internal events are complete.
   *
   * Defaults to **undefined**.
   */
  onClick: PropTypes.func,
  /**
   * Hide the button using display:none instead of removing it from the dom. May be useful with animations.
   *
   * Defaults to **false**.
   */
  persistent: PropTypes.bool,
  /**
   * Optionally override the default component of Element Button (such as an IconButton).
   *
   * Defaults to **undefined**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType])
};
const StepButtonDefaultProps = {
  buttonProps: undefined,
  className: undefined,
  confirmDisabled: false,
  customLabel: undefined,
  direction: "next",
  disabled: false,
  persistent: false,
  tag: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const StepContentPropTypes = {
  /**
   * Content to be rendered inside StepContent.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Disable the normal width of `600px` and apply a full-width style to fill it's container.
   *
   * Defaults to **false**.
   */
  fullWidth: PropTypes.bool,
  /**
   * Change the default padding. The StepContent will normally use standard padding.
   *
   * Defaults to **'standard'**.
   */
  padding: PropTypes.oneOf(["none", "dense", "standard", "airy"]),
  /**
   * Hide the button using display:none instead of removing it from the dom. May be useful with animations.
   *
   * Defaults to **false**.
   */
  persistent: PropTypes.bool,
  /**
   * The id of the associated step.
   *
   * Defaults to **undefined**.
   */
  stepId: PropTypes.string.isRequired,
  /**
   * By default a div will be rendered, this allow another tag to be used instead. A block type component is suggested.
   *
   * Defaults to **'div'**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType])
};
const StepContentDefaultProps = {
  children: null,
  className: undefined,
  fullWidth: false,
  padding: "standard",
  persistent: false,
  stepId: undefined,
  tag: "div"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const StepDividerPropTypes = {
  /**
   * Optionally override automatic active tracking - only needed when managing Stepper state in the parent application. Will use the `primary` color when true and the `stroke` color when false. Only used with linear Steppers.
   *
   * Defaults to **undefined**.
   */
  active: PropTypes.bool,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Optional props to be passed to the underlying Element Divider component. See Divider documentation for more info.
   *
   * Defaults to **undefined**.
   */
  dividerProps: PropTypes.object,
  /**
   * The step index immediately preceding the StepDivider. Used for calculating the active state with a linear Stepper.
   *
   * Defaults to **undefined**.
   */
  nearestStepIndex: PropTypes.number
};
const StepDividerDefaultProps = {
  active: undefined,
  className: undefined,
  dividerProps: undefined,
  nearestStepIndex: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const StepperButtonContainerPropTypes = {
  /**
   * Change the default border. The Stepper Button Container will normally have a top border.
   *
   * Defaults to **'default'**.
   */
  border: PropTypes.oneOf(["none", "default"]),
  /**
   * Content to be rendered inside StepContent.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Disable the normal width of `600px` and apply a  100% width style to fill it's container. Note, this is automatically enabled with vertical steppers.
   *
   * Defaults to **undefined**.
   */
  fullWidth: PropTypes.bool,
  /**
   * Change the default padding. The Stepper Button Container will normally use standard padding.
   *
   * Defaults to **'standard'**.
   */
  padding: PropTypes.oneOf(["none", "dense", "standard", "airy"]),
  /**
   * By default a div will be rendered, this allow another tag to be used instead. A block type component is suggested.
   *
   * Defaults to **'div'**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType])
};
const StepperButtonContainerDefaultProps = {
  border: "default",
  children: null,
  className: undefined,
  fullWidth: undefined,
  padding: "standard",
  tag: "div"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const StepperContainerPropTypes = {
  /**
   * The Stepper component to render.
   *
   * Defaults to **undefined**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Fired when the confirm button is clicked.
   *
   * Defaults to **undefined**.
   */
  onConfirm: PropTypes.func,
  /**
   * Using onStepChange is usually preferred as it catches non-linear step clicks. OnNext is fired only when the next button is clicked.
   *
   * Defaults to **undefined**.
   */
  onNext: PropTypes.func,
  /**
   * Using onStepChange is usually preferred as it catches non-linear step clicks. OnPrev is fired only when the prev button is clicked.
   *
   * Defaults to **undefined**.
   */
  onPrev: PropTypes.func,
  /**
   * An alternative to onNext and onPrev, onStepChange will fire when the progress is changed in any way. Note: this *does not* fire when the confirm button is clicked.
   *
   * Defaults to **undefined**.
   */
  onStepChange: PropTypes.func,
  /**
   * By default a div will be rendered, this allow another tag to be used instead. A block type component is suggested.
   *
   * Defaults to **'div'**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType])
};
const StepperContainerDefaultProps = {
  children: undefined,
  className: undefined,
  tag: "div"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Content to be rendered inside StepContent.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * By default a div will be rendered, this allow another tag to be used instead. A block type component is suggested.
   *
   * Defaults to **'div'**.
   */
  tag: PropTypes.oneOfType([PropTypes.string, PropTypes.elementType])
});

// intentionally left empty (for Stepper to detect if it needs to create a Stepper Container)
const StepperContext = /*#__PURE__*/createContext();

const getThemeColor = variant => {
  switch (variant) {
    case 'active':
      return 'primary';
    case 'completed':
      return 'primary';
    case 'incomplete':
      return 'gray';
    case 'danger':
      return 'danger';
    case 'inactive':
    default:
      return 'muted';
  }
};
const getVariant = (stepIndex, progress, nonLinear, errorState) => {
  // the current step should always be active, regardless of mode
  if (stepIndex === progress) return 'active';
  // in linear mode, anything in front the current progress should simply be inactive
  if (!nonLinear && stepIndex > progress) return 'inactive';
  // check and show the error state
  if (errorState) return errorState;
  // if there is no validation state and we're not non-linear, success!
  if (!nonLinear && stepIndex > -1 && stepIndex < progress) return 'completed';
  // anything we didn't catch
  return 'inactive';
};
const getBubbleText = (variant, stepNumber) => {
  switch (variant) {
    case 'completed':
      return /*#__PURE__*/React.createElement(Icon, {
        icon: "check"
      });
    case 'incomplete':
      return /*#__PURE__*/React.createElement(Icon, {
        icon: "warning"
      });
    case 'danger':
      return /*#__PURE__*/React.createElement(Icon, {
        icon: "error"
      });
    case 'inactive':
    case 'active':
    default:
      return stepNumber;
  }
};
const getStepIndex = (stepIndexProp, stepIndexes, id) => {
  if (stepIndexProp !== undefined) return stepIndexProp;
  if (stepIndexes) return stepIndexes.findIndex(x => x === id);
  return 0;
};
const Step = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    className,
    dense: denseProp,
    forceVariant,
    id,
    onClick,
    onStepEnter,
    onStepLeave,
    secondaryText,
    stepIndex: stepIndexOverride,
    tag: Tag,
    textBubbleProps,
    textBubbleText: textBubbleTextOverride,
    textBubbleThemeColor: textBubbleThemeColorOverride,
    title,
    errorState,
    variant: variantOverride,
    ...customProps
  } = props;
  const {
    dense: denseContext,
    nonLinear,
    progress,
    registerStep,
    setProgress,
    stepIndexes
  } = useContext(StepperContext) || {};
  const stepIndex = getStepIndex(stepIndexOverride, stepIndexes, id);
  const stepNumber = stepIndex > -1 ? stepIndex + 1 : '';
  const variant = variantOverride || getVariant(stepIndex, progress, nonLinear, errorState);
  const bubbleText = textBubbleTextOverride || getBubbleText(variant, stepNumber);
  const bubbleThemeColor = textBubbleThemeColorOverride || getThemeColor(variant);
  const dense = denseProp || denseContext;
  const bubbleSize = dense ? 'small' : 'default';
  const handleClick = () => {
    setProgress(stepIndex);
    onClick === null || onClick === void 0 ? void 0 : onClick(stepIndex);
  };
  useEffect(() => {
    registerStep === null || registerStep === void 0 ? void 0 : registerStep(id || title, onStepEnter, onStepLeave);
  }, [id, title, registerStep, onStepEnter, onStepLeave]);
  return /*#__PURE__*/React.createElement(Tag, _extends({
    id: id,
    ref: externalRef,
    className: clsx('lmnt lmnt-stepper__step', `lmnt-stepper__step--${variant}`, className),
    disabled: !nonLinear,
    onClick: handleClick,
    type: "button"
  }, customProps), /*#__PURE__*/React.createElement("div", {
    className: "lmnt-stepper__step-indicator"
  }, /*#__PURE__*/React.createElement(TextBubble, _extends({
    bubbleSize: bubbleSize,
    themeColor: bubbleThemeColor,
    text: bubbleText
  }, textBubbleProps))), /*#__PURE__*/React.createElement("div", {
    className: "lmnt-stepper__step-text"
  }, /*#__PURE__*/React.createElement(TypoSubtitle, {
    tag: "div",
    className: "lmnt-stepper__step-title"
  }, title), /*#__PURE__*/React.createElement(TypoCaption, {
    tag: "div",
    className: "lmnt-stepper__step-secondary-text"
  }, secondaryText)));
});
Step.displayName = 'Step';
Step.propTypes = StepPropTypes;
Step.defaultProps = StepDefaultProps;

const getLabel = stepType => {
  switch (stepType) {
    case 'confirm':
      return 'Confirm';
    case 'prev':
      return 'Prev';
    case 'next':
    default:
      return 'Next';
  }
};
const StepButton = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    buttonProps,
    className,
    customLabel,
    disabled,
    confirmDisabled,
    onClick,
    persistent,
    direction,
    tag: Tag = Button,
    ...customProps
  } = props;
  const {
    next,
    prev,
    progress,
    stepIndexes,
    confirm
  } = useContext(StepperContext) || {};
  const lastStep = direction === 'next' && progress === ((stepIndexes === null || stepIndexes === void 0 ? void 0 : stepIndexes.length) || 0) - 1;
  const stepType = lastStep ? 'confirm' : direction;
  const hidePrevious = stepType === 'prev' && progress === 0;
  const buttonDisabled = confirmDisabled && lastStep || disabled || hidePrevious;
  const labelActual = customLabel || getLabel(stepType);
  const handClick = () => {
    if (stepType === 'confirm') {
      confirm();
      onClick === null || onClick === void 0 ? void 0 : onClick();
      return;
    }
    direction === 'prev' ? prev() : next();
    onClick === null || onClick === void 0 ? void 0 : onClick();
  };
  if (!hidePrevious || persistent) return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt-stepper__step-button', hidePrevious && 'lmnt-stepper__step-button--hidden', className),
    disabled: buttonDisabled,
    variant: stepType === 'prev' ? 'text' : 'filled',
    onClick: handClick
  }, buttonProps, customProps), labelActual);
  return null;
});
StepButton.displayName = 'StepButton';
StepButton.propTypes = StepButtonPropTypes;
StepButton.defaultProps = StepButtonDefaultProps;

const StepContent = /*#__PURE__*/forwardRef((props, externalRef) => {
  // eslint-disable-next-line react/prop-types
  const {
    children,
    className,
    fullWidth,
    padding,
    persistent,
    stepId,
    tag: Tag,
    ...customProps
  } = props;
  const {
    stepIndexes,
    progress
  } = useContext(StepperContext) || {};
  const active = progress === (stepIndexes === null || stepIndexes === void 0 ? void 0 : stepIndexes.findIndex(x => x === stepId));
  if (active || persistent) return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt-stepper__step-content', !active && 'lmnt-stepper__step-content--hidden', fullWidth && 'lmnt-stepper__step-content--full-width', padding === 'airy' && 'lmnt-padding--airy', padding === 'dense' && 'lmnt-padding--dense', padding === 'standard' && 'lmnt-padding--standard', className)
  }, customProps), children);
  return null;
});
StepContent.displayName = StepContent;
StepContent.propTypes = StepContentPropTypes;
StepContent.defaultProps = StepContentDefaultProps;

const StepDivider = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    active: activeOverride,
    className,
    dividerProps,
    nearestStepIndex,
    ...customProps
  } = props;
  const {
    progress,
    nonLinear
  } = useContext(StepperContext) || {};
  const active = activeOverride || !nonLinear && progress > nearestStepIndex;
  return /*#__PURE__*/React.createElement(Divider, _extends({
    ref: externalRef,
    variant: "tall",
    className: clsx('lmnt-stepper__step-divider', className),
    themeColor: active ? 'primary' : 'on-surface-stroke'
  }, dividerProps, customProps));
});
StepDivider.displayName = 'StepDivider';
StepDivider.propTypes = StepDividerPropTypes;
StepDivider.defaultProps = StepDividerDefaultProps;

const StepperContainer = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    onConfirm,
    onNext,
    onPrev,
    onStepChange,
    tag,
    ...customProps
  } = props;
  const Tag = tag || 'div';
  const [dense, setDense] = useState();
  const [vertical, setVertical] = useState(false);
  const [nonLinear, setNonLinear] = useState(false);
  const [rtl, setRtl] = useState(false);
  const [progress, setProgress] = useState(0);
  const [stepRegistration, setStepRegistration] = useState([]);
  const [stepIndexes, setStepIndexes] = useState([]);
  const ref = useRef();
  useEffect(() => {
    setStepIndexes(stepRegistration.map(x => x.stepId));
  }, [stepRegistration]);
  const registerStep = useCallback((key, onStepEnter, onStepLeave) => {
    setStepRegistration(current => {
      if (current.find(x => x === key)) return current;
      const next = [...current];
      next.push({
        stepId: key,
        onStepEnter,
        onStepLeave
      });
      return next;
    });
  }, []);
  const handleProgressChange = useCallback(newProgress => {
    var _stepRegistration$pro, _stepRegistration$pro2, _stepRegistration$new, _stepRegistration$new2;
    setProgress(newProgress);
    (_stepRegistration$pro = (_stepRegistration$pro2 = stepRegistration[progress]).onStepLeave) === null || _stepRegistration$pro === void 0 ? void 0 : _stepRegistration$pro.call(_stepRegistration$pro2, newProgress, progress);
    (_stepRegistration$new = (_stepRegistration$new2 = stepRegistration[newProgress]).onStepEnter) === null || _stepRegistration$new === void 0 ? void 0 : _stepRegistration$new.call(_stepRegistration$new2, newProgress, progress);
    onStepChange === null || onStepChange === void 0 ? void 0 : onStepChange(newProgress, progress);
  }, [onStepChange, progress, stepRegistration]);
  const prev = useCallback(() => {
    const newProgress = progress <= 0 ? 0 : progress - 1;
    handleProgressChange(newProgress, progress);
    onPrev === null || onPrev === void 0 ? void 0 : onPrev(newProgress, progress);
  }, [handleProgressChange, onPrev, progress]);
  const next = useCallback(() => {
    const stepCount = stepIndexes.length;
    const newProgress = progress + 1;
    if (newProgress >= stepCount) return;
    handleProgressChange(newProgress, progress);
    onNext === null || onNext === void 0 ? void 0 : onNext(newProgress, progress);
  }, [handleProgressChange, onNext, progress, stepIndexes.length]);
  const confirm = useCallback(() => {
    onConfirm === null || onConfirm === void 0 ? void 0 : onConfirm();
  }, [onConfirm]);
  const contextValue = useMemo(() => ({
    confirm,
    dense,
    next,
    nonLinear,
    prev,
    progress,
    registerStep,
    rtl,
    setDense,
    setNonLinear,
    setProgress,
    setRtl,
    setVertical,
    stepIndexes,
    vertical
  }), [confirm, dense, next, nonLinear, prev, progress, registerStep, rtl, stepIndexes, vertical]);
  useImperativeHandle(externalRef, () => ({
    ...contextValue,
    current: ref.current
  }));
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: ref,
    className: clsx('lmnt-stepper__container', rtl && 'lmnt-stepper__container--rtl', vertical && 'lmnt-stepper__container--vertical', className)
  }, customProps), /*#__PURE__*/React.createElement(StepperContext.Provider, {
    value: contextValue
  }, children));
});
StepperContainer.displayName = 'StepperContainer';
StepperContainer.propTypes = StepperContainerPropTypes;
StepperContainer.defaultProps = StepperContainerDefaultProps;

const customContainer = containerRef => content => /*#__PURE__*/React.createElement(StepperContainer, {
  ref: containerRef
}, content);

// TODO: Mikes todo list
// - fix flash of checked steppers on load (I think this is from the new "active" logic change)
// - finish form validation demo (do we need to add a validation to Step that passes a param that allows variant to be updated?)

const Stepper = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    border,
    children,
    className,
    dense,
    nonLinear,
    progress,
    rtl,
    steps,
    tag: Tag,
    vertical,
    ...customProps
  } = props;
  const context = useContext(StepperContext);
  const [sharedState, setSharedState] = useState();
  const containerRef = useRef();
  useEffect(() => {
    // make sure we only set this once
    if (sharedState) return;
    // Shared state is managed in the StepperContainer. However, if StepperContainer has not been created externally we create one using ConditionalWrapper and get shared state via ref.
    const {
      setDense,
      setProgress,
      setNonLinear,
      setVertical,
      setRtl
    } = context || containerRef.current;
    if (!setDense || !setNonLinear || !setProgress || !setRtl || !setVertical) return;
    // store minimum we need here
    setSharedState({
      setDense,
      setNonLinear,
      setProgress,
      setRtl,
      setVertical
    });
  }, [context, sharedState]);
  useEffect(() => {
    var _sharedState$setDense;
    if (dense === undefined) return;
    sharedState === null || sharedState === void 0 ? void 0 : (_sharedState$setDense = sharedState.setDense) === null || _sharedState$setDense === void 0 ? void 0 : _sharedState$setDense.call(sharedState, dense);
  }, [dense, sharedState]);
  useEffect(() => {
    var _sharedState$setNonLi;
    if (nonLinear === undefined) return;
    sharedState === null || sharedState === void 0 ? void 0 : (_sharedState$setNonLi = sharedState.setNonLinear) === null || _sharedState$setNonLi === void 0 ? void 0 : _sharedState$setNonLi.call(sharedState, nonLinear);
  }, [nonLinear, sharedState]);
  useEffect(() => {
    var _sharedState$setProgr;
    if (progress === undefined) return;
    sharedState === null || sharedState === void 0 ? void 0 : (_sharedState$setProgr = sharedState.setProgress) === null || _sharedState$setProgr === void 0 ? void 0 : _sharedState$setProgr.call(sharedState, progress);
  }, [progress, sharedState]);
  useEffect(() => {
    var _sharedState$setRtl;
    if (rtl === undefined) return;
    sharedState === null || sharedState === void 0 ? void 0 : (_sharedState$setRtl = sharedState.setRtl) === null || _sharedState$setRtl === void 0 ? void 0 : _sharedState$setRtl.call(sharedState, rtl);
  }, [rtl, sharedState]);
  useEffect(() => {
    var _sharedState$setVerti;
    if (vertical === undefined) return;
    sharedState === null || sharedState === void 0 ? void 0 : (_sharedState$setVerti = sharedState.setVertical) === null || _sharedState$setVerti === void 0 ? void 0 : _sharedState$setVerti.call(sharedState, vertical);
  }, [vertical, sharedState]);
  return /*#__PURE__*/React.createElement(ConditionalWrapper, {
    condition: !context,
    wrapper: customContainer(containerRef)
  }, /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt lmnt-stepper', border === 'none' && 'lmnt-stepper--un-bordered', dense && 'lmnt-stepper--dense', rtl && 'lmnt-stepper--rtl', vertical && 'lmnt-stepper--vertical', nonLinear && 'lmnt-stepper--non-linear', className)
  }, customProps), steps && steps.map((s, i) => /*#__PURE__*/React.createElement(Fragment, {
    key: s.title
  }, /*#__PURE__*/React.createElement(Step, _extends({
    stepIndex: i
  }, s)), i !== steps.length - 1 && /*#__PURE__*/React.createElement(StepDivider, {
    nearestStepIndex: i
  }))), children));
});
Stepper.displayName = 'Stepper';
Stepper.propTypes = StepperPropTypes;
Stepper.defaultProps = StepperDefaultProps;

const StepperButtonContainer = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    border,
    children,
    className,
    fullWidth: fullWidthProp,
    padding,
    tag: Tag,
    ...customProps
  } = props;
  const {
    vertical
  } = useContext(StepperContext) || {};
  const fullWidth = fullWidthProp !== undefined ? fullWidthProp : vertical;
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt-stepper__button-container', border === 'none' && 'lmnt-stepper__button-container--un-bordered', fullWidth && 'lmnt-stepper__button-container--full-width', className)
  }, customProps), /*#__PURE__*/React.createElement("div", {
    className: clsx('lmnt-stepper__button-container-inner', padding === 'dense' && 'lmnt-padding--dense', padding === 'standard' && 'lmnt-padding--standard', padding === 'airy' && 'lmnt-padding--airy')
  }, children));
});
StepperButtonContainer.displayName = 'StepperButtonContainer';
StepperButtonContainer.propTypes = StepperButtonContainerPropTypes;
StepperButtonContainer.defaultProps = StepperButtonContainerDefaultProps;

const StepperContentContainer = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    border,
    children,
    className,
    fullWidth,
    padding,
    tag: Tag,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt-stepper__content-container', className)
  }, customProps), children);
});
StepperContentContainer.displayName = 'StepperButtonContainer';
StepperContentContainer.propTypes = StepperButtonContainerPropTypes;
StepperContentContainer.defaultProps = StepperButtonContainerDefaultProps;

export { Step, StepButton, StepContent, StepDivider, Stepper, StepperButtonContainer, StepperContainer, StepperContentContainer, StepperContext };
//# sourceMappingURL=index.es.js.map
