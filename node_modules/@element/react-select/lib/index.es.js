import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { memo, forwardRef, useMemo, useCallback, useState, useRef, useEffect, useImperativeHandle } from 'react';
import clsx from 'clsx';
import { MDCSelectHelperText } from '@material/select';
import { deprecatedProp, useIsomorphicLayoutEffect, edsRandomId, edsWarning } from '@element/react-common';
import { getListVariant, edsQuerySelector } from '@element/shared';
import { TooltipText } from '@element/react-tooltip';
import RSelect, { components, createFilter } from 'react-select';
import { createPopper } from '@popperjs/core';
import PropTypes from 'prop-types';
import { List, ListItem, ListDivider } from '@element/react-list';
import { Switch } from '@element/react-switch';
import { Typography, TypoSubtitle } from '@element/react-typography';
import { Button } from '@element/react-button';
import ResizeObserver from 'resize-observer-polyfill';
import { Checkbox } from '@element/react-checkbox';
import { Icon } from '@element/react-icon';
import { IconButton } from '@element/react-icon-button';
import { FloatingLabel } from '@element/react-floating-label';
import { NotchedOutline } from '@element/react-notched-outline';
import { ponyfill } from '@material/dom';
import { MenuContext } from '@element/react-menu';
import '@emotion/core';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const SelectPropTypes = {
  /**
   * Accessibility label for assistive technologies.
   *
   * Defaults to **null**.
   */
  ariaLabel: PropTypes.string,
  /**
   * Id of the component being labeled for assistive technologies.
   *
   * Defaults to **null**.
   */
  ariaLabelledBy: PropTypes.string,
  /**
   * Label for the Cancel button on the multi-select label.
   *
   * Defaults to **'Cancel'**.
   */
  cancelLabel: PropTypes.string,
  /**
   * Name of the key for category name in options.
   *
   * Defaults to **'categoryName'**.
   */
  categoryNameKey: PropTypes.string,
  /**
   * Name of the key for category value in options.
   *
   * Defaults to **'categoryValue'**.
   */
  categoryValueKey: PropTypes.string,
  /**
   * Expects one or more SelectOption components. Options should not be used with children. If both are sent children will be ignored.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * If true select is clearable.
   *
   * Defaults to **false**.
   */
  clearable: PropTypes.bool,
  /**
   * Label for the Confirm button on the multi-select label.
   *
   * Defaults to **'Confirm'**.
   */
  confirmLabel: PropTypes.string,
  /**
   * Custom properties to be passed to the react-select instance.
   *
   * Defaults to **null**.
   */
  containerProps: PropTypes.object,
  /**
   * The menu will be visible by default.
   *
   * Defaults to **false**.
   */
  defaultOpen: PropTypes.bool,
  /**
   * Styles the select in a more compact format. When used with filled an external label must be used. Dense is not recommended when using as a multi select and `multiDisplayType` is set to pills.
   *
   * Defaults to **false**.
   */
  dense: PropTypes.bool,
  /**
   * Prevents the user from interacting with the component.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * Custom configuration for the select filter.
   *
   * Defaults to **{ 'ignoreCase': true, 'ignoreAccents': true, 'matchFrom': 'any', 'stringify': option => `${option.label} ${option.value}`, 'trim': true }**.
   */
  filterConfig: PropTypes.object,
  /**
   * Custom filter function.
   *
   * Defaults to **undefined**.
   */
  filterFunction: PropTypes.func,
  /**
   * If true the select input will remain the same height even if rendered selections exceed the max height.
   *
   * Defaults to **false**.
   */
  fixedHeightInput: PropTypes.bool,
  /**
   * Name of the key for group name in options.
   *
   * Defaults to **'groupName'**.
   */
  groupNameKey: PropTypes.string,
  /**
   * Name of the key for group value in options.
   *
   * Defaults to **'groupValue'**.
   */
  groupValueKey: PropTypes.string,
  /**
   * Helper text to be displayed below Select, by default only visible on focus.
   *
   * Defaults to **null**.
   */
  helperText: PropTypes.string,
  /**
   * Randomly generated id for the helper text container element. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  helperTextId: PropTypes.string,
  /**
   * Set the helper text to be permanently visible.
   *
   * Defaults to **false**.
   */
  helperTextPersistent: PropTypes.bool,
  /**
   * Set the helper text to use validation styles. Helper text changes with `valid` (e.g., helper text will appear the current theme's danger color when `valid` is set to 'false').
   *
   * Defaults to **false**.
   */
  helperTextValidation: PropTypes.bool,
  /**
   * Remove the selection option(s) from the list.
   *
   * Defaults to **false**.
   */
  hideSelectedOptions: PropTypes.bool,
  /**
   * Whether or not the menu is hoisted to render outside of the parent element. Useful for when the select needs to render in a parent with `overflow: hidden`.
   *
   * Defaults to **false**.
   */
  hoisted: PropTypes.bool,
  /**
   * Overwrite the default, randomly generated id. Each must be unique.
   *
   * Defaults to **null**.
   */
  id: PropTypes.string,
  /**
   * @deprecated _Renamed to `clearable` for consistency._
   *
   * If true select is clearable.
   *
   * Defaults to **undefined**.
   */
  isClearable: deprecatedProp(PropTypes.bool, "Select", "Renamed to `clearable` for consistency."),
  /**
   * @deprecated _Renamed to `multiSelect` for consistency._
   *
   * If true select is a multi-select.
   *
   * Defaults to **undefined**.
   */
  isMulti: deprecatedProp(PropTypes.bool, "Select", "Renamed to `multiSelect` for consistency."),
  /**
   * The placeholder/floating display label.
   *
   * Defaults to **null**.
   */
  label: PropTypes.string,
  /**
   * Accepts the name of any valid material icon (see Icon component documentation for a list of valid icons).
   *
   * Defaults to **null**.
   */
  leadingIcon: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * Max height the menu may take up. If using groups, we recommend adding a menu max height.
   *
   * Defaults to **undefined**.
   */
  menuMaxHeight: PropTypes.string,
  /**
   * How value is displayed if select is a multiselect.
   *
   * Defaults to **'pills'**.
   */
  multiDisplayType: PropTypes.oneOf(["pills", "text"]),
  /**
   * Enable multi-selection mode. Note, row highlighting is disabled when using multi-select.
   *
   * Defaults to **false**.
   */
  multiSelect: PropTypes.bool,
  /**
   * Name to be added to hidden html input.
   *
   * Defaults to **null**.
   */
  name: PropTypes.string,
  /**
   * Message to show if no options are available.
   *
   * Defaults to **'No options'**.
   */
  noOptionsMessage: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * Fired when the Select looses focus.
   *
   * Defaults to **null**.
   */
  onBlur: PropTypes.func,
  /**
   * Fired when value of the selected option is changed.
   *
   * Defaults to **null**.
   */
  onChange: PropTypes.func,
  /**
   * Fired when the Select gains focus.
   *
   * Defaults to **null**.
   */
  onFocus: PropTypes.func,
  /**
   * Fired when the select is searchable and a user changes the search term.
   *
   * Defaults to **null**.
   */
  onInputChange: PropTypes.func,
  /**
   * The menu will always be visible.
   *
   * Defaults to **undefined**.
   */
  open: PropTypes.bool,
  /**
   * (??) When using multi-select mode the menu items will show a switch to show all options or only selected.
   *
   * Defaults to **'Show only selected options'**.
   */
  optionFilterLabel: PropTypes.string,
  /**
   * Options for select. See README for schema architecture. Options should not be used with children. If both are sent children will be ignored.
   *
   * Defaults to **null**.
   */
  options: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.object), PropTypes.arrayOf(PropTypes.string), PropTypes.arrayOf(PropTypes.number)]),
  /**
   * The DOM element the menu should render in if `hoisted` is set to true. If a string is sent it should be a valid DOM query selector. If one is not sent, Portal will default to `document.body`.
   *
   * Defaults to **undefined**.
   */
  portalContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * When in multi-select mode a confirmation will be required before the onChange will be called.
   *
   * Defaults to **false**.
   */
  requireConfirmation: PropTypes.bool,
  /**
   * Whether or not the input is required. Can be used for validation purposes.
   *
   * Defaults to **false**.
   */
  required: PropTypes.bool,
  /**
   * Enable autocomplete behavior.
   *
   * Defaults to **false**.
   */
  searchable: PropTypes.bool,
  /**
   * Label for the Select All checkbox.
   *
   * Defaults to **'Select All Options'**.
   */
  selectAllLabel: PropTypes.string,
  /**
   * When using a multi-select list the items will have checkboxes to indicate selection. If false, options will not have a checkbox, and selected options will be removed from the list.
   *
   * Defaults to **true**.
   */
  showCheckboxOptions: PropTypes.bool,
  /**
   * When using a multi-select mode the menu will include a switch to show all options or only selected.
   *
   * Defaults to **true**.
   */
  showOptionFilter: PropTypes.bool,
  /**
   * Shows a checkbox to select all options.
   *
   * Defaults to **true**.
   */
  showSelectAll: PropTypes.bool,
  /**
   * Passthrough style object.
   *
   * Defaults to **null**.
   */
  style: PropTypes.object,
  /**
   * Prevent console warning when value is not found in the options list.
   *
   * Defaults to **false**.
   */
  suppressInvalidOptionWarning: PropTypes.bool,
  /**
   * Name of the key for the text in options.
   *
   * Defaults to **'text'**.
   */
  textKey: PropTypes.string,
  /**
   * Color of the select based on the theme.
   *
   * Defaults to **'primary'**.
   */
  themeColor: PropTypes.oneOf(["primary", "secondary"]),
  /**
   * If defined, a Tooltip will appear on the Select input. Useful to show the full value, if selected value is too long for the Select width. The object should be the needed Tooltip properties. Tooltip `text`prop will be set to the current selected value of the Select.  See Tooltip docs for available props.
   *
   * Defaults to **null**.
   */
  tooltip: PropTypes.object,
  /**
   * Whether or not the selected value is valid. Can be used for validation purposes.
   *
   * Defaults to **null**.
   */
  valid: PropTypes.bool,
  /**
   * The value of the select.
   *
   * Defaults to **undefined**.
   */
  value: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.object), PropTypes.object, PropTypes.string, PropTypes.number]),
  /**
   * @deprecated _Renamed to `multiDisplayType` for clarity._
   *
   * How value is displayed if select is a multiselect.
   *
   * Defaults to **undefined**.
   */
  valueDisplay: deprecatedProp(PropTypes.oneOf(["pills", "text"]), "Select", "Renamed to `multiDisplayType` for clarity."),
  /**
   * Name of the key for the value in options.
   *
   * Defaults to **'value'**.
   */
  valueKey: PropTypes.string,
  /**
   * Applies the selected style to the select input.
   *
   * Defaults to **'filled'**.
   */
  variant: PropTypes.oneOf(["filled", "outlined"])
};
const SelectDefaultProps = {
  ariaLabel: null,
  ariaLabelledBy: null,
  cancelLabel: "Cancel",
  categoryNameKey: "categoryName",
  categoryValueKey: "categoryValue",
  children: null,
  className: undefined,
  clearable: false,
  confirmLabel: "Confirm",
  containerProps: null,
  defaultOpen: false,
  dense: false,
  disabled: false,
  filterConfig: {
    ignoreCase: true,
    ignoreAccents: true,
    matchFrom: "any",
    stringify: option => `${option.label} ${option.value}`,
    trim: true
  },
  filterFunction: undefined,
  fixedHeightInput: false,
  groupNameKey: "groupName",
  groupValueKey: "groupValue",
  helperText: null,
  helperTextId: undefined,
  helperTextPersistent: false,
  helperTextValidation: false,
  hideSelectedOptions: false,
  hoisted: false,
  id: null,
  isClearable: undefined,
  isMulti: undefined,
  label: null,
  leadingIcon: null,
  menuMaxHeight: undefined,
  multiDisplayType: "pills",
  multiSelect: false,
  name: null,
  noOptionsMessage: "No options",
  open: undefined,
  optionFilterLabel: "Show only selected options",
  options: null,
  portalContainer: undefined,
  requireConfirmation: false,
  required: false,
  searchable: false,
  selectAllLabel: "Select All Options",
  showCheckboxOptions: true,
  showOptionFilter: true,
  showSelectAll: true,
  style: null,
  suppressInvalidOptionWarning: false,
  textKey: "text",
  themeColor: "primary",
  tooltip: null,
  valid: null,
  value: undefined,
  valueDisplay: undefined,
  valueKey: "value",
  variant: "filled"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Inner props from the react select.
   *
   * Defaults to **undefined**.
   */
  innerProps: PropTypes.object
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const SelectConfirmationPropTypes = {
  /**
   * Label for the Cancel button on the multi select label.
   *
   * Defaults to **'Cancel'**.
   */
  cancelLabel: PropTypes.string,
  /**
   * Label for the Confirm button on the multi select label.
   *
   * Defaults to **'Confirm'**.
   */
  confirmLabel: PropTypes.string,
  /**
   * Fired when confirmation is clicked.
   *
   * Defaults to **null**.
   */
  onConfirm: PropTypes.func,
  /**
   * Sets the theme color for the option filter switch, confirm/cancel buttons and checkboxes
   *
   * Defaults to **'primary'**.
   */
  themeColor: PropTypes.oneOf(["primary", "secondary"])
};
const SelectConfirmationDefaultProps = {
  cancelLabel: "Cancel",
  confirmLabel: "Confirm",
  themeColor: "primary"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const SelectContentPropTypes = {
  /**
   * Content to be rendered inside the component. Accepts any valid markup.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node.isRequired,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Indicates the content will appear before the list, otherwise content will assume it is trailing.
   *
   * Defaults to **undefined**.
   */
  leading: PropTypes.bool
};
const SelectContentDefaultProps = {
  children: null,
  className: undefined,
  leading: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Expects the value containers and indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Whether or not the select has a value.
   *
   * Defaults to **null**.
   */
  hasValue: PropTypes.bool,
  /**
   * Inner props from the react select.
   *
   * Defaults to **null**.
   */
  innerProps: PropTypes.object,
  /**
   * Whether or not the select is focused.
   *
   * Defaults to **null**.
   */
  isFocused: PropTypes.bool,
  /**
   * Select props sent to react select.
   *
   * Defaults to **null**.
   */
  selectProps: PropTypes.object
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Expects the indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const SelectLabelPropTypes = {
  /**
   * Expects the value containers and indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Whether or not the select control has expanded in height.
   *
   * Defaults to **null**.
   */
  extendedHeight: PropTypes.bool,
  /**
   * Whether or not the select control has a fixed height.
   *
   * Defaults to **null**.
   */
  fixedHeightInput: PropTypes.bool,
  /**
   * Whether or not the label should float.
   *
   * Defaults to **null**.
   */
  float: PropTypes.bool,
  /**
   * Whether or not the select is the outlined variant.
   *
   * Defaults to **null**.
   */
  isOutlined: PropTypes.bool,
  /**
   * Label for the select.
   *
   * Defaults to **empty string**.
   */
  label: PropTypes.string,
  /**
   * Id for the select.
   *
   * Defaults to **empty string**.
   */
  selectId: PropTypes.string,
  /**
   * Select props sent to react select.
   *
   * Defaults to **null**.
   */
  selectProps: PropTypes.object
};
const SelectLabelDefaultProps = {
  children: null,
  extendedHeight: null,
  fixedHeightInput: null,
  float: null,
  isOutlined: null,
  label: "",
  selectId: "",
  selectProps: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Expects the value containers and indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Returns the value of the select.
   *
   * Defaults to **null**.
   */
  getValue: PropTypes.func,
  /**
   * Select props sent to react select.
   *
   * Defaults to **null**.
   */
  selectProps: PropTypes.object,
  /**
   * Set the value of the select.
   *
   * Defaults to **null**.
   */
  setValue: PropTypes.func
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Expects the value containers and indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Select props sent to react select.
   *
   * Defaults to **null**.
   */
  selectProps: PropTypes.object
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Expects the value containers and indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Expects the value containers and indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const SelectOptionPropTypes = {
  /**
   * The display value of the SelectOption. If using more than a simple string or number, custom css may be necessary.
   *
   * Defaults to **undefined**.
   */
  children: PropTypes.node,
  /**
   * Data for the select option.
   *
   * Defaults to **undefined**.
   */
  data: PropTypes.object,
  /**
   * Prevent the user from interacting with the component.
   *
   * Defaults to **undefined**.
   */
  disabled: PropTypes.bool,
  /**
   * Returns the value of the select.
   *
   * Defaults to **undefined**.
   */
  getValue: PropTypes.func,
  /**
   * Inner props from the react select.
   *
   * Defaults to **undefined**.
   */
  innerProps: PropTypes.object,
  /**
   * The option is nested.
   *
   * Defaults to **false**.
   */
  isChildOption: PropTypes.bool,
  /**
   * Whether or not the option is focused.
   *
   * Defaults to **undefined**.
   */
  isFocused: PropTypes.bool,
  /**
   * Whether or not the select is selected.
   *
   * Defaults to **undefined**.
   */
  isSelected: PropTypes.bool,
  /**
   * The display value of the SelectOption.
   *
   * Defaults to **undefined**.
   */
  label: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.node]),
  /**
   * Select props sent to react select.
   *
   * Defaults to **undefined**.
   */
  selectProps: PropTypes.object,
  /**
   * @deprecated _The parent Select component will manage the selected state of child SelectOptions. If this is set, it will only change the appearance of the option to show as highlighted._
   *
   * Whether or not the select is selected.
   *
   * Defaults to **undefined**.
   */
  selected: deprecatedProp(PropTypes.bool, "SelectOption", "The parent Select component will manage the selected state of child SelectOptions. If this is set, it will only change the appearance of the option to show as highlighted."),
  /**
   * Sets the value of the select.
   *
   * Defaults to **undefined**.
   */
  setValue: PropTypes.func,
  /**
   * The value of the SelectOption.
   *
   * Defaults to **undefined**.
   */
  value: PropTypes.any
};
const SelectOptionDefaultProps = {
  children: undefined,
  data: undefined,
  disabled: undefined,
  getValue: undefined,
  innerProps: undefined,
  isChildOption: false,
  isFocused: undefined,
  isSelected: undefined,
  label: undefined,
  selectProps: undefined,
  selected: undefined,
  setValue: undefined,
  value: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Label for the option filter switch.
   *
   * Defaults to **empty string**.
   */
  optionFilterLabel: PropTypes.string,
  /**
   * Theme color for the switch.
   *
   * Defaults to **empty string**.
   */
  optionFilterThemeColor: PropTypes.oneOf(["primary", "secondary"]),
  /**
   * Sets the value of the showOnlySelectedItems prop.
   *
   * Defaults to **null**.
   */
  setShowOnlySelectedItems: PropTypes.func,
  /**
   * If true only selected items are shown in the menu.
   *
   * Defaults to **null**.
   */
  showOnlySelectedItems: PropTypes.bool
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const SelectPortalPropTypes = {
  /**
   * Expects the value containers and indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Returns the styles of the component.
   *
   * Defaults to **null**.
   */
  getStyles: PropTypes.func,
  /**
   * Position of the select menu.
   *
   * Defaults to **empty string**.
   */
  menuPosition: PropTypes.string
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Expects the value containers and indicators.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Select props sent to react select.
   *
   * Defaults to **null**.
   */
  selectProps: PropTypes.object
});

const commonClassName = 'lmnt lmnt-select-value-container';
const SelectValueContainer = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    selectProps,
    children
  } = {
    ...props
  };
  const {
    multiDisplayType,
    value,
    multiSelect,
    fixedHeightInput
  } = {
    ...selectProps
  };
  if (multiSelect && multiDisplayType === 'text') {
    if (fixedHeightInput && value && value.length > 0) {
      const val = value.length === 1 ? value[0].label : `${value.length} items selected`;
      return /*#__PURE__*/React.createElement("div", {
        ref: externalRef,
        className: commonClassName
      }, val, children[1]);
    }
    const val = value === null || value === void 0 ? void 0 : value.map(v => v.label);
    return /*#__PURE__*/React.createElement("div", {
      ref: externalRef,
      className: commonClassName
    }, /*#__PURE__*/React.createElement("div", null, val === null || val === void 0 ? void 0 : val.join(', ')), children[1]);
  }
  if (multiSelect && fixedHeightInput) {
    return /*#__PURE__*/React.createElement("div", {
      className: "lmnt-select-value-container-scroll-wrapper"
    }, /*#__PURE__*/React.createElement(components.ValueContainer, _extends({
      ref: externalRef,
      className: commonClassName
    }, props)));
  }
  return /*#__PURE__*/React.createElement(components.ValueContainer, _extends({
    ref: externalRef,
    className: commonClassName
  }, props));
});
SelectValueContainer.displayName = 'SelectValueContainer';
var SelectValueContainer$1 = /*#__PURE__*/memo(SelectValueContainer);

const SelectContent = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    leading,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'lmnt-select__content', leading && `lmnt-select__content--leading`, !leading && `lmnt-select__content--trailing`, className)
  }, customProps), children);
});
SelectContent.displayName = 'SelectContent';
SelectContent.propTypes = SelectContentPropTypes;
SelectContent.defaultProps = SelectContentDefaultProps;

/* eslint-disable react/forbid-prop-types */
const SelectOptionFilter = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    optionFilterLabel,
    showOnlySelectedItems,
    setShowOnlySelectedItems,
    themeColor
  } = props;
  const TrailingSwitch = useMemo(() => /*#__PURE__*/React.createElement("div", {
    className: "lmnt-select__option-filter-switch"
  }, /*#__PURE__*/React.createElement(Switch, {
    hideLabel: true,
    themeColor: themeColor,
    checked: showOnlySelectedItems,
    onChange: setShowOnlySelectedItems,
    label: optionFilterLabel
  })), [optionFilterLabel, showOnlySelectedItems, setShowOnlySelectedItems, themeColor]);
  return /*#__PURE__*/React.createElement(List, {
    ref: externalRef,
    inMenu: true,
    nonInteractive: true
  }, /*#__PURE__*/React.createElement(ListItem, {
    className: clsx('lmnt-select__option-filter', 'lmnt-select__menu-item'),
    noHover: true,
    trailingBlockType: "switch",
    trailingBlock: TrailingSwitch,
    tabIndex: 0
  }, /*#__PURE__*/React.createElement("div", {
    className: "lmnt-select__option-filter-label"
  }, /*#__PURE__*/React.createElement(Typography, {
    type: "caption"
  }, optionFilterLabel))));
});
SelectOptionFilter.displayName = 'SelectOptionFilter';
SelectOptionFilter.propTypes = {
  optionFilterLabel: PropTypes.string.isRequired,
  showOnlySelectedItems: PropTypes.bool,
  themeColor: PropTypes.string,
  setShowOnlySelectedItems: PropTypes.func.isRequired
};
SelectOptionFilter.defaultProps = {
  showOnlySelectedItems: false,
  themeColor: 'primary'
};

const SelectConfirmation = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    onConfirm,
    cancelLabel,
    confirmLabel,
    getValue,
    setValue,
    blurSelect,
    prevSelection,
    selectId,
    themeColor,
    ...customProps
  } = props;
  const handleConfirm = useCallback(() => {
    const val = getValue();
    onConfirm(val, {
      action: 'confirm-selection'
    });
    blurSelect();
  }, [getValue, onConfirm, blurSelect]);
  const handleCancel = useCallback(() => {
    setValue(prevSelection || []);
    blurSelect();
  }, [setValue, blurSelect, prevSelection]);
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'lmnt-select__confirmation')
  }, customProps), /*#__PURE__*/React.createElement(Button, {
    variant: "text",
    onClick: handleCancel,
    label: cancelLabel,
    className: clsx('lmnt-select__cancel-button', themeColor === 'secondary' && 'mdc-theme--text-primary-on-background'),
    id: `${selectId}-cancel`,
    themeColor: themeColor
  }), /*#__PURE__*/React.createElement(Button, {
    variant: "filled",
    onClick: handleConfirm,
    label: confirmLabel,
    id: `${selectId}-confirm`,
    themeColor: themeColor
  }));
});
SelectConfirmation.displayName = 'SelectConfirmation';
SelectConfirmation.propTypes = SelectConfirmationPropTypes;
SelectConfirmation.defaultProps = SelectConfirmationDefaultProps;

const SelectMenu = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    selectProps,
    children,
    getValue,
    setValue
  } = {
    ...props
  };
  const {
    menuIsOpen,
    leadingContent,
    trailingContent,
    showOptionFilter,
    optionFilterLabel,
    showOnlySelectedItems,
    setShowOnlySelectedItems,
    multiSelect,
    requireConfirmation,
    onChange,
    cancelLabel,
    confirmLabel,
    blurSelect,
    prevSelection,
    showCheckboxOptions,
    selectId,
    themeColor
  } = {
    ...selectProps
  };
  return /*#__PURE__*/React.createElement(components.Menu, _extends({
    ref: externalRef
  }, props, {
    className: clsx('lmnt-select-menu', 'mdc-select__menu mdc-menu mdc-menu-surface mdc-menu-surface--fullwidth', menuIsOpen && 'mdc-menu-surface--open')
  }), leadingContent && /*#__PURE__*/React.createElement(SelectContent, {
    id: selectId,
    leading: true
  }, leadingContent), showOptionFilter && multiSelect && /*#__PURE__*/React.createElement(SelectOptionFilter, {
    optionFilterLabel: optionFilterLabel,
    showOnlySelectedItems: showOnlySelectedItems,
    setShowOnlySelectedItems: setShowOnlySelectedItems,
    themeColor: themeColor
  }), /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement("div", {
    className: "lmnt-select__menu-footer"
  }, requireConfirmation && multiSelect && showCheckboxOptions && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(List, {
    inMenu: true
  }, /*#__PURE__*/React.createElement(ListDivider, null)), /*#__PURE__*/React.createElement(SelectConfirmation, {
    onConfirm: onChange,
    cancelLabel: cancelLabel,
    confirmLabel: confirmLabel,
    getValue: getValue,
    setValue: setValue,
    blurSelect: blurSelect,
    prevSelection: prevSelection,
    selectId: selectId,
    themeColor: themeColor
  })), trailingContent && /*#__PURE__*/React.createElement(SelectContent, {
    id: selectId
  }, trailingContent))));
});
SelectMenu.displayName = 'SelectMenu';
var SelectMenu$1 = /*#__PURE__*/React.memo(SelectMenu);

const getBoundingClientObj = element => {
  const rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
};
const SelectControlComponent = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    selectProps,
    innerProps,
    isFocused,
    children,
    hasValue,
    getValue
  } = props;
  const {
    ariaLabel,
    ariaLabelledBy,
    className,
    customProps,
    dense,
    disabled,
    fixedHeightInput,
    fullWidth,
    hoisted,
    leadingIcon,
    menuIsOpen,
    multiDisplayType,
    multiSelect,
    name,
    required,
    setControlRect,
    setSelectExtendedHeight,
    variant
  } = selectProps;
  const {
    onMouseDown
  } = {
    ...innerProps
  };
  const [extendedHeight, setExtendedHeight] = useState(false);
  const anchorResizeObserver = useRef();
  const anchorRef = useRef();
  const isOutlined = variant === 'outlined';
  const isFilled = variant === 'filled';
  const handleOnMouseDown = e => {
    onMouseDown(e);
  };
  useIsomorphicLayoutEffect(() => {
    const refCurrent = anchorRef.current;
    if (!fixedHeightInput || hoisted) {
      anchorResizeObserver.current = new ResizeObserver(entries => {
        const rect = getBoundingClientObj(entries[0].target);
        setControlRect(rect);
        if (multiDisplayType === 'pills') {
          setExtendedHeight(entries[0].contentRect.height > 68);
          setSelectExtendedHeight(entries[0].contentRect.height > 68);
        } else {
          setExtendedHeight(entries[0].contentRect.height > 56);
          setSelectExtendedHeight(entries[0].contentRect.height > 56);
        }
      });
      anchorResizeObserver.current.observe(refCurrent);
    }
    return () => {
      !fixedHeightInput && anchorResizeObserver.current && anchorResizeObserver.current.unobserve(refCurrent);
    };
  }, [fixedHeightInput, multiDisplayType, setSelectExtendedHeight, hoisted, setControlRect, extendedHeight]);
  return /*#__PURE__*/React.createElement("div", {
    ref: externalRef,
    tabIndex: -1,
    role: "button",
    onMouseDown: handleOnMouseDown,
    className: clsx('lmnt', 'mdc-select', 'lmnt-select', disabled && 'mdc-select--disabled', isOutlined && 'mdc-select--outlined lmnt-select--outlined', isFilled && 'mdc-select--filled lmnt-select--filled', leadingIcon && 'mdc-select--with-leading-icon', required && 'mdc-select--required', dense && 'lmnt-select--dense', fullWidth && 'lmnt-select--fullWidth', isFocused && 'mdc-select--focused', menuIsOpen && 'mdc-select--activated', multiSelect && 'lmnt-select--multi', hasValue && 'lmnt-select--has-value', multiDisplayType === 'pills' && 'lmnt-select--value-display-pills', multiDisplayType === 'text' && 'lmnt-select--value-display-text', className)
  }, !isOutlined && /*#__PURE__*/React.createElement("div", {
    className: clsx('mdc-line-ripple', isFocused && 'mdc-line-ripple--active')
  }), /*#__PURE__*/React.createElement(components.Control, _extends({}, props, {
    className: "lmnt-select-control-container"
  }), /*#__PURE__*/React.createElement("div", {
    ref: anchorRef,
    className: clsx('mdc-select__anchor', 'lmnt-select__anchor', extendedHeight && 'lmnt-select__anchor--extended-height'),
    "aria-disabled": disabled,
    "aria-haspopup": "listbox",
    role: "button",
    "aria-labelledby": ariaLabelledBy,
    "aria-label": ariaLabel
  }, leadingIcon ? /*#__PURE__*/React.createElement("div", {
    className: "lmnt-select-leading-icon"
  }, typeof leadingIcon === 'string' ? /*#__PURE__*/React.createElement("i", {
    className: "material-icons mdc-select__icon"
  }, leadingIcon) : leadingIcon) : null, children), /*#__PURE__*/React.createElement("input", _extends({
    name: name,
    type: "hidden",
    value: getValue()
  }, customProps))));
});
SelectControlComponent.displayName = 'SelectControlComponent';
var SelectControlComponent$1 = /*#__PURE__*/memo(SelectControlComponent);

const isInViewport = element => {
  const rect = element.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
};
const SelectOption = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    data,
    getValue,
    innerProps,
    isChildOption,
    isFocused,
    isSelected,
    selectProps,
    selected,
    setValue
  } = props;
  const {
    innerRef
  } = {
    ...innerProps
  };
  const {
    allChecked,
    allowTextWrappedOptions,
    categoryNameKey,
    checkAll,
    disabled: parentDisabled,
    groupNameKey,
    multiSelect,
    selectAllLabel,
    showCheckboxOptions,
    showOnlySelectedItems,
    themeColor,
    value
  } = selectProps;
  const {
    customProps,
    disabled
  } = data || {};
  const {
    className: customClassName,
    ...customPropsActual
  } = customProps || {};
  const disabledActual = parentDisabled || disabled;
  const selectedActual = useMemo(() => value === (data === null || data === void 0 ? void 0 : data.value) || multiSelect && (getValue === null || getValue === void 0 ? void 0 : getValue().some(v => v.value === data.value)) || selected || (data === null || data === void 0 ? void 0 : data.selected) || isSelected, [value, data.value, data === null || data === void 0 ? void 0 : data.selected, multiSelect, getValue, selected, isSelected]);
  const optionIndex = useMemo(() => {
    const idArray = innerProps === null || innerProps === void 0 ? void 0 : innerProps.id.split('-');
    return idArray === null || idArray === void 0 ? void 0 : idArray.pop();
  }, [innerProps === null || innerProps === void 0 ? void 0 : innerProps.id]);
  useEffect(() => {
    if (isFocused) {
      const el = document.querySelector(`.lmnt-select__menu-item-${optionIndex}`);
      if (el && !isInViewport(el)) {
        var _el$scrollIntoView;
        el === null || el === void 0 ? void 0 : (_el$scrollIntoView = el.scrollIntoView) === null || _el$scrollIntoView === void 0 ? void 0 : _el$scrollIntoView.call(el);
      }
    }
  }, [isFocused, optionIndex]);
  const variant = useMemo(() => getListVariant(data, groupNameKey, categoryNameKey), [groupNameKey, categoryNameKey, data]);
  const handleClick = useCallback(() => {
    if (multiSelect && getValue) {
      const values = getValue();
      if (values.some(v => v.value === data.value)) {
        setValue(values.filter(v => v.value !== data.value));
      } else setValue([...values, data]);
    } else {
      setValue(data);
    }
  }, [multiSelect, getValue, setValue, data]);
  const leadingBlockTypeToUse = useMemo(() => {
    if (multiSelect && showCheckboxOptions) {
      return 'checkbox';
    }
    return data.leadingBlockType;
  }, [multiSelect, showCheckboxOptions, data.leadingBlockType]);
  const leadingBlockToUse = useMemo(() => {
    if (multiSelect && showCheckboxOptions) {
      return /*#__PURE__*/React.createElement(Checkbox, {
        hideLabel: true,
        tabIndex: -1,
        label: data.label || children,
        checked: selectedActual,
        themeColor: themeColor
      });
    }
    return data.leadingBlock;
  }, [multiSelect, showCheckboxOptions, data.leadingBlock, data.label, selectedActual, themeColor, children]);
  const content = useMemo(() => {
    if (!variant || variant === 'standard') return data.label || children;
    return /*#__PURE__*/React.createElement(TypoSubtitle, {
      level: variant === 'category' ? 0 : 2
    }, data.label || children);
  }, [data.label, variant, children]);
  const refActual = useRef(innerRef);
  useImperativeHandle(externalRef, () => refActual.current, []);
  if (data.value === 'hidden') {
    return /*#__PURE__*/React.createElement(ListItem, _extends({
      ref: refActual
    }, customPropsActual, {
      className: clsx('lmnt-select-hidden-item', customClassName)
    }));
  }
  if (data.value === 'select-all') {
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ListItem, _extends({}, customPropsActual, {
      className: clsx('lmnt-select__select-all-checkbox', 'lmnt-select__menu-item', `lmnt-select__menu-item-${optionIndex}`, isFocused && 'lmnt-select__menu-item--has-focus', allowTextWrappedOptions && 'lmnt-select__menu-item--text-wrap', customClassName),
      disableHighlight: showCheckboxOptions,
      onClick: checkAll,
      ref: refActual,
      selected: allChecked,
      tabIndex: 0
    }), showCheckboxOptions ? /*#__PURE__*/React.createElement(Checkbox, {
      tabIndex: -1,
      label: selectAllLabel,
      checked: allChecked,
      themeColor: themeColor
    }) : selectAllLabel), /*#__PURE__*/React.createElement(ListDivider, {
      tabIndex: -1,
      variant: "padded",
      className: "mdc-list-divider--with-leading-checkbox"
    }));
  }
  return (
    /*#__PURE__*/
    // eslint-disable-next-line react/jsx-no-useless-fragment
    React.createElement(React.Fragment, null, !showOnlySelectedItems || showOnlySelectedItems && selectedActual ? /*#__PURE__*/React.createElement(ListItem, _extends({}, customPropsActual, innerProps, {
      "aria-disabled": disabledActual,
      "aria-selected": selectedActual,
      ariaChecked: selectedActual,
      className: clsx('lmnt-select__menu-item', `lmnt-select__menu-item-${optionIndex}`, isFocused && 'lmnt-select__menu-item--has-focus', allowTextWrappedOptions && 'lmnt-select__menu-item--text-wrap', customClassName),
      "data-value": data.value,
      disabled: disabledActual,
      disableHighlight: multiSelect && showCheckboxOptions,
      isChildOption: isChildOption,
      leadingBlock: leadingBlockToUse,
      leadingBlockType: leadingBlockTypeToUse,
      onClick: handleClick,
      ref: innerRef,
      role: !variant || variant === 'standard' || value ? 'option' : null,
      selected: selectedActual,
      tabIndex: 0,
      trailingBlock: data.trailingBlock,
      trailingBlockType: data.trailingBlockType,
      variant: variant,
      primaryText: content
    })) : null)
  );
});
SelectOption.displayName = 'SelectOption';
SelectOption.propTypes = SelectOptionPropTypes;
SelectOption.defaultProps = SelectOptionDefaultProps;

const SelectDropdownIcon = /*#__PURE__*/forwardRef((props, externalRef) => /*#__PURE__*/React.createElement(components.DropdownIndicator, _extends({
  ref: externalRef
}, props, {
  className: "lmnt-select-dropdown-container"
}), /*#__PURE__*/React.createElement("span", {
  className: "lmnt mdc-select__dropdown-icon"
}, /*#__PURE__*/React.createElement("svg", {
  className: "lmnt mdc-select__dropdown-icon-graphic",
  viewBox: "7 10 10 5"
}, /*#__PURE__*/React.createElement("polygon", {
  className: "lmnt mdc-select__dropdown-icon-inactive",
  stroke: "none",
  fillRule: "evenodd",
  points: "7 10 12 15 17 10"
}), /*#__PURE__*/React.createElement("polygon", {
  className: "lmnt mdc-select__dropdown-icon-active",
  stroke: "none",
  fillRule: "evenodd",
  points: "7 15 12 10 17 15"
})))));
SelectDropdownIcon.displayName = 'SelectDropdownIcon';
var SelectDropdownIcon$1 = /*#__PURE__*/React.memo(SelectDropdownIcon);

const SelectMultiValueRemove = /*#__PURE__*/forwardRef((props, externalRef) => /*#__PURE__*/React.createElement(components.MultiValueRemove, _extends({
  ref: externalRef
}, props), /*#__PURE__*/React.createElement(Icon, {
  tabIndex: 0,
  className: "lmnt-select-multi-value-remove--icon",
  icon: "cancel",
  pointer: true
})));
SelectMultiValueRemove.displayName = 'SelectMultiValueRemove';
var SelectMultiValueRemove$1 = /*#__PURE__*/React.memo(SelectMultiValueRemove);

const SelectMultiValue = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children
  } = {
    ...props
  };
  return /*#__PURE__*/React.createElement(components.MultiValue, _extends({
    ref: externalRef
  }, props, {
    className: "lmnt lmnt-select-multi-value-container"
  }), children);
});
SelectMultiValue.displayName = 'SelectMultiValue';
var SelectMultiValue$1 = /*#__PURE__*/memo(SelectMultiValue);

const SelectClearIndicator = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    innerProps: {
      ref,
      ...restInnerProps
    }
  } = {
    ...props
  };
  const refActual = useRef(ref);
  useImperativeHandle(externalRef, () => refActual.current, []);
  return /*#__PURE__*/React.createElement("div", _extends({}, restInnerProps, {
    ref: refActual,
    className: "lmnt-select-clear--icon-container"
  }), /*#__PURE__*/React.createElement(IconButton, {
    className: "lmnt-select-clear--icon",
    icon: "clear",
    dense: true,
    onKeyDown: event => {
      if (event.key) restInnerProps.onMouseDown(event);
    }
  }));
});
SelectClearIndicator.displayName = 'SelectClearIndicator';
var SelectClearIndicator$1 = /*#__PURE__*/React.memo(SelectClearIndicator);

const {
  estimateScrollWidth
} = {
  ...ponyfill
};
const getOutlinedLabelPositionY = selectAnchorHeight => selectAnchorHeight / 2 + 13.5 / 2;
function estimateScrollHeight(element) {
  if (!element) return 0;
  // Check the offsetParent. If the element inherits display: none from any
  // parent, the offsetParent property will be null (see
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).
  // This check ensures we only clone the node when necessary.
  const htmlEl = element;
  if (htmlEl.offsetParent !== null) {
    return htmlEl.scrollHeight;
  }
  const clone = htmlEl.cloneNode(true);
  clone.style.setProperty('position', 'absolute');
  clone.style.setProperty('transform', 'translate(-9999px, -9999px)');
  document.documentElement.appendChild(clone);
  const {
    scrollHeight
  } = {
    ...clone
  };
  document.documentElement.removeChild(clone);
  return scrollHeight;
}
const SelectLabel = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    isOutlined,
    float,
    label,
    selectId,
    extendedHeight,
    fixedHeightInput,
    required,
    containerId
  } = props;
  const labelRef = useRef();
  const [labelWidth, setLabelWidth] = useState();
  const [outlinedLabelPosition, setOutlinedLabelPosition] = useState();
  const [styleObject, setStyleObject] = useState();
  const menuResizeObserver = useRef();
  useImperativeHandle(externalRef, () => ({
    label: labelRef.current
  }), []);
  useEffect(() => {
    var _document$querySelect;
    const anchorElement = (_document$querySelect = document.querySelector(`#${containerId}`)) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.getElementsByClassName('lmnt-select__anchor')[0];
    if (!fixedHeightInput) {
      menuResizeObserver.current = new ResizeObserver(entries => {
        setOutlinedLabelPosition(entries[0].contentRect.height);
      });
      anchorElement && menuResizeObserver.current.observe(anchorElement);
    }
    return () => {
      anchorElement && !fixedHeightInput && menuResizeObserver.current && menuResizeObserver.current.unobserve(anchorElement);
    };
  }, [fixedHeightInput, containerId]);
  useEffect(() => {
    var _document$querySelect2;
    const anchorElement = (_document$querySelect2 = document.querySelector(`#${containerId}`)) === null || _document$querySelect2 === void 0 ? void 0 : _document$querySelect2.getElementsByClassName('lmnt-select__anchor')[0];
    if (anchorElement) {
      const selectHeight = estimateScrollHeight(anchorElement);
      setOutlinedLabelPosition(selectHeight);
    }
  }, [containerId, extendedHeight]);
  useEffect(() => {
    if (float && isOutlined) {
      setLabelWidth(labelRef.current ? estimateScrollWidth(labelRef.current) * 0.75 + 8 : 0);
      setStyleObject({
        transform: `translateY(-${getOutlinedLabelPositionY(outlinedLabelPosition)}px) scale(0.75)`
      });
    } else {
      setLabelWidth();
      setStyleObject();
    }
  }, [float, isOutlined, outlinedLabelPosition]);
  useImperativeHandle(externalRef, () => labelRef.current, []);
  return (
    /*#__PURE__*/
    // eslint-disable-next-line react/jsx-no-useless-fragment
    React.createElement(React.Fragment, null, !isOutlined ? /*#__PURE__*/React.createElement(FloatingLabel, {
      ref: labelRef,
      float: float,
      htmlFor: selectId,
      className: "lmnt-select-label"
    }, `${label || ''}${required ? '*' : ''}`) : /*#__PURE__*/React.createElement(NotchedOutline, {
      closed: !float,
      width: labelWidth
    }, label && /*#__PURE__*/React.createElement(FloatingLabel, {
      ref: labelRef,
      htmlFor: selectId,
      float: float,
      className: "lmnt-select-label",
      style: styleObject
    }, `${label}${required ? '*' : ''}`)))
  );
});
SelectLabel.displayName = 'SelectLabel';
SelectLabel.propTypes = SelectLabelPropTypes;
SelectLabel.defaultProps = SelectLabelDefaultProps;
var SelectLabel$1 = /*#__PURE__*/React.memo(SelectLabel);

const SelectIndicatorsContainer = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children
  } = {
    ...props
  };
  return /*#__PURE__*/React.createElement(components.IndicatorsContainer, _extends({
    ref: externalRef
  }, props, {
    className: "lmnt-select-indicators-container"
  }), children);
});
var SelectIndicatorsContainer$1 = /*#__PURE__*/React.memo(SelectIndicatorsContainer);

const SelectMenuList = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    selectProps
  } = {
    ...props
  };
  const {
    listType
  } = {
    ...selectProps
  };

  // HACK: setting innerRef to null disables react-select's freezing of the menu scrolling. This should be further investigated
  const hackedProps = {
    ...props,
    innerRef: null
  };
  const value = useMemo(() => ({
    inMenu: true
  }), []);
  return /*#__PURE__*/React.createElement(components.MenuList, _extends({
    ref: externalRef
  }, hackedProps), /*#__PURE__*/React.createElement(MenuContext.Provider, {
    value: value
  }, /*#__PURE__*/React.createElement(List, {
    listType: listType,
    role: "group"
  }, children)));
});
SelectMenuList.displayName = 'SelectMenuList';
var SelectMenuList$1 = /*#__PURE__*/React.memo(SelectMenuList);

const SelectPortal = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    getStyles,
    menuPosition,
    selectProps: {
      controlRect
    }
  } = props;
  const isFixed = useMemo(() => menuPosition === 'fixed', [menuPosition]);
  const scrollDistance = useMemo(() => isFixed ? 0 : window.pageYOffset, [isFixed]);
  const offset = useMemo(() => controlRect ? controlRect.bottom + scrollDistance + 4 : null, [controlRect, scrollDistance]);
  const state = useMemo(() => ({
    offset,
    position: menuPosition,
    rect: controlRect
  }), [menuPosition, offset, controlRect]);
  const styles = useMemo(() => {
    if (controlRect && getStyles('menuPortal', state)) {
      return {
        ...getStyles('menuPortal', state),
        top: getStyles('menuPortal', state).top,
        zIndex: 9999
      };
    }
    return {};
  }, [controlRect, state, getStyles]);
  return /*#__PURE__*/React.createElement(components.MenuPortal, _extends({
    ref: externalRef
  }, props, {
    css: styles
  }));
});
SelectPortal.displayName = 'SelectPortal';
SelectPortal.propTypes = SelectPortalPropTypes;

var SelectStyles = (menuMaxHeight => ({
  container: () => null,
  control: () => null,
  indicatorsContainer: () => null,
  indicatorContainer: () => null,
  dropdownIndicator: () => null,
  input: () => null,
  menu: () => ({
    maxHeight: menuMaxHeight
  }),
  menuList: () => ({
    maxHeight: menuMaxHeight
  }),
  menuPortal: base => ({
    ...base,
    zIndex: '99'
  }),
  multiValue: () => null,
  multiValueLabel: () => null,
  multiValueRemove: () => null,
  group: () => null,
  groupHeading: () => null,
  noOptionsMessage: () => null,
  option: () => null,
  singleValue: () => null,
  valueContainer: () => null
}));

const fullFilterConfig = {
  ignoreCase: true,
  ignoreAccents: true,
  matchFrom: 'start',
  stringify: option => `${option.label} ${option.value}`,
  trim: true
};
const removeEmpty = obj => Object.fromEntries(Object.entries(obj).filter(_ref => {
  let [_, v] = _ref;
  return v != null;
})); // eslint-disable-line no-unused-vars

const getParsedOptions = childrenLocal => React.Children.map(childrenLocal, child => {
  const {
    label: childLabel,
    value: childValue,
    children: childChildren,
    ...customChildProps
  } = child.props;
  return {
    label: childLabel || childChildren,
    text: childLabel || childChildren,
    value: childValue,
    customProps: removeEmpty(customChildProps)
  };
});
const Select = /*#__PURE__*/forwardRef((props, externalRef) => {
  var _selectRef$current, _selectRef$current$st;
  const {
    ariaLabel,
    ariaLabelledBy,
    cancelLabel,
    categoryNameKey,
    categoryValueKey,
    children,
    className,
    clearable,
    confirmLabel,
    containerProps,
    defaultOpen,
    dense,
    disabled,
    filterConfig,
    filterFunction,
    fixedHeightInput,
    groupNameKey,
    groupValueKey,
    helperText,
    helperTextId,
    helperTextPersistent,
    helperTextValidation,
    hideSelectedOptions,
    hoisted,
    id,
    isClearable,
    isMulti,
    label,
    leadingContent,
    leadingIcon,
    menuMaxHeight,
    multiDisplayType,
    multiSelect,
    name,
    noOptionsMessage,
    onBlur,
    onChange,
    onFocus,
    onInputChange,
    open,
    optionFilterLabel,
    options,
    portalContainer,
    requireConfirmation,
    required,
    searchable,
    selectAllLabel,
    showCheckboxOptions,
    showOptionFilter,
    showSelectAll,
    style,
    suppressInvalidOptionWarning,
    textKey,
    themeColor,
    trailingContent,
    tooltip,
    valid,
    value,
    valueDisplay,
    valueKey,
    variant,
    ...customProps
  } = props;
  const [controlRect, setControlRect] = useState();
  const [optionsActual, setOptionsActual] = useState(() => {
    if (options) return options;
    return getParsedOptions(children);
  });
  const [extendedHeight, setSelectExtendedHeight] = useState();
  const [float, setFloat] = useState();
  const [isFocused, setIsFocused] = useState(false);
  const [prevSelection, setPrevSelection] = useState(value);
  const [idActual] = useState(() => id || edsRandomId());
  const [helperTextIdActual] = useState(() => helperTextId || edsRandomId());
  const helperTextDomRef = useRef();
  const helperTextRef = useRef();
  const [selectValue, setSelectValue] = useState();
  const [showOnlySelectedItems, setShowOnlySelectedItems] = useState(false);
  const selectRef = useRef();
  const tooltipRef = useRef();
  const popperRef = useRef();
  const selectId = `${idActual}-select`;
  const containerId = `${idActual}-container`;
  const rootRef = useRef();
  const closeMenuOnSelect = useMemo(() => !multiSelect, [multiSelect]);
  const valueIsArray = Array.isArray(value);
  const hasArrayValue = valueIsArray && value.length > 0;
  const hasValue = valueIsArray ? hasArrayValue : value;
  const refVal = (_selectRef$current = selectRef.current) === null || _selectRef$current === void 0 ? void 0 : (_selectRef$current$st = _selectRef$current.state.focusedOption) === null || _selectRef$current$st === void 0 ? void 0 : _selectRef$current$st.value;
  const isOutlined = variant === 'outlined';
  const isValid = useMemo(() => valid === undefined || valid === null || valid === '' ? true : valid, [valid]);
  const classes = clsx('lmnt', 'lmnt-select-container', `lmnt-select--${variant}`, isFocused && 'mdc-select--focused', isOutlined && 'mdc-select--outlined', fixedHeightInput && 'lmnt-select--fixed-height', leadingIcon && 'lmnt-select--with-leading-icon', float && 'lmnt-select-float-label', multiDisplayType === 'pills' && 'lmnt-select--value-display-pills', multiDisplayType === 'text' && 'lmnt-select--value-display-text', dense && 'lmnt-select--dense', disabled && 'lmnt-select--is-disabled mdc-select--disabled', !isValid && 'mdc-select--invalid', className);
  useImperativeHandle(externalRef, () => selectRef.current, []);
  useEffect(() => {
    // HACK: this breaks when helperText is markup instead of string, so now we bypass it in that case
    if (helperText && typeof helperText === 'string') {
      helperTextRef.current = new MDCSelectHelperText(helperTextDomRef.current);
    }
    return () => {
      helperTextRef.current && helperTextRef.current.destroy();
    };
  }, [helperText]);
  useEffect(() => {
    if (helperText) {
      var _helperTextRef$curren, _helperTextRef$curren2, _helperTextRef$curren3;
      (_helperTextRef$curren = helperTextRef.current) === null || _helperTextRef$curren === void 0 ? void 0 : _helperTextRef$curren.foundation.setValidation(helperTextValidation);
      (_helperTextRef$curren2 = helperTextRef.current) === null || _helperTextRef$curren2 === void 0 ? void 0 : _helperTextRef$curren2.foundation.setValidity(isValid);
      (_helperTextRef$curren3 = helperTextRef.current) === null || _helperTextRef$curren3 === void 0 ? void 0 : _helperTextRef$curren3.foundation.setContent(helperText);
    }
  }, [helperText, helperTextValidation, isValid]);
  const mapNewOptions = (groupNameKeyLocal, optionsActualLocal, textKeyLocal, valueKeyLocal) => {
    if (!optionsActualLocal) return [];
    return optionsActualLocal.map(o => {
      if (typeof o === 'string' || typeof o === 'number') return {
        label: o,
        value: o
      };
      if (typeof o !== 'object') return null;
      if (!o[groupNameKeyLocal]) return {
        ...o,
        label: o[textKeyLocal],
        value: o[valueKeyLocal]
      };
      return {
        ...o,
        label: o[groupNameKeyLocal],
        options: o.options.map(opt => ({
          ...opt,
          label: opt[textKeyLocal],
          value: opt[valueKeyLocal]
        }))
      };
      // TODO: Add category functionality later
    });
  };

  const formatItems = useCallback(() => {
    const newOptions = mapNewOptions(groupNameKey, optionsActual, textKey, valueKey);
    if (showSelectAll && multiSelect) {
      newOptions.unshift({
        label: 'select-all',
        value: 'select-all',
        type: 'internal'
      });
    }
    if (requireConfirmation && multiSelect) {
      newOptions.push({
        label: 'hidden',
        value: 'hidden',
        type: 'internal',
        focusItem: `${idActual}-confirm`
      });
    }
    return newOptions;
  }, [groupNameKey, optionsActual, textKey, valueKey, showSelectAll, multiSelect, requireConfirmation, idActual]);
  const [items, setItems] = useState(() => formatItems());
  const getOptionItems = itemsLocal => itemsLocal.filter(item => (item === null || item === void 0 ? void 0 : item.type) !== 'internal');
  const getAllOptions = useCallback(itemsLocal => {
    const optionItems = getOptionItems(itemsLocal);
    const allOptions = [];
    optionItems.forEach(group => {
      group.options.forEach(o => allOptions.push(o));
    });
    return allOptions;
  }, []);
  const isValidObject = (optionItems, key) => Array.isArray(optionItems) && optionItems[0] && typeof optionItems[0] === 'object' && optionItems[0][key];
  const getListType = useCallback(() => {
    const optionItems = getOptionItems(items);
    if (isValidObject(optionItems, categoryNameKey)) return 'category';
    if (isValidObject(optionItems, groupNameKey)) return 'group';
    return 'simple';
  }, [categoryNameKey, groupNameKey, items]);
  const [listType, setListType] = useState(getListType());
  const [allChecked, setAllChecked] = useState(() => {
    const optionItems = getOptionItems(items);
    if (listType === 'simple') {
      return (prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.length) === (optionItems === null || optionItems === void 0 ? void 0 : optionItems.length);
    }
    if (listType === 'group') {
      const allOptions = getAllOptions(items);
      return (prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.length) === (allOptions === null || allOptions === void 0 ? void 0 : allOptions.length);
    }
    return null;
  });
  const filterOption = useMemo(() => {
    if (filterFunction) return filterFunction;
    return createFilter({
      ...fullFilterConfig,
      ...filterConfig
    });
  }, [filterConfig, filterFunction]);
  const focusElem = elemId => {
    var _document, _document$getElementB;
    (_document = document) === null || _document === void 0 ? void 0 : (_document$getElementB = _document.getElementById(elemId)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.focus();
  };
  const isSimpleValue = localValue => {
    if (!localValue) return true;
    if (Array.isArray(localValue)) return !localValue || typeof localValue[0] !== 'object' && typeof localValue !== 'function';
    return typeof localValue !== 'object' && typeof localValue !== 'function';
  };
  const getValueIndex = (opts, val) => opts.findIndex(o => o.value === val || o.text === val || o === val);
  const blurSelect = selectRefLocal => () => {
    selectRefLocal.current.blur();
  };
  const [menuPortalTarget, setMenuPortalTarget] = useState(() => {
    var _document2;
    if (!hoisted) return null;
    if (!portalContainer) return (_document2 = document) === null || _document2 === void 0 ? void 0 : _document2.body;
    if (typeof portalContainer === 'string') return edsQuerySelector(portalContainer);
    return portalContainer;
  });
  const handleFocus = useCallback(e => {
    setIsFocused(true);
    setFloat(true);
    onFocus && onFocus(e);
  }, [onFocus]);
  const handleBlur = useCallback(e => {
    var _e$relatedTarget;
    if (refVal === 'hidden' || ((_e$relatedTarget = e.relatedTarget) === null || _e$relatedTarget === void 0 ? void 0 : _e$relatedTarget.id) === `${idActual}-confirm`) {
      return;
    }
    setIsFocused(false);
    if (valueIsArray) {
      setFloat(!!value.length || !!selectRef.current.state.value && !!selectRef.current.state.value.length);
    } else {
      setFloat(!!value || !!selectRef.current.state.value);
    }
    if (multiSelect && requireConfirmation) {
      var _getOptionItems;
      selectRef.current.setValue(prevSelection);
      setAllChecked((prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.length) === ((_getOptionItems = getOptionItems(items)) === null || _getOptionItems === void 0 ? void 0 : _getOptionItems.length));
    }
    onBlur && onBlur(e);
  }, [refVal, idActual, valueIsArray, multiSelect, requireConfirmation, onBlur, value, prevSelection, items]);
  const handleChange = useCallback((val, action) => {
    if (action.action === 'cancel-selection') {
      selectRef.current.setValue(prevSelection);
      setSelectValue(prevSelection);
      setIsFocused(false);
      if (!open) {
        selectRef.current.setState({
          menuIsOpen: false
        }, blurSelect(selectRef));
      }
      selectRef.current.setState({
        focusedOption: null
      });
      blurSelect(selectRef.current);
      return;
    }
    // HACK: handleChange is being called with a null val on blur/menu close. Preventing this from erroring out for now. It should be further investigated
    if (val === undefined) return;
    let valueToSend;
    if (action.action === 'clear') {
      onChange === null || onChange === void 0 ? void 0 : onChange(val);
      setPrevSelection(val);
      return;
    }
    if (isSimpleValue(optionsActual) && !multiSelect) {
      valueToSend = val === null || val === void 0 ? void 0 : val.value;
    } else if (Array.isArray(val)) {
      valueToSend = val.map(v => {
        if (isSimpleValue(v)) {
          return val === null || val === void 0 ? void 0 : val.value;
        }
        return {
          [textKey]: v.label,
          [valueKey]: v.value
        };
      });
    } else {
      valueToSend = {
        [textKey]: val.label,
        [valueKey]: val.value
      };
    }
    if (Array.isArray(val) && val.length > 0 && !isFocused) {
      setFloat(false);
    } else {
      setFloat(!!val || isFocused);
    }
    if (!multiSelect || !requireConfirmation || !showCheckboxOptions) {
      onChange === null || onChange === void 0 ? void 0 : onChange(valueToSend);
      setPrevSelection(val);
      return;
    }
    if (action.action === 'confirm-selection') {
      onChange === null || onChange === void 0 ? void 0 : onChange(valueToSend);
      setPrevSelection(val);
      if (!open) selectRef.current.setState({
        menuIsOpen: false
      });
      blurSelect(selectRef.current);
    }
    setSelectValue(val);
  }, [optionsActual, isFocused, multiSelect, requireConfirmation, showCheckboxOptions, textKey, valueKey, onChange, open, prevSelection]);
  const checkAll = useCallback(() => {
    if (listType === 'simple') {
      const optionItems = getOptionItems(items);
      if (!selectValue || (selectValue === null || selectValue === void 0 ? void 0 : selectValue.length) < (optionItems === null || optionItems === void 0 ? void 0 : optionItems.length)) {
        setAllChecked(true);
        selectRef.current.setValue(optionItems);
      } else {
        selectRef.current.setValue([]);
        setAllChecked(false);
      }
    }
    if (listType === 'group') {
      const allOptions = getAllOptions(items);
      if (!selectValue || (selectValue === null || selectValue === void 0 ? void 0 : selectValue.length) < (allOptions === null || allOptions === void 0 ? void 0 : allOptions.length)) {
        setAllChecked(true);
        selectRef.current.setValue(allOptions);
      } else {
        selectRef.current.setValue([]);
        setAllChecked(false);
      }
    }
    return null;
  }, [listType, items, selectValue, getAllOptions]);
  const handleOnEnter = useCallback(e => {
    if (showSelectAll && multiSelect && refVal === 'select-all') {
      e.preventDefault();
      checkAll();
      return;
    }
    if (requireConfirmation && multiSelect && refVal === 'hidden') {
      e.preventDefault();
      if (e.target.id === `${idActual}-confirm`) {
        handleChange(selectRef.current.getValue(), {
          action: 'confirm-selection'
        });
      }
      if (e.target.id === `${idActual}-cancel`) {
        handleChange(prevSelection, {
          action: 'cancel-selection'
        });
      }
    }
  }, [checkAll, handleChange, idActual, multiSelect, prevSelection, refVal, requireConfirmation, showSelectAll]);

  // Handle focusing onto the confirm button. Note: A tad brittle.
  const getNextIndex = (itemsLength, previousIndex, isUp) => {
    const nextIndex = previousIndex + (isUp ? -1 : 1);
    if (isUp && nextIndex === -1) return itemsLength - 1;
    if (!isUp && nextIndex >= itemsLength) return 0;
    return nextIndex;
  };
  const focusNextItem = (item, isUp) => {
    var _document3, _confirm$parentElemen;
    const confirm = (_document3 = document) === null || _document3 === void 0 ? void 0 : _document3.getElementById(item === null || item === void 0 ? void 0 : item.focusItem);
    const next = isUp ? confirm === null || confirm === void 0 ? void 0 : (_confirm$parentElemen = confirm.parentElement) === null || _confirm$parentElemen === void 0 ? void 0 : _confirm$parentElemen.firstChild : confirm === null || confirm === void 0 ? void 0 : confirm.previousSibling;
    next === null || next === void 0 ? void 0 : next.focus();
  };
  const focusConfirmButton = item => {
    var _document$getElementB2;
    (_document$getElementB2 = document.getElementById(item === null || item === void 0 ? void 0 : item.focusItem)) === null || _document$getElementB2 === void 0 ? void 0 : _document$getElementB2.focus();
    selectRef.current.setState({
      menuIsOpen: true
    });
    selectRef.current.state.focusedOption = item;
  };
  const handleVerticalArrows = useCallback(e => {
    const isUp = e.code === 'ArrowUp';
    const previousIndex = items.findIndex(x => {
      var _selectRef$current$st2, _selectRef$current$st3;
      return x.value === ((_selectRef$current$st2 = selectRef.current.state) === null || _selectRef$current$st2 === void 0 ? void 0 : (_selectRef$current$st3 = _selectRef$current$st2.focusedOption) === null || _selectRef$current$st3 === void 0 ? void 0 : _selectRef$current$st3.value);
    });
    const nextIndex = getNextIndex(items === null || items === void 0 ? void 0 : items.length, previousIndex, isUp);
    if (!(requireConfirmation && multiSelect)) return;

    // if the prev item was the confirm button, focus to the appropriate item
    if (
    // eslint-disable-next-line no-unsafe-optional-chaining
    previousIndex === (items === null || items === void 0 ? void 0 : items.length) - 1 && e.target.id !== `${idActual}-cancel`) {
      e.preventDefault();
      focusNextItem(items[previousIndex], isUp);
      return;
    }

    // eslint-disable-next-line no-unsafe-optional-chaining
    if (nextIndex !== (items === null || items === void 0 ? void 0 : items.length) - 1) {
      selectRef.current.focus();
      return;
    }
    e.preventDefault();
    focusConfirmButton(items === null || items === void 0 ? void 0 : items[nextIndex]);
  }, [items, requireConfirmation, multiSelect, idActual]);
  const handleArrowLeft = useCallback(e => {
    e.preventDefault();
    if (e.target.id === `${idActual}-confirm`) {
      focusElem(`${idActual}-cancel`);
      selectRef.current.state.focusedOption = {
        label: 'hidden',
        value: 'hidden',
        type: 'internal',
        focusItem: `${idActual}-cancel`
      };
    }
  }, [idActual]);
  const handleArrowRight = useCallback(e => {
    e.preventDefault();
    if (e.target.id === `${idActual}-cancel`) focusElem(`${idActual}-confirm`);
  }, [idActual]);
  const handleOnEscape = useCallback(() => {
    handleChange(prevSelection, {
      action: 'cancel-selection'
    });
  }, [prevSelection, handleChange]);
  const onKeyPress = useCallback(e => {
    switch (e.key) {
      case 'Escape':
        handleOnEscape(e);
        break;
      case 'Enter':
      case ' ':
        handleOnEnter(e);
        break;
      case 'ArrowLeft':
        handleArrowLeft(e);
        break;
      case 'ArrowRight':
        handleArrowRight(e);
        break;
      case 'ArrowDown':
      case 'ArrowUp':
        handleVerticalArrows(e);
        break;
    }
  }, [handleArrowLeft, handleArrowRight, handleVerticalArrows, handleOnEnter, handleOnEscape]);
  useEffect(() => {
    if (options) {
      setOptionsActual(options);
      return;
    }
    const parsedOptions = getParsedOptions(children);
    setOptionsActual(parsedOptions);
  }, [options, children]);
  useEffect(() => {
    if (!hoisted) return;
    if (!portalContainer) {
      var _document4;
      setMenuPortalTarget((_document4 = document) === null || _document4 === void 0 ? void 0 : _document4.body);
      return;
    }
    if (typeof portalContainer === 'string') {
      setMenuPortalTarget(edsQuerySelector(portalContainer));
      return;
    }
    setMenuPortalTarget(portalContainer);
  }, [hoisted, portalContainer]);
  useEffect(() => {
    setListType(getListType());
  }, [getListType]);
  useEffect(() => {
    if (!hasValue) {
      setSelectValue(value);
      return;
    }
    if (isSimpleValue(value)) {
      if (!children) setSelectValue({
        label: value,
        value
      });
      const index = getValueIndex(optionsActual, value);
      if (index !== -1) {
        setSelectValue({
          label: optionsActual[index].text || value,
          value
        });
      } else if (!suppressInvalidOptionWarning) {
        edsWarning('Value sent is not an option');
      }
      return;
    }
    if (valueIsArray) {
      setSelectValue(value.map(v => isSimpleValue(v) ? v.value : {
        label: v[textKey],
        value: v[valueKey]
      }));
      return;
    }
    setSelectValue({
      label: value[textKey],
      value: value[valueKey]
    });
  }, [value, textKey, valueKey, children, optionsActual, valueIsArray, hasValue, suppressInvalidOptionWarning]);
  useEffect(() => {
    setItems(formatItems());
  }, [formatItems]);
  useEffect(() => {
    if (valueIsArray || Array.isArray(selectValue)) {
      setFloat(!!(value !== null && value !== void 0 && value.length) || isFocused || !!selectValue && !!(selectValue !== null && selectValue !== void 0 && selectValue.length));
    } else {
      setFloat(isFocused || !!selectValue);
    }
  }, [isFocused, value, selectValue, valueIsArray]);
  useEffect(() => {
    if (listType === 'simple') {
      const optionItems = getOptionItems(items);
      setAllChecked((prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.length) === (optionItems === null || optionItems === void 0 ? void 0 : optionItems.length));
    }
    if (listType === 'group') {
      const allOptions = getAllOptions(items);
      setAllChecked((prevSelection === null || prevSelection === void 0 ? void 0 : prevSelection.length) === (allOptions === null || allOptions === void 0 ? void 0 : allOptions.length));
    }
  }, [prevSelection, items, listType, getAllOptions]);
  useEffect(() => {
    if (listType === 'simple') {
      const optionItems = getOptionItems(items);
      setAllChecked((selectValue === null || selectValue === void 0 ? void 0 : selectValue.length) === (optionItems === null || optionItems === void 0 ? void 0 : optionItems.length));
    }
    if (listType === 'group') {
      const allOptions = getAllOptions(items);
      setAllChecked((selectValue === null || selectValue === void 0 ? void 0 : selectValue.length) === (allOptions === null || allOptions === void 0 ? void 0 : allOptions.length));
    }
  }, [items, selectValue, listType, getAllOptions]);
  const getNoOptionsMessage = useCallback(() => noOptionsMessage, [noOptionsMessage]);
  useEffect(() => {
    if (tooltip) {
      const position = tooltip.position || 'bottom';
      const modifiers = [{
        name: 'flip',
        options: {
          enabled: true,
          padding: {
            bottom: 32,
            top: 32
          }
        }
      }, {
        name: 'offset',
        options: {
          offset: [0, 12]
        }
      }];
      popperRef.current = createPopper(rootRef.current, tooltipRef.current, {
        placement: position,
        modifiers
      });
    }
    return () => {
      var _popperRef$current;
      (_popperRef$current = popperRef.current) === null || _popperRef$current === void 0 ? void 0 : _popperRef$current.destroy();
    };
  }, [tooltip === null || tooltip === void 0 ? void 0 : tooltip.position, tooltip]);
  const showTooltip = useCallback(() => {
    if (value) {
      const input = selectRef.current.controlRef.querySelector('.lmnt__single-value');
      if (input.offsetWidth < input.scrollWidth) {
        var _tooltipRef$current, _popperRef$current2, _popperRef$current3;
        (_tooltipRef$current = tooltipRef.current) === null || _tooltipRef$current === void 0 ? void 0 : _tooltipRef$current.setAttribute('data-show', '');
        (_popperRef$current2 = popperRef.current) === null || _popperRef$current2 === void 0 ? void 0 : _popperRef$current2.setOptions(opts => ({
          ...opts,
          modifiers: [...opts.modifiers, {
            name: 'eventListeners',
            enabled: true
          }]
        }));
        (_popperRef$current3 = popperRef.current) === null || _popperRef$current3 === void 0 ? void 0 : _popperRef$current3.update();
      }
    }
  }, [value]);
  const hideTooltip = useCallback(() => {
    var _tooltipRef$current2, _popperRef$current4;
    (_tooltipRef$current2 = tooltipRef.current) === null || _tooltipRef$current2 === void 0 ? void 0 : _tooltipRef$current2.removeAttribute('data-show');
    (_popperRef$current4 = popperRef.current) === null || _popperRef$current4 === void 0 ? void 0 : _popperRef$current4.setOptions(opts => ({
      ...opts,
      modifiers: [...opts.modifiers, {
        name: 'eventListeners',
        enabled: false
      }]
    }));
  }, []);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends({
    id: `${idActual}-container`,
    ref: rootRef,
    className: classes,
    style: style
  }, containerProps, {
    onMouseEnter: tooltip && showTooltip,
    onFocus: tooltip && showTooltip,
    onMouseLeave: tooltip && hideTooltip,
    onBlur: tooltip && hideTooltip
  }), /*#__PURE__*/React.createElement(RSelect, _extends({}, props, {
    ref: selectRef,
    id: `${idActual}`,
    instanceId: `${idActual}`,
    allChecked: allChecked,
    blurSelect: blurSelect(selectRef),
    checkAll: checkAll,
    "aria-controls": helperTextIdActual,
    "aria-describedby": helperTextIdActual,
    className: clsx('lmnt-select-inner-container', fixedHeightInput && 'lmnt-select--fixed-height'),
    classNamePrefix: "lmnt",
    closeMenuOnSelect: closeMenuOnSelect,
    components: {
      Control: SelectControlComponent$1,
      Menu: SelectMenu$1,
      ValueContainer: SelectValueContainer$1,
      Option: SelectOption,
      GroupHeading: SelectOption,
      IndicatorSeparator: null,
      DropdownIndicator: SelectDropdownIcon$1,
      MultiValueRemove: SelectMultiValueRemove$1,
      MultiValue: SelectMultiValue$1,
      ClearIndicator: SelectClearIndicator$1,
      IndicatorsContainer: SelectIndicatorsContainer$1,
      MenuList: SelectMenuList$1,
      MenuPortal: SelectPortal
    },
    isSearchable: searchable,
    leadingIcon: leadingIcon,
    controlRect: controlRect,
    setControlRect: setControlRect,
    defaultMenuIsOpen: defaultOpen,
    extendedHeight: extendedHeight,
    filterOption: filterOption,
    float: float,
    isClearable: isClearable || clearable,
    isDisabled: disabled,
    isMulti: isMulti || multiSelect,
    isOutlined: isOutlined,
    listType: listType,
    menuPlacement: "auto",
    menuPortalTarget: menuPortalTarget,
    onBlur: handleBlur,
    onChange: handleChange,
    onFocus: handleFocus,
    onKeyDown: onKeyPress,
    openMenuOnFocus: true,
    options: items,
    placeholder: "",
    prevSelection: prevSelection,
    selectId: selectId,
    selectOptionsProps: optionsActual,
    setSelectExtendedHeight: setSelectExtendedHeight,
    setShowOnlySelectedItems: setShowOnlySelectedItems,
    showOnlySelectedItems: showOnlySelectedItems,
    styles: SelectStyles(menuMaxHeight),
    tabSelectsValue: false,
    value: selectValue,
    valueDisplay: valueDisplay || multiDisplayType,
    variant: variant,
    disabled: disabled,
    customProps: customProps,
    themeColor: themeColor,
    optionFilterLabel: optionFilterLabel,
    noOptionsMessage: getNoOptionsMessage,
    menuIsOpen: open,
    menuShouldScrollIntoView: false,
    onInputChange: onInputChange,
    required: required
  })), /*#__PURE__*/React.createElement(SelectLabel$1, {
    extendedHeight: extendedHeight,
    label: label,
    isOutlined: isOutlined,
    id: `${idActual}-select-label`,
    selectId: selectId,
    containerId: containerId,
    float: float,
    variant: variant,
    required: required
  }), tooltip && /*#__PURE__*/React.createElement(TooltipText, _extends({
    role: "tooltip",
    id: idActual
  }, tooltip, {
    ref: tooltipRef,
    text: value
  }))), helperText && /*#__PURE__*/React.createElement("div", {
    ref: helperTextDomRef,
    id: helperTextIdActual,
    "aria-hidden": helperTextPersistent ? 'false' : 'true',
    className: clsx(['mdc-select-helper-text', helperTextValidation && 'mdc-select-helper-text--validation-msg'])
  }, helperText));
});
Select.displayName = 'Select';
Select.propTypes = SelectPropTypes;
Select.defaultProps = {
  ...SelectDefaultProps,
  filterConfig: {
    ignoreCase: true,
    ignoreAccents: true,
    matchFrom: 'any',
    stringify: option => `${option.label} ${option.value}`,
    trim: true
  }
};

const SelectContext = /*#__PURE__*/React.createContext({
  enhanced: false
});

const SelectMultiValueLabel = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children
  } = {
    ...props
  };
  return /*#__PURE__*/React.createElement(components.MultiValueLabel, _extends({
    ref: externalRef
  }, props, {
    className: "lmnt lmnt-select-multi-value-label"
  }), children);
});
SelectMultiValueLabel.displayName = 'SelectMultiValueLabel';
var SelectMultiValueLabel$1 = /*#__PURE__*/memo(SelectMultiValueLabel);

export { Select, SelectClearIndicator$1 as SelectClearIndicator, SelectConfirmation, SelectContext, SelectControlComponent$1 as SelectControlComponent, SelectDropdownIcon$1 as SelectDropdownIcon, SelectIndicatorsContainer$1 as SelectIndicatorsContainer, SelectLabel$1 as SelectLabel, SelectMenu$1 as SelectMenu, SelectMenuList$1 as SelectMenuList, SelectMultiValue$1 as SelectMultiValue, SelectMultiValueLabel$1 as SelectMultiValueLabel, SelectMultiValueRemove$1 as SelectMultiValueRemove, SelectOption, SelectOptionFilter, SelectPortal, SelectStyles, SelectValueContainer$1 as SelectValueContainer };
//# sourceMappingURL=index.es.js.map
