import _extends from '@babel/runtime-corejs3/helpers/extends';
import clsx from 'clsx';
import React, { forwardRef, useRef, useState, useImperativeHandle, useEffect, useCallback, useMemo } from 'react';
import { MDCBanner } from '@material/banner';
import PropTypes from 'prop-types';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const BannerPropTypes = {
  /**
   * Indicates that the banner should have more white-space padding than default.
   *
   * Defaults to **null**.
   */
  airy: PropTypes.bool,
  /**
   * Content to be rendered inside the banner. Accepts any valid markup.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node.isRequired,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * If using a custom top app bar with banner, you will have to send in the height of the custom top app bar so the banner positions correctly, ie 55px. You will be responsible for making sure the page content aligns properly upon opening and closing the Banner.  The Banner Margin Fix component allows you to wrap the content and send in the margin top or you can use a custom component.
   *
   * Defaults to **null**.
   */
  customTopAppBarHeight: PropTypes.string,
  /**
   * Indicates that the banner will be used with an Element Drawer.
   *
   * Defaults to **null**.
   */
  drawer: PropTypes.bool,
  /**
   * Indicates that the banner should have box-shadow and elevation styles. Should be used when banner is fixed. Flat style by default.
   *
   * Defaults to **null**.
   */
  elevated: PropTypes.bool,
  /**
   * Indicates that the banner will be in a fixed position.
   *
   * Defaults to **null**.
   */
  fixed: PropTypes.bool,
  /**
   * Banner media slot can hold an image, icon, or other media. (40x40).
   *
   * Defaults to **null**.
   */
  media: PropTypes.node,
  /**
   * Fired when the banner finishes its closing animation.
   *
   * Defaults to **null**.
   */
  onClosed: PropTypes.func,
  /**
   * Fired when the banner begins its closing animation.
   *
   * Defaults to **null**.
   */
  onClosing: PropTypes.func,
  /**
   * Fired when the banner finishes its opened animation.
   *
   * Defaults to **null**.
   */
  onOpened: PropTypes.func,
  /**
   * Fired when the banner begins its MDCBanner:opening animation.
   *
   * Defaults to **null**.
   */
  onOpening: PropTypes.func,
  /**
   * Fired when the Primary Action Button is clicked. Runs after closing animation begins.
   *
   * Defaults to **null**.
   */
  onPrimaryClicked: PropTypes.func,
  /**
   * Fired when the Secondary Action Button is clicked. Runs after closing animation begins.
   *
   * Defaults to **null**.
   */
  onSecondaryClicked: PropTypes.func,
  /**
   * Indicates that the banner should be open. Open by default. Animates between states with transition CSS.
   *
   * Defaults to **true**.
   */
  open: PropTypes.bool,
  /**
   * If true clicking on the primary button will dismiss the banner. At least one button must dismiss the banner. If both primary and secondary buttons are marked as not dismissive, the primary button will default to dismissive.
   *
   * Defaults to **true**.
   */
  primaryButtonDismissive: PropTypes.bool,
  /**
   * Banner primary button label text.
   *
   * Defaults to **'Ok'**.
   */
  primaryButtonLabel: PropTypes.string,
  /**
   * If true clicking on the secondary button will dismiss the banner. At least one button must dismiss the banner. If both secondary and secondary buttons are marked as not dismissive, the primary button will default to dismissive.
   *
   * Defaults to **true**.
   */
  secondaryButtonDismissive: PropTypes.bool,
  /**
   * Banner action button label text.
   *
   * Defaults to **null**.
   */
  secondaryButtonLabel: PropTypes.string,
  /**
   * Indicates that the banner background-color should use Element's 'surface variant' color. Uses 'surface' by default.
   *
   * Defaults to **null**.
   */
  surfaceVariant: PropTypes.bool,
  /**
   * Indicates that the banner will be used with an Element Top App Bar.
   *
   * Defaults to **null**.
   */
  topAppBar: PropTypes.bool,
  /**
   * Indicates which type of Element Top App Bar Banner will be used with.
   *
   * Defaults to **'fixed'**.
   */
  topAppBarVariant: PropTypes.oneOf(["fixed", "relative", "dense", "prominent", "dense-prominent", "dense-fixed", "prominent-fixed", "dense-prominent-fixed"])
};
const BannerDefaultProps = {
  airy: null,
  children: null,
  className: undefined,
  customTopAppBarHeight: null,
  drawer: null,
  elevated: null,
  fixed: null,
  media: null,
  open: true,
  primaryButtonDismissive: true,
  primaryButtonLabel: "Ok",
  secondaryButtonDismissive: true,
  secondaryButtonLabel: null,
  surfaceVariant: null,
  topAppBar: null,
  topAppBarVariant: "fixed"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const BannerMarginFixPropTypes = {
  /**
   * If supplied, the adjusted margin will attempt to be automatically calculated.
   *
   * Defaults to **undefined**.
   */
  bannerId: PropTypes.string,
  /**
   * Apply the adjusted left margin.
   *
   * Defaults to **false**.
   */
  bannerOpen: PropTypes.bool,
  /**
   * Content to be vertically adjusted. Accepts any valid markup.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * The spacing between the bottom of the banner and the top of the content being adjusted.
   *
   * Defaults to **24**.
   */
  extraMargin: PropTypes.number,
  /**
   * Custom margin.
   *
   * Defaults to **0**.
   */
  marginTop: PropTypes.number,
  /**
   * Passthrough style object.
   *
   * Defaults to **null**.
   */
  style: PropTypes.object
};
const BannerMarginFixDefaultProps = {
  bannerId: undefined,
  bannerOpen: false,
  children: null,
  className: undefined,
  extraMargin: 24,
  marginTop: 0,
  style: null
};

const Banner = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    airy,
    children,
    className,
    customTopAppBarHeight,
    dismissButtonLabel,
    drawer,
    elevated,
    fixed,
    open,
    media,
    onClosed,
    onClosing,
    onOpened,
    onOpening,
    onPrimaryClicked,
    onSecondaryClicked,
    primaryButtonDismissive,
    primaryButtonLabel,
    secondaryButtonDismissive,
    secondaryButtonLabel,
    style,
    surfaceVariant,
    topAppBar,
    topAppBarVariant,
    ...customProps
  } = props;
  const ref = useRef();
  const bannerRef = useRef();
  const [height, setHeight] = useState(0);
  const [isOpen, setIsOpen] = useState(open);
  useImperativeHandle(externalRef, () => ({
    open: isOpen,
    height,
    current: ref.current
  }), [height, isOpen]);
  useEffect(() => {
    bannerRef.current = new MDCBanner(ref.current);
    return () => {
      bannerRef.current.destroy();
    };
  }, [bannerRef]);
  const getReason = reason => {
    switch (reason) {
      case 0:
        return 'primaryClicked';
      case 1:
        return 'secondaryClicked';
      default:
        return 'programmatically';
    }
  };
  const handleOnClosing = useCallback(e => {
    onClosing && onClosing(getReason(e.detail.reason), e);
  }, [onClosing]);
  useEffect(() => {
    bannerRef.current.listen('MDCBanner:closing', handleOnClosing);
    return () => {
      bannerRef.current.unlisten('MDCBanner:closing', handleOnClosing);
    };
  }, [bannerRef, handleOnClosing]);
  const handleOnClosed = useCallback(e => {
    onClosed && onClosed(getReason(e.detail.reason), e);
    setIsOpen(false);
  }, [onClosed]);
  useEffect(() => {
    bannerRef.current.listen('MDCBanner:closed', handleOnClosed);
    return () => {
      bannerRef.current.unlisten('MDCBanner:closed', handleOnClosed);
    };
  }, [bannerRef, handleOnClosed]);
  useEffect(() => {
    bannerRef.current.listen('MDCBanner:opening', onOpening);
    return () => {
      bannerRef.current.unlisten('MDCBanner:opening', onOpening);
    };
  }, [bannerRef, onOpening]);
  const handleOnOpened = useCallback(() => {
    onOpened === null || onOpened === void 0 ? void 0 : onOpened();
    setHeight(bannerRef.current.foundation.adapter.getContentHeight());
    setIsOpen(open === false || true);
  }, [onOpened, open]);
  useEffect(() => {
    bannerRef.current.listen('MDCBanner:opened', handleOnOpened);
    return () => {
      bannerRef.current.unlisten('MDCBanner:opened', handleOnOpened);
    };
  }, [handleOnOpened]);
  useEffect(() => {
    if (open) {
      !bannerRef.current.isOpen && bannerRef.current.open();
    } else {
      bannerRef.current.isOpen && bannerRef.current.close();
    }
  }, [open]);
  const handleWindowSizeChange = useCallback(() => {
    bannerRef.current && bannerRef.current.layout();
  }, []);
  useEffect(() => {
    /* eslint-disable no-undef */
    window.addEventListener('resize', handleWindowSizeChange);
    return () => {
      window.removeEventListener('resize', handleWindowSizeChange);
    };
    /* eslint-enable no-undef */
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const classNames = clsx('lmnt', 'lmnt-banner', 'mdc-banner', 'mdc-banner--mobile-stacked', airy && 'lmnt-banner--airy', fixed && 'lmnt-banner--fixed', topAppBar && 'lmnt-banner--top-app-bar', topAppBar && topAppBarVariant === 'fixed' && 'lmnt-banner--top-app-bar-fixed', topAppBar && topAppBarVariant === 'prominent' && 'lmnt-banner--top-app-bar--prominent', topAppBar && topAppBarVariant === 'dense' && 'lmnt-banner--top-app-bar--dense', topAppBar && topAppBarVariant === 'dense-prominent' && 'lmnt-banner--top-app-bar--dense-prominent', topAppBar && topAppBarVariant === 'prominent-fixed' && 'lmnt-banner--top-app-bar--prominent-fixed', topAppBar && topAppBarVariant === 'dense-fixed' && 'lmnt-banner--top-app-bar--dense-fixed', topAppBar && topAppBarVariant === 'dense-prominent-fixed' && 'lmnt-banner--top-app-bar--dense-prominent-fixed', drawer && 'lmnt-banner--drawer', elevated && 'lmnt-banner--elevated', surfaceVariant && 'lmnt-banner--surface-variant', bannerRef.current && bannerRef.current.isOpen && 'mdc-banner--open', className);
  const bannerStyles = useMemo(() => customTopAppBarHeight ? {
    ...style,
    top: customTopAppBarHeight,
    marginTop: 0,
    position: 'fixed'
  } : style, [style, customTopAppBarHeight]);
  const innerStyles = useMemo(() => customTopAppBarHeight ? {
    top: customTopAppBarHeight
  } : {}, [customTopAppBarHeight]);
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: ref,
    "aria-hidden": !open,
    className: classNames
  }, customProps, {
    style: bannerStyles,
    role: "banner"
  }), /*#__PURE__*/React.createElement("div", {
    className: clsx('lmnt-banner__inner', fixed && !airy && 'mdc-banner__fixed'),
    style: innerStyles
  }, /*#__PURE__*/React.createElement("div", {
    className: "mdc-banner__content lmnt-banner__content",
    role: "status",
    "aria-live": "assertive"
  }, /*#__PURE__*/React.createElement("div", {
    className: "mdc-banner__graphic-text-wrapper"
  }, media && /*#__PURE__*/React.createElement("div", {
    className: "lmnt-banner__media mdc-banner__graphic",
    role: "img"
  }, media), /*#__PURE__*/React.createElement("div", {
    className: "mdc-banner__text mdc-typography"
  }, children || /*#__PURE__*/React.createElement("p", null, "Banner text should be provided locally."))), /*#__PURE__*/React.createElement("div", {
    className: "mdc-banner__actions lmnt-banner__actions"
  }, secondaryButtonLabel && /*#__PURE__*/React.createElement("button", {
    onClick: onSecondaryClicked,
    className: clsx('mdc-button', secondaryButtonDismissive && 'mdc-banner__secondary-action'),
    type: "button"
  }, secondaryButtonLabel), /*#__PURE__*/React.createElement("button", {
    tabIndex: "0",
    onClick: onPrimaryClicked,
    className: clsx('mdc-button', (primaryButtonDismissive || !primaryButtonDismissive && !secondaryButtonDismissive) && 'mdc-banner__primary-action'),
    type: "button"
  }, primaryButtonLabel)))));
});
Banner.displayName = 'Banner';
Banner.propTypes = BannerPropTypes;
Banner.defaultProps = BannerDefaultProps;

const BannerMarginFix = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    bannerId,
    bannerOpen,
    children,
    className,
    extraMargin,
    marginTop,
    style,
    ...customProps
  } = props;
  const styles = useMemo(() => bannerOpen ? {
    ...style,
    marginTop: marginTop + extraMargin
  } : style, [bannerOpen, marginTop, extraMargin, style]);
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: externalRef
  }, customProps, {
    style: styles,
    className: clsx('lmnt-banner--margin-fix', className)
  }), children);
});
BannerMarginFix.displayName = 'BannerMarginFix';
BannerMarginFix.propTypes = BannerMarginFixPropTypes;
BannerMarginFix.defaultProps = BannerMarginFixDefaultProps;

export { Banner, BannerMarginFix };
//# sourceMappingURL=index.es.js.map
