import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { forwardRef, useRef, useImperativeHandle, useEffect, useMemo, createContext, useState, useContext, Fragment, useCallback } from 'react';
import { deprecatedProp, edsRandomId, ConditionalWrapper, edsWarning as edsWarning$1, HoistingContext, hoistingEnabled } from '@element/react-common';
import clsx from 'clsx';
import { MDCDataTable } from '@material/data-table';
import { edsWarning } from '@element/shared';
import PropTypes from 'prop-types';
import sortBy from 'lodash/sortBy';
import { Textfield } from '@element/react-textfield';
import { Checkbox } from '@element/react-checkbox';
import { Switch } from '@element/react-switch';
import { Datepicker } from '@element/react-datepicker';
import { useSortBy, usePagination, useBlockLayout, useResizeColumns, useFlexLayout, useAbsoluteLayout, useExpanded, useTable } from 'react-table';
import { VariableSizeList, FixedSizeList } from 'react-window';
import { useSortable, sortableKeyboardCoordinates, SortableContext, horizontalListSortingStrategy } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { useSensors, useSensor, PointerSensor, MouseSensor, KeyboardSensor, DndContext, closestCenter } from '@dnd-kit/core';
import { Pagination } from '@element/react-pagination';
import { TypoDisplay } from '@element/react-typography';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TablePropTypes = {
  /**
   * The table will always use div tags instead of standard table tags. Note, disabled when using `layout='standard'`.
   *
   * Defaults to **false**.
   */
  alwaysUseDivTags: PropTypes.bool,
  /**
   * Accessibility label for assistive technologies.
   *
   * Defaults to **null**.
   */
  ariaLabel: PropTypes.string,
  /**
   * Enable the user to toggle sortable columns between ascending, descending, and unsorted.
   *
   * Defaults to **false**.
   */
  canUnSort: PropTypes.bool,
  /**
   * Pass custom props directly to each TableCell (generated & virtualized modes only). Can be either an object or a function that receives the following signature `(cellData)`.
   *
   * Defaults to **undefined**.
   */
  cellProps: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  /**
   * The composed table elements. Expects one each of TableHeader, TableBody.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Allow columns to be re-ordered using drag and drop headers. Note, this cannot be used with fixed columns.
   *
   * Defaults to **false**.
   */
  columnReordering: PropTypes.bool,
  /**
   * Apply a striped effect to columns.
   *
   * Defaults to **false**.
   */
  columnStriped: PropTypes.bool,
  /**
   * Array of objects describing the table columns, used in conjunction with `data` prop. **See README for the full column schema.**  **Note:** do not use `children` when using `data` and `columns`.
   *
   * Defaults to **[]**.
   */
  columns: PropTypes.arrayOf(PropTypes.object),
  /**
   * Custom properties to be applied to the table container.
   *
   * Defaults to **null**.
   */
  containerProps: PropTypes.object,
  /**
   * Array of data. Must be used in conjunction with `columns`. **Note:** do not use `children` when using `data` and `columns`.
   *
   * Defaults to **null**.
   */
  data: PropTypes.arrayOf(PropTypes.object),
  /**
   * An object to describe the the default column properties if none else are specified via data.
   *
   * Defaults to **null**.
   */
  defaultColumn: PropTypes.object,
  /**
   * A more compact table with less padding.
   *
   * Defaults to **false**.
   */
  dense: PropTypes.bool,
  /**
   * Disable multi-column sorting.
   *
   * Defaults to **false**.
   */
  disableMultiSort: PropTypes.bool,
  /**
   * Indicates if the table supports expandable rows. See 'Expandable Rows' in the README for details.
   *
   * Defaults to **undefined**.
   */
  expandable: PropTypes.bool,
  /**
   * Used to render secondary content when used with `expandable`. Note: this is only shown when a row is expanded using a button using `row.getToggleRowExpandedProps()` or `row.getToggleAllRowsExpandedProps()`. See 'Expandable Rows' in the README for details.
   *
   * Defaults to **undefined**.
   */
  expandedRowTemplate: PropTypes.func,
  /**
   * On by default, setting this to false will remove the additional trailing border added to fixed columns. This should only be used where there is an alternate means of showing which columns are fixed, ie. background color or elevation.
   *
   * Defaults to **true**.
   */
  fixedColumnsBorder: PropTypes.bool,
  /**
   * The header row will remain fixed on-screen, while the body may scroll under it. This will automatically be applied when `virtualized` is `true`. Warning, `fixedHeader` requires a layout of `standard`.
   *
   * Defaults to **false**.
   */
  fixedHeader: PropTypes.bool,
  /**
   * Content to appear at the bottom of the table. Expects a `TableFooter` component with one or more `TableRows` and `TableCells` or `TableHeaderCells`
   *
   * Defaults to **null**.
   */
  footerContent: PropTypes.node,
  /**
   * The table will expand it's width to 100% of it's parent container.
   *
   * Defaults to **false**.
   */
  fullWidth: PropTypes.bool,
  /**
   * Pass custom props directly to each TableHeaderCell (generated & virtualized modes only). Can be either an object or a function that receives the following signature `(column)`.
   *
   * Defaults to **undefined**.
   */
  headerCellProps: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  /**
   * Content to appear at the top of the table. Expects a `TableHeader` component with  one or more `TableRows` and `TableCells` or `TableHeaderCells`
   *
   * Defaults to **null**.
   */
  headerContent: PropTypes.node,
  /**
   * The divider between the header and rows will be taller. Used in conjunction with `headerDividerThemeColor` to add a splash of color to a table.
   *
   * Defaults to **false**.
   */
  headerDividerTall: PropTypes.bool,
  /**
   * Add a splash of color to the divider between the header and rows.
   *
   * Defaults to **null**.
   */
  headerDividerThemeColor: PropTypes.oneOf(["", "primary", "secondary", "primary-variant", "secondary-variant"]),
  /**
   * Pass custom props directly to each TableHeaderRow (generated & virtualized modes only). Can be either an object or a function that receives the following signature `(rowData, rowIndex)`.
   *
   * Defaults to **undefined**.
   */
  headerRowProps: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  /**
   * Enabled the header of the card to use a surface color, similar to the colored header on a `Card` component. Should be used sparingly.
   *
   * Defaults to **null**.
   */
  headerThemeColor: PropTypes.oneOf(["", "neutral", "primary", "secondary", "primary-variant", "secondary-variant"]),
  /**
   * Fixed height of the table. Required when `layout` is `fixed`, `virtualized` is `true` or `fixedHeader` is `true`. Note, must be a unit-less number (in pixels).
   *
   * Defaults to **null**.
   */
  height: PropTypes.number,
  /**
   * An array of id's for columns to hide.
   *
   * Defaults to **undefined**.
   */
  hiddenColumns: PropTypes.arrayOf(PropTypes.string),
  /**
   * Hides the horizontal scrollbar. Note: only use when alternative scrolling is offered.
   *
   * Defaults to **false**.
   */
  hideHorizontalScrollbar: PropTypes.bool,
  /**
   * All expandable/collapsible rows will be expanded when used with `expandable`.
   *
   * Defaults to **undefined**.
   */
  initiallyExpanded: PropTypes.bool,
  /**
   * The style of layout to use. Notes: In most cases the column width will default to 150px, with the exception of `standard`, which uses browser default table layout. Using `resizableColumns` or `columnReordering` will force layout to `block`. Using `virtualized` will use it's own layout technique. Fixed headers requires the `standard` layout. Warning: the default value will change to `standard` in v6.
   *
   * Defaults to **'block'**.
   */
  layout: PropTypes.oneOf(["standard", "block", "flex"]),
  /**
   * Custom content to appear inside the table container directly above the actual table.
   *
   * Defaults to **null**.
   */
  leadingContent: PropTypes.node,
  /**
   * Removes certain margins and paddings for better appearance when nesting tables. Used on the child (nested) table.
   *
   * Defaults to **false**.
   */
  nested: PropTypes.bool,
  /**
   * Show the table header with the `noContentMessage` when there is no table content or data.
   *
   * Defaults to **false**.
   */
  noContentIncludeTable: PropTypes.bool,
  /**
   * The message to show when there is no table content or data.
   *
   * Defaults to **'There is no content available.'**.
   */
  noContentMessage: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.node]),
  /**
   * Prevents hover highlighting effect on rows.
   *
   * Defaults to **false**.
   */
  noHover: PropTypes.bool,
  /**
   * Event that is fired when table data has been updated, such as when a column is dragged and dropped. Warning, this only fires when using `data` and `columns` props. It does not work when directly composing Table components.
   *
   * Defaults to **null**.
   */
  onStateChange: PropTypes.func,
  /**
   * Event that is fired when table width has been changed, either by the browser window or other layout changes. Warning, this only fires when using `data` and `columns` props. It does not work when directly composing Table components.
   *
   * Defaults to **null**.
   */
  onWidthChange: PropTypes.func,
  /**
   * Enable built-in pagination.
   *
   * Defaults to **false**.
   */
  paginated: PropTypes.bool,
  /**
   * Customize table behavior.
   *
   * Defaults to **null**.
   */
  plugins: PropTypes.arrayOf(PropTypes.object),
  /**
   * Enable columns to be resized by the user.
   *
   * Defaults to **null**.
   */
  resizableColumns: PropTypes.bool,
  /**
   * When using `variableHeight` rowHeight must be specified as a function, otherwise the default row height of `50` should be used except in cases of custom CSS. The function will receive the rowIndex as a parameter.
   *
   * Defaults to **50**.
   */
  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),
  /**
   * Pass custom props directly to each TableRow (generated & virtualized modes only). Can be either an object or a function that receives the following signature `(rowData, rowIndex)`..
   *
   * Defaults to **undefined**.
   */
  rowProps: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  /**
   * Apply a stripped effect to the rows.
   *
   * Defaults to **null**.
   */
  rowStriped: PropTypes.bool,
  /**
   * Enable the sort indicator to be hidden until the header cell is hovered/activated.
   *
   * Defaults to **false**.
   */
  sortIndicatorOnHover: PropTypes.bool,
  /**
   * Enable built-in column sorting.
   *
   * Defaults to **false**.
   */
  sortable: PropTypes.bool,
  /**
   * Passthrough style object.
   *
   * Defaults to **null**.
   */
  style: PropTypes.object,
  /**
   * @deprecated _Use `leadingContent` instead._
   *
   * Custom content to appear inside the table container directly above the actual table.
   *
   * Defaults to **null**.
   */
  topBar: deprecatedProp(PropTypes.node, "Table", "Use `leadingContent` instead."),
  /**
   * Custom content to appear inside the table container directly below the actual table.
   *
   * Defaults to **null**.
   */
  trailingContent: PropTypes.node,
  /**
   * Used with virtualized tables with expandable rows that are of varying sizes or a different size than the original row.
   *
   * Defaults to **false**.
   */
  variableHeight: PropTypes.bool,
  /**
   * Enable virtualized rendering for high performance with large amounts of data.
   *
   * Defaults to **false**.
   */
  virtualized: PropTypes.bool,
  /**
   * Fixed width for the table. Required for a `layout` of `fixed`. Note, must be a unit-less number (in pixels).
   *
   * Defaults to **null**.
   */
  width: PropTypes.number
};
const TableDefaultProps = {
  alwaysUseDivTags: false,
  ariaLabel: null,
  canUnSort: false,
  cellProps: undefined,
  children: null,
  className: undefined,
  columnReordering: false,
  columnStriped: false,
  columns: [],
  containerProps: null,
  data: null,
  defaultColumn: null,
  dense: false,
  disableMultiSort: false,
  expandable: undefined,
  expandedRowTemplate: undefined,
  fixedColumnsBorder: true,
  fixedHeader: false,
  footerContent: null,
  fullWidth: false,
  headerCellProps: undefined,
  headerContent: null,
  headerDividerTall: false,
  headerDividerThemeColor: null,
  headerRowProps: undefined,
  headerThemeColor: null,
  height: null,
  hiddenColumns: undefined,
  hideHorizontalScrollbar: false,
  initiallyExpanded: undefined,
  layout: "block",
  leadingContent: null,
  nested: false,
  noContentIncludeTable: false,
  noContentMessage: "There is no content available.",
  noHover: false,
  paginated: false,
  plugins: null,
  resizableColumns: null,
  rowHeight: 50,
  rowProps: undefined,
  rowStriped: null,
  sortIndicatorOnHover: false,
  sortable: false,
  style: null,
  topBar: null,
  trailingContent: null,
  variableHeight: false,
  virtualized: false,
  width: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableBodyPropTypes = {
  /**
   * The table will always use div tags instead of standard table tags. Note, disabled when using `layout='standard'`.
   *
   * Defaults to **false**.
   */
  alwaysUseDivTags: PropTypes.bool,
  /**
   * Expects one or more `TableRow` components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Passthrough style object.
   *
   * Defaults to **null**.
   */
  style: PropTypes.object,
  /**
   * Fixed width for table body.
   *
   * Defaults to **null**.
   */
  width: PropTypes.number
};
const TableBodyDefaultProps = {
  alwaysUseDivTags: false,
  children: null,
  className: undefined,
  style: null,
  width: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableCellPropTypes = {
  /**
   * The table will always use div tags instead of standard table tags. Note, disabled when using `layout='standard'`.
   *
   * Defaults to **false**.
   */
  alwaysUseDivTags: PropTypes.bool,
  /**
   * @deprecated _This prop has been deprecated in favor of `cellProps` in the column schema (see README), which offers more flexibility._
   *
   * Enabled a custom background color.
   *
   * Defaults to **undefined**.
   */
  backgroundColor: deprecatedProp(PropTypes.string, "TableCell", "This prop has been deprecated in favor of `cellProps` in the column schema (see README), which offers more flexibility."),
  /**
   * React-Table cell object.
   *
   * Defaults to **null**.
   */
  cell: PropTypes.object,
  /**
   * Mostly commonly a string, accepts any valid markup.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * The cell may span multiple columns. Note: Only supported in composed tables (ie tables that do not have columns/data and are not virtualized).
   *
   * Defaults to **null**.
   */
  colSpan: PropTypes.number,
  /**
   * Override the default rendering of the cell.
   *
   * Defaults to **null**.
   */
  customRenderer: PropTypes.func,
  /**
   * Used for sticky columns.
   *
   * Defaults to **undefined**.
   */
  fixed: PropTypes.bool,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * The table's layout value, used internally.
   *
   * Defaults to **empty string**.
   */
  layout: PropTypes.string,
  /**
   * Removes certain margins and paddings for better appearance when nesting tables. Used on the parent cell of the nested table.
   *
   * Defaults to **false**.
   */
  nestable: PropTypes.bool,
  /**
   * The cell may span multiple rows. Note: Only supported in composed tables (ie tables that do not have columns/data and are not virtualized).
   *
   * Defaults to **null**.
   */
  rowSpan: PropTypes.number
};
const TableCellDefaultProps = {
  alwaysUseDivTags: false,
  backgroundColor: undefined,
  cell: null,
  children: null,
  className: undefined,
  colSpan: null,
  customRenderer: null,
  fixed: undefined,
  id: undefined,
  layout: "",
  nestable: false,
  rowSpan: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableFooterPropTypes = {
  /**
   * The table will always use div tags instead of standard table tags. Note, disabled when using `layout='standard'`.
   *
   * Defaults to **false**.
   */
  alwaysUseDivTags: PropTypes.bool,
  /**
   * Expects one or more `TableRow` components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Passthrough style object.
   *
   * Defaults to **null**.
   */
  style: PropTypes.object,
  /**
   * Fixed width for table body.
   *
   * Defaults to **null**.
   */
  width: PropTypes.number
};
const TableFooterDefaultProps = {
  alwaysUseDivTags: false,
  children: null,
  className: undefined,
  style: null,
  width: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableHeaderPropTypes = {
  /**
   * The table will always use div tags instead of standard table tags. Note, disabled when using `layout='standard'`.
   *
   * Defaults to **false**.
   */
  alwaysUseDivTags: PropTypes.bool,
  /**
   * Expects one or more `TableRow` components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Passthrough style object.
   *
   * Defaults to **null**.
   */
  style: PropTypes.object,
  /**
   * Fixed width for table body.
   *
   * Defaults to **null**.
   */
  width: PropTypes.number
};
const TableHeaderDefaultProps = {
  alwaysUseDivTags: false,
  children: null,
  className: undefined,
  style: null,
  width: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableHeaderCellPropTypes = {
  /**
   * Optional custom formatter function for `TableHeaderCell` actions.
   *
   * Defaults to **null**.
   */
  actionsRenderer: PropTypes.func,
  /**
   * The table will always use div tags instead of standard table tags. Note, disabled when using `layout='standard'`.
   *
   * Defaults to **false**.
   */
  alwaysUseDivTags: PropTypes.bool,
  /**
   * @deprecated _This prop has been deprecated in favor of `cellProps` in the column schema (see README), which offers more flexibility._
   *
   * Custom background color.
   *
   * Defaults to **undefined**.
   */
  backgroundColor: deprecatedProp(PropTypes.string, "TableHeaderCell", "This prop has been deprecated in favor of `cellProps` in the column schema (see README), which offers more flexibility."),
  /**
   * Mostly commonly a string, accepts any valid markup.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * React-Table column object.
   *
   * Defaults to **null**.
   */
  column: PropTypes.object,
  /**
   * Custom index to be passed to the actionsRenderer.
   *
   * Defaults to **undefined**.
   */
  columnIndex: PropTypes.number,
  /**
   * Used to trigger drag-and-drop functionality.
   *
   * Defaults to **null**.
   */
  columnReordering: PropTypes.bool,
  /**
   * Override the default rendering of the cell.
   *
   * Defaults to **null**.
   */
  customRenderer: PropTypes.func,
  /**
   * Used for sticky columns.
   *
   * Defaults to **undefined**.
   */
  fixed: PropTypes.bool,
  /**
   * Required for column reordering.
   *
   * Defaults to **null**.
   */
  id: PropTypes.string,
  /**
   * The table's layout value, used internally.
   *
   * Defaults to **empty string**.
   */
  layout: PropTypes.string,
  /**
   * Fired with the user clicks on the cell.
   *
   * Defaults to **null**.
   */
  onClick: PropTypes.func,
  /**
   * Enabled resizable column indicator.
   *
   * Defaults to **null**.
   */
  resizableColumns: PropTypes.bool,
  /**
   * Enables the sort indicator to be hidden when the mouse is not hovering.
   *
   * Defaults to **null**.
   */
  sortIndicatorOnHover: PropTypes.bool,
  /**
   * Will enable sorting events and apply a sortable indicator to the column.
   *
   * Defaults to **false**.
   */
  sortable: PropTypes.bool,
  /**
   * Passthrough style object.
   *
   * Defaults to **null**.
   */
  style: PropTypes.object
};
const TableHeaderCellDefaultProps = {
  actionsRenderer: null,
  alwaysUseDivTags: false,
  backgroundColor: undefined,
  children: null,
  className: undefined,
  column: null,
  columnIndex: undefined,
  columnReordering: null,
  customRenderer: null,
  fixed: undefined,
  id: null,
  layout: "",
  resizableColumns: null,
  sortIndicatorOnHover: null,
  sortable: false,
  style: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableHeaderRowPropTypes = {
  /**
   * The table will always use div tags instead of standard table tags. Note, disabled when using `layout='standard'`.
   *
   * Defaults to **false**.
   */
  alwaysUseDivTags: PropTypes.bool,
  /**
   * Expects one or more `TableRow` components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string
};
const TableHeaderRowDefaultProps = {
  alwaysUseDivTags: false,
  children: null,
  className: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableNoContentPropTypes = {
  /**
   * Accepts any valid markup.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Wraps the output in a table row and cell. For use within a table.
   *
   * Defaults to **false**.
   */
  includeTableMarkup: PropTypes.bool
};
const TableNoContentDefaultProps = {
  children: null,
  className: undefined,
  includeTableMarkup: false
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableRowPropTypes = {
  /**
   * The table will always use div tags instead of standard table tags. Note, disabled when using `layout='standard'`.
   *
   * Defaults to **false**.
   */
  alwaysUseDivTags: PropTypes.bool,
  /**
   * Expects one or more `TableRow` components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string
};
const TableRowDefaultProps = {
  alwaysUseDivTags: false,
  children: null,
  className: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableSortIndicatorPropTypes = {
  /**
   * React-Table column object.
   *
   * Defaults to **null**.
   */
  column: PropTypes.object,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string
};
const TableSortIndicatorDefaultProps = {
  column: null,
  id: undefined
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableTopBarPropTypes = {
  /**
   * Expects a component such as a button or search bar, but will accept any valid markup.
   *
   * Defaults to **null**.
   */
  actions: PropTypes.node,
  /**
   * Expects a FilterBar component, but will accept any valid markup.
   *
   * Defaults to **null**.
   */
  filterBar: PropTypes.node,
  /**
   * @deprecated _May be removed pending further review._
   *
   * Adds additional emphasis and padding.
   *
   * Defaults to **undefined**.
   */
  prominent: deprecatedProp(PropTypes.bool, "TableTopBar", "May be removed pending further review."),
  /**
   * Can be used to add a title to the table.
   *
   * Defaults to **null**.
   */
  title: PropTypes.string
};
const TableTopBarDefaultProps = {
  actions: null,
  filterBar: null,
  prominent: undefined,
  title: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TableVerticalResizeHandlePropTypes = {
  /**
   * The composed table elements. Expects one each of TableHeader, TableBody.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * React-Table column object.
   *
   * Defaults to **null**.
   */
  column: PropTypes.object
};
const TableVerticalResizeHandleDefaultProps = {
  children: null,
  className: undefined,
  column: null
};

const TableNoContent = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    includeTableMarkup,
    ...customProps
  } = props;
  const content = /*#__PURE__*/React.createElement("div", _extends({
    ref: externalRef,
    className: clsx('lmnt-table__no-content', className)
  }, customProps), children);
  return includeTableMarkup ? /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("td", null, content)) : content;
});
TableNoContent.displayName = 'TableNoContent';
TableNoContent.propTypes = TableNoContentPropTypes;
TableNoContent.defaultProps = TableNoContentDefaultProps;

const TableBase = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alwaysUseDivTags,
    fixedColumns,
    ariaLabel,
    children,
    className,
    columnStriped,
    cellProps,
    containerProps,
    defaultColumn,
    dense,
    fixedHeader,
    fullWidth,
    headerCellProps,
    headerDividerTall,
    headerDividerThemeColor,
    headerRowProps,
    headerThemeColor,
    // height,
    hideHorizontalScrollbar,
    layout,
    leadingContent,
    nested,
    noContentIncludeTable,
    noContentMessage,
    noHover,
    noInit,
    rowProps,
    rowStriped,
    style,
    trailingContent,
    virtualized,
    width,
    ...customProps
  } = props || {};
  const mdcDataTable = useRef();
  const tableRef = useRef();
  const hasContent = !!children;
  useImperativeHandle(externalRef, () => tableRef.current, []);
  useEffect(() => {
    if (hasContent && !noInit && !virtualized && !alwaysUseDivTags && !mdcDataTable.current) {
      try {
        mdcDataTable.current = MDCDataTable.attachTo(tableRef.current);
      } catch (e) {
        edsWarning(`Error rendering table: "${e.message}". This most likely means that the table contents were empty`);
      }
    }
    return () => {
      if (mdcDataTable.current) {
        mdcDataTable.current.destroy();
      }
    };
    // This is to prevent it from making noContent a dependency, which will cause an infinite loop. Eslint isn't always smart.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [mdcDataTable, tableRef, virtualized, alwaysUseDivTags]);
  const classes = clsx('lmnt', 'mdc-data-table', 'lmnt-table', virtualized && 'lmnt-table--virtualized', rowStriped && 'lmnt-table__table--row-striped', columnStriped && 'lmnt-table__table--column-striped', fixedHeader && 'mdc-data-table--sticky-header', dense && 'lmnt-table--dense', noHover && 'lmnt-table--no-hover', headerThemeColor === 'neutral' && 'lmnt-table__header-theme--neutral', headerThemeColor === 'primary' && 'lmnt-table__header-theme--primary', headerThemeColor === 'secondary' && 'lmnt-table__header-theme--secondary', headerThemeColor === 'primary-variant' && 'lmnt-table__header-theme--primary-variant', headerThemeColor === 'secondary-variant' && 'lmnt-table__header-theme--secondary-variant', !headerThemeColor && headerDividerThemeColor === 'primary' && 'lmnt-table__header-divider--primary', !headerThemeColor && headerDividerThemeColor === 'secondary' && 'lmnt-table__header-divider--secondary', !headerThemeColor && headerDividerThemeColor === 'primary-variant' && 'lmnt-table__header-divider--primary-variant', !headerThemeColor && headerDividerThemeColor === 'secondary-variant' && 'lmnt-table__header-divider--secondary-variant', headerDividerTall && 'lmnt-table__header-divider--tall', nested && 'lmnt-table--nested', !width && fullWidth && 'lmnt-table--full-width', width && 'lmnt-table--fixed-width', hideHorizontalScrollbar && 'lmnt-table__hide-horizontal-scrollbar', className);
  const styles = {
    ...style
  };
  if (width) styles.width = `${width}px`;
  // BUG: does not work as intended
  // if (height) styles.height = `${height}px`;

  const content = useMemo(() => hasContent ? children : /*#__PURE__*/React.createElement(TableNoContent, null, noContentMessage), [children, noContentMessage, hasContent]);
  const TableTag = alwaysUseDivTags ? 'div' : 'table';
  return /*#__PURE__*/React.createElement("div", _extends({
    className: classes,
    ref: tableRef,
    style: styles
  }, customProps), leadingContent, /*#__PURE__*/React.createElement("div", _extends({
    className: clsx('mdc-data-table__table-container', 'lmnt-data-table__container'
    // (fullWidth || layout === 'flex') &&
    //     'lmnt-data-table--flex-overflow'
    )
  }, containerProps), /*#__PURE__*/React.createElement(TableTag, {
    className: clsx('mdc-data-table__table', 'lmnt-table__table', fixedHeader && layout === 'block' && 'lmnt-table__block-fixed-header', fixedHeader && layout === 'flex' && 'lmnt-table__flex-fixed-header'),
    "aria-label": ariaLabel
  }, content)), trailingContent);
});
TableBase.displayName = 'TableBase';

const scrollbarWidthCalculator = () => {
  // thanks too https://davidwalsh.name/detect-scrollbar-width
  const scrollDiv = document.createElement('div');
  scrollDiv.setAttribute('style', 'width: 100px; height: 100px; overflow: scroll; position:absolute; top:-9999px;');
  document.body.appendChild(scrollDiv);
  const finalScrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return finalScrollbarWidth;
};
const formatIntrinsicValue = value => {
  if (!value && value !== 0) return null;
  if (typeof value === 'object') {
    if (value instanceof Date) return value.toLocaleDateString();
    if ( /*#__PURE__*/React.isValidElement(value)) return value;
    // make a reasonable attempt at getting a display value by trying some common props. We could use the `value?.label || value?.text` format, but lets be formal about it for now.
    if (Object.prototype.hasOwnProperty.call(value, 'label')) return value.label;
    if (Object.prototype.hasOwnProperty.call(value, 'text')) return value.text;
    if (Object.prototype.hasOwnProperty.call(value, 'display')) return value.display;
    if (Object.prototype.hasOwnProperty.call(value, 'displayValue')) return value.displayValue;
    if (Object.prototype.hasOwnProperty.call(value, 'displayLabel')) return value.displayLabel;
    if (Object.prototype.hasOwnProperty.call(value, 'value')) return value.value;
    // this will look bad, but we don't have much choice
  }

  return String(value);
};
const formatCurrency = (value, _ref) => {
  let {
    country = 'en-US',
    currency = 'USD',
    maximumSignificantDigits
  } = _ref;
  return new Intl.NumberFormat(country, {
    style: 'currency',
    currency,
    maximumSignificantDigits
  }).format(value);
};
const formatCellValue = props => {
  var _Date, _Date$toLocaleDateStr, _Date2, _Date2$toLocaleTimeSt, _Date3, _Date3$toLocaleString, _cells$, _cells$$row, _cells$2, _cells$2$row;
  const {
    accessor,
    row,
    onCellUpdate,
    cell,
    cell: {
      value,
      column: {
        cellTemplate,
        displayConfig,
        displayTemplate,
        displayType,
        editable
      }
    }
  } = props;

  // if they want to use the react-table syntax

  const {
    cells,
    id: rowId
  } = row;

  // automatically override display type when a template is passed in
  const displayTypeActual = cellTemplate || displayTemplate ? 'custom' : displayType;

  // if (value === null || value === undefined) return '';

  if (!displayTypeActual) return formatIntrinsicValue(value);
  if (displayTypeActual.indexOf('currency') > -1) return formatCurrency(value, displayTypeActual);
  switch (displayTypeActual) {
    case 'text':
      return String(value);
    case 'percentage':
      return `${value}%`;
    case 'date':
      return (_Date = new Date(value)) === null || _Date === void 0 ? void 0 : (_Date$toLocaleDateStr = _Date.toLocaleDateString) === null || _Date$toLocaleDateStr === void 0 ? void 0 : _Date$toLocaleDateStr.call(_Date);
    case 'time':
      return (_Date2 = new Date(value)) === null || _Date2 === void 0 ? void 0 : (_Date2$toLocaleTimeSt = _Date2.toLocaleTimeString) === null || _Date2$toLocaleTimeSt === void 0 ? void 0 : _Date2$toLocaleTimeSt.call(_Date2);
    case 'datetime':
      return (_Date3 = new Date(value)) === null || _Date3 === void 0 ? void 0 : (_Date3$toLocaleString = _Date3.toLocaleString) === null || _Date3$toLocaleString === void 0 ? void 0 : _Date3$toLocaleString.call(_Date3);
    case 'currency':
      return formatCurrency(value, displayConfig);
    case 'checkbox':
      return /*#__PURE__*/React.createElement(Checkbox, {
        dense: true,
        checked: value,
        onChange: onCellUpdate(accessor, rowId)
      });
    case 'switch':
      return /*#__PURE__*/React.createElement(Switch, {
        dense: true,
        checked: value,
        onChange: onCellUpdate(accessor, rowId)
      });
    case 'custom':
      if (cellTemplate) return cellTemplate({
        cell,
        editable,
        onCellUpdate,
        row,
        value
      });

      // TODO: deprecated, remove in v6!
      if (displayTemplate) return displayTemplate(value, cells === null || cells === void 0 ? void 0 : (_cells$ = cells[0]) === null || _cells$ === void 0 ? void 0 : (_cells$$row = _cells$.row) === null || _cells$$row === void 0 ? void 0 : _cells$$row.original, cells === null || cells === void 0 ? void 0 : (_cells$2 = cells[0]) === null || _cells$2 === void 0 ? void 0 : (_cells$2$row = _cells$2.row) === null || _cells$2$row === void 0 ? void 0 : _cells$2$row.id, editable, onCellUpdate, row);
      return value;
    default:
      return value;
  }
};
const formatCellEditor = props => {
  var _rowData$, _rowData$$row, _rowData$2, _rowData$2$row;
  const {
    accessor,
    onCellUpdate,
    row,
    onControlBlur,
    setEditedValue,
    editedValue,
    cell: {
      value,
      column: {
        editType,
        editConfig,
        editTemplate
      }
    }
  } = props;
  const valueActual = editedValue || value;
  const rowData = row.cells;
  const variant = (editConfig === null || editConfig === void 0 ? void 0 : editConfig.variant) || 'outlined';
  const handleUpdate = onCellUpdate === null || onCellUpdate === void 0 ? void 0 : onCellUpdate(accessor, row, setEditedValue);
  const sharedProps = {
    dense: true,
    onChange: handleUpdate,
    onBlur: onControlBlur
  };
  switch (editType) {
    case 'checkbox':
      return /*#__PURE__*/React.createElement(Checkbox, _extends({
        checked: valueActual
      }, sharedProps));
    case 'switch':
      return /*#__PURE__*/React.createElement(Switch, _extends({
        checked: valueActual
      }, sharedProps));
    case 'datepicker':
      return /*#__PURE__*/React.createElement(Datepicker, _extends({
        variant: variant,
        value: valueActual
      }, sharedProps));
    case 'number':
      return /*#__PURE__*/React.createElement(Textfield, _extends({
        variant: variant,
        value: valueActual,
        type: "number"
      }, sharedProps));
    case 'custom':
      return editTemplate === null || editTemplate === void 0 ? void 0 : editTemplate(valueActual, rowData === null || rowData === void 0 ? void 0 : (_rowData$ = rowData[0]) === null || _rowData$ === void 0 ? void 0 : (_rowData$$row = _rowData$.row) === null || _rowData$$row === void 0 ? void 0 : _rowData$$row.original, rowData === null || rowData === void 0 ? void 0 : (_rowData$2 = rowData[0]) === null || _rowData$2 === void 0 ? void 0 : (_rowData$2$row = _rowData$2.row) === null || _rowData$2$row === void 0 ? void 0 : _rowData$2$row.id, onCellUpdate, onControlBlur);
    case 'text':
    case 'textfield':
    default:
      return /*#__PURE__*/React.createElement(Textfield, _extends({
        variant: variant,
        value: valueActual
      }, sharedProps));
  }
};
const formatEditor = (accessor, onCellUpdate) => props => !props.cell.column.editable ? formatCellValue(props) : formatCellEditor({
  ...props,
  ...accessor,
  ...onCellUpdate
});
const formatCell = (accessor, onCellUpdate) => props => formatCellValue({
  ...props,
  ...onCellUpdate,
  accessor
});
const formatColumns = (columns, onCellUpdate) => {
  if (!columns) return [];
  return columns.map(column => {
    const {
      headerTemplate
    } = column;
    const temp = {
      ...column,
      Cell: formatCell(column.accessor, onCellUpdate),
      Editor: formatEditor(column.accessor, onCellUpdate),
      // Make sure we always have an id, if the user didn't pass one in
      id: column.id || edsRandomId()
    };
    if (headerTemplate) temp.Header = headerTemplate;
    // recursion to catch grouped columns
    if (column.columns) temp.columns = formatColumns(column.columns, onCellUpdate);
    return temp;
  });
};
const getBackgroundColor = column => {
  if (!column) return null;
  let cursor = column;
  let bgColor = '';
  while (cursor) {
    if (cursor.backgroundColor) {
      bgColor = cursor.backgroundColor;
      break;
    }
    cursor = cursor.parent;
  }
  return bgColor;
};
const callProps = (propsToCall, args) => typeof propsToCall === 'function' ? propsToCall(...args) : propsToCall;
const createProps = (globalProps, localProps, args) => ({
  ...callProps(globalProps, args),
  ...callProps(localProps, args)
});
const getCombinedProps = (props, customProps, getTableProps) => {
  const combinedStyles = {
    ...props.style
  };
  if (props.height && !props.virtualized) combinedStyles.height = `${props.height}px`;
  return getTableProps === null || getTableProps === void 0 ? void 0 : getTableProps({
    ariaLabel: props.ariaLabel,
    className: props.className,
    columnStriped: props.columnStriped,
    containerProps: props.containerProps,
    dense: props.dense,
    fixedHeader: props.fixedHeader,
    fullWidth: props.fullWidth,
    headerDividerTall: props.headerDividerTall,
    headerDividerThemeColor: props.headerDividerThemeColor,
    headerThemeColor: props.headerThemeColor,
    layout: props.layout,
    leadingContent: props.topBar || props.leadingContent,
    nested: props.nested,
    noContentIncludeTable: props.noContentIncludeTable,
    noContentMessage: props.noContentMessage,
    noHover: props.noHover,
    rowStriped: props.rowStriped,
    style: combinedStyles,
    virtualized: props.virtualized,
    width: props.width,
    ...customProps
  });
};
const getInitialState = columns => {
  const sorting = sortBy(columns.reduce((out, c, i) => {
    if (c.defaultSort) {
      out.push({
        id: c.id,
        desc: c.defaultSort === 'desc' || c.defaultSort === 'descending',
        order: c.defaultSortOrder || i
      });
    }
    return out;
  }, []), 'order');
  return {
    sortBy: sorting
  };
};
const getColumnAlignment = column => {
  switch (column === null || column === void 0 ? void 0 : column.align) {
    case 'left':
      return {
        justifyContent: 'flex-start'
      };
    case 'right':
      return {
        justifyContent: 'flex-end'
      };
    case 'center':
      return {
        justifyContent: 'center'
      };
    default:
      return null;
  }
};
const getContextRootProp = (context, prop, defaultValue) => {
  if (!context || !context.rootProps) return undefined;
  const val = context.rootProps[prop];
  return val !== undefined ? val : defaultValue;
};

const ReactTableManager = props => {
  const {
    canUnSort,
    columnReordering,
    data,
    // TODO: this is broken in the current version (and never fully worked). I intend to fix it sometime in the future, so I'm leaving this zombie code for now.
    // defaultColumn,
    disableMultiSort,
    expandable,
    initialState,
    layout,
    paginated,
    resizableColumns,
    sortable,
    columns,
    virtualized
  } = props;
  const plugins = useMemo(() => {
    const list = [];
    if (sortable) list.push(useSortBy);
    if (paginated === true || paginated === 'standard') list.push(usePagination);
    if (layout === 'block') list.push(useBlockLayout);

    // TODO: this logic will change in v6 to not use react-table if layout is empty
    if (!layout && (resizableColumns || virtualized || columnReordering)) {
      list.push(useBlockLayout);
    }
    if (resizableColumns) list.push(useResizeColumns);
    if (layout === 'flex') list.push(useFlexLayout);
    if (layout === 'absolute') list.push(useAbsoluteLayout);
    if (expandable) list.push(useExpanded);
    return list;
  }, [columnReordering, expandable, layout, paginated, resizableColumns, sortable, virtualized]);
  const tableProps = useTable({
    columns,
    data,
    // TODO: this is broken in the current version (and never fully worked). I intend to fix it sometime in the future, so I'm leaving this zombie code for now.
    // defaultColumn,
    disableMultiSort,
    disableSortRemove: !canUnSort,
    initialState,
    useManualSorting: sortable === 'controlled'
  }, ...plugins);
  const {
    totalColumnsWidth
  } = tableProps;
  const scrollBarSize = scrollbarWidthCalculator();
  const totalWidth = totalColumnsWidth + scrollBarSize;
  return {
    ...tableProps,
    scrollBarSize,
    totalWidth
  };
};

const TableBody = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alwaysUseDivTags,
    children,
    className,
    style,
    width,
    ...customProps
  } = props;
  const styles = {
    ...style
  };
  if (width) styles.width = width;
  const Tag = alwaysUseDivTags ? 'div' : 'tbody';
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('mdc-data-table__content lmnt-table__body', className)
  }, customProps, {
    style: styles
  }), children);
});
TableBody.displayName = 'TableBody';
TableBody.propTypes = TableBodyPropTypes;
TableBody.defaultProps = TableBodyDefaultProps;

const CellRenderer = _ref => {
  let {
    cell,
    children
  } = _ref;
  return cell ? cell.render('Cell', {
    children
  }) : children;
};

const TableContext = /*#__PURE__*/createContext({});

/* eslint-disable react/prop-types */
const TableCell = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alwaysUseDivTags,
    backgroundColor,
    cell,
    children,
    className,
    colSpan,
    columnIndex,
    columnWidth,
    // columnWidth is here to shut up warnings, we need to figure out why it's being passed in
    customRenderer,
    fixed,
    id,
    layout,
    nestable,
    rowSpan,
    style,
    ...customProps
  } = props;
  const ref = useRef();
  const [idActual] = useState(id || (cell === null || cell === void 0 ? void 0 : cell.id) || edsRandomId());
  const column = (cell === null || cell === void 0 ? void 0 : cell.column) || {};
  const Tag = alwaysUseDivTags ? 'div' : 'td';
  const fixedActual = fixed || column.fixed;
  const isLeadingFixed = fixedActual === true || fixedActual === 'leading';
  const isTrailingFixed = fixedActual === 'trailing';
  const bgColor = backgroundColor || getBackgroundColor(column);
  const context = useContext(TableContext);
  const fixedWidth = isLeadingFixed && context ? context.state.fixedWidths[columnIndex] : null;
  const fixedOffset = isLeadingFixed && context ? context.state.fixedOffsets[columnIndex] : null;
  const fixedColumnsBorder = getContextRootProp(context, 'fixedColumnsBorder', true);
  const styles = {
    ...style
  };
  if (fixedWidth) {
    styles.width = `${fixedWidth}px`;
    styles.minWidth = `${fixedWidth}px`;
  }
  if (fixedOffset || fixedOffset === 0) styles.left = `${fixedOffset}px`;
  if (bgColor) styles.backgroundColor = bgColor;
  const cellProps = {
    className: clsx('lmnt', 'mdc-data-table__cell', isTrailingFixed && 'lmnt-table__trailing-fixed-cell', isLeadingFixed && 'lmnt-table__leading-fixed-cell', fixedColumnsBorder && 'lmnt-table__leading-fixed-cell--trailing-border', nestable && 'lmnt-table__cell--nestable', className),
    ref,
    id: idActual,
    role: 'gridcell',
    style: styles,
    colSpan,
    rowSpan,
    ...customProps
  };
  useImperativeHandle(externalRef, () => ref.current, []);
  return /*#__PURE__*/React.createElement(Tag, cellProps, /*#__PURE__*/React.createElement("div", {
    className: "lmnt-table__cell-content",
    style: {
      ...getColumnAlignment(column)
    }
  }, /*#__PURE__*/React.createElement(ConditionalWrapper, {
    condition: customRenderer,
    wrapper: customRenderer
  }, /*#__PURE__*/React.createElement(CellRenderer, {
    cell: cell
  }, children))));
});
TableCell.displayName = 'TableCell';
TableCell.propTypes = TableCellPropTypes;
TableCell.defaultProps = TableCellDefaultProps;

const TableRow = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alwaysUseDivTags,
    children,
    className,
    headerGroup,
    // headerGroup is here to shut up warnings, we need to figure out why it's being passed in
    row,
    rowStyle,
    ...customProps
  } = props;
  const Tag = alwaysUseDivTags ? 'div' : 'tr';
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt', 'mdc-data-table__row', 'lmnt-table__row', className),
    role: "row",
    style: rowStyle
  }, customProps), children);
});
TableRow.displayName = 'TableRow';
TableRow.propTypes = TableRowPropTypes;
TableRow.defaultProps = TableRowDefaultProps;

var renderRows = (_ref => {
  let {
    alwaysUseDivTags,
    cellProps,
    expandable,
    expandedRowTemplate,
    initiallyExpanded,
    layout,
    prepareRow,
    rowProps,
    rows,
    visibleColumns
  } = _ref;
  let rowWidth = null;
  return _ref2 => {
    var _rows$;
    let {
      index: rowIndex,
      style: rowStyle
    } = _ref2;
    const row = rows[rowIndex];
    const customRowProps = createProps(rowProps, row.original.rowProps, [row.original, rowIndex]);
    const nestableActual = true;
    prepareRow(row);
    const combinedStyles = {
      ...(customRowProps === null || customRowProps === void 0 ? void 0 : customRowProps.style),
      ...rowStyle
    };

    // HACK: flex layout needs explicit row width
    if (layout === 'flex' && !rowWidth) rowWidth = rows === null || rows === void 0 ? void 0 : (_rows$ = rows[0]) === null || _rows$ === void 0 ? void 0 : _rows$.cells.reduce((sum, r) => sum + r.column.totalWidth, 0);
    if (layout === 'flex' && rowWidth) combinedStyles.width = `${rowWidth}px`;
    const showExpandedContent = expandable && expandedRowTemplate && (row.isExpanded || initiallyExpanded);
    const combinedProps = {
      ...row.getRowProps({
        ...customRowProps,
        row,
        alwaysUseDivTags,
        style: combinedStyles
      })
    };
    // console.log('row props', combinedProps);
    return /*#__PURE__*/React.createElement(Fragment, {
      key: `lmnt-row-${combinedProps.key}`
    }, /*#__PURE__*/React.createElement(TableRow, combinedProps, row.cells.map((cell, columnIndex) => {
      const customCellProps = createProps(cellProps, cell.column.cellProps, [cell]);
      return /*#__PURE__*/React.createElement(TableCell, _extends({
        layout: layout,
        columnIndex: columnIndex
      }, cell.getCellProps({
        ...customCellProps,
        cell,
        alwaysUseDivTags
      })));
    })), showExpandedContent && /*#__PURE__*/React.createElement(TableRow, {
      key: `${combinedProps.key}_expanded`,
      alwaysUseDivTags: alwaysUseDivTags
    }, /*#__PURE__*/React.createElement(TableCell, {
      nestable: nestableActual,
      colSpan: visibleColumns.length,
      alwaysUseDivTags: alwaysUseDivTags
    }, expandedRowTemplate({
      row
    }))));
  };
});

/* eslint-disable react/prop-types */
const TableRowVirtualRenderer = _ref => {
  let {
    children,
    height,
    rowHeight,
    rowCount,
    totalWidth,
    variableHeight,
    width
  } = _ref;
  const VirtualList = variableHeight ? VariableSizeList : FixedSizeList;
  return /*#__PURE__*/React.createElement(VirtualList, {
    height: height,
    itemCount: rowCount,
    itemSize: rowHeight,
    width: width || totalWidth
  }, children);
};

const TableRowRenderer = _ref => {
  let {
    children,
    rowCount
  } = _ref;
  const arr = [];
  for (let index = 0; index < rowCount; index += 1) {
    // HACK: convert children to match what react-window sends to it's renderer.
    // TODO: find a better pattern for this
    arr.push(children({
      index
    }));
  }
  return arr;
};

const defaultHeight = 500;
var TableBodyRenderer = (_ref => {
  let {
    alwaysUseDivTags,
    tableProps,
    rtProps,
    hasData,
    rows
  } = _ref;
  const {
    cellProps,
    columns,
    expandable,
    expandedRowTemplate,
    height,
    initiallyExpanded,
    layout,
    noContentIncludeTable,
    noContentMessage,
    rowHeight,
    rowProps,
    variableHeight,
    virtualized,
    width
  } = tableProps;
  const {
    getTableBodyProps,
    prepareRow,
    totalWidth,
    visibleColumns
  } = rtProps;
  const showNoContent = !hasData && noContentIncludeTable;
  const VirtualList = virtualized ? TableRowVirtualRenderer : TableRowRenderer;
  return /*#__PURE__*/React.createElement(TableBody, _extends({
    alwaysUseDivTags: alwaysUseDivTags
  }, getTableBodyProps === null || getTableBodyProps === void 0 ? void 0 : getTableBodyProps()), showNoContent && /*#__PURE__*/React.createElement(TableRow, null, /*#__PURE__*/React.createElement(TableCell, {
    colSpan: columns === null || columns === void 0 ? void 0 : columns.length
  }, /*#__PURE__*/React.createElement(TableNoContent, null, noContentMessage))), /*#__PURE__*/React.createElement(VirtualList, {
    rowHeight: rowHeight,
    height: height || defaultHeight,
    rowCount: (rows === null || rows === void 0 ? void 0 : rows.length) || 0,
    totalWidth: totalWidth,
    variableHeight: variableHeight,
    virtualized: virtualized,
    width: width
  }, renderRows({
    alwaysUseDivTags,
    cellProps,
    expandable,
    expandedRowTemplate,
    initiallyExpanded,
    layout,
    prepareRow,
    rowProps,
    rows,
    visibleColumns
  })));
});

const TableHeader = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alwaysUseDivTags,
    children,
    className,
    style,
    width,
    ...customProps
  } = props;
  ({
    ...style
  });
  const Tag = alwaysUseDivTags ? 'div' : 'thead';
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt', 'lmnt-table__header', className)
  }, customProps, {
    style: style
  }), children);
});
TableHeader.displayName = 'TableHeader';
TableHeader.propTypes = TableHeaderPropTypes;
TableHeader.defaultProps = TableHeaderDefaultProps;

const TableHeaderRow = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alwaysUseDivTags,
    children,
    className,
    headerGroup,
    // headerGroup is here to shut up warnings, we need to figure out why it's being passed in
    ...customProps
  } = props;
  const Tag = alwaysUseDivTags ? 'div' : 'tr';
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt', 'mdc-data-table__header-row lmnt-table__header-row', className)
  }, customProps), children);
});
TableHeaderRow.displayName = 'TableHeaderRow';
TableHeaderRow.propTypes = TableHeaderRowPropTypes;
TableHeaderRow.defaultProps = TableHeaderRowDefaultProps;

const TableVerticalResizeHandle = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    column,
    children,
    className,
    ...customProps
  } = props;
  if (!column.getResizerProps) return null;
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: externalRef,
    className: clsx('lmnt', 'lmnt-table__resize-handle', className)
  }, column.getResizerProps(), customProps), children);
});
TableVerticalResizeHandle.displayName = 'TableVerticalResizeHandle';
TableVerticalResizeHandle.propTypes = TableVerticalResizeHandlePropTypes;
TableVerticalResizeHandle.defaultProps = TableVerticalResizeHandleDefaultProps;

/* eslint-disable react/prop-types */
const TableSortIndicator = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    column,
    id,
    sortIndicatorOnHover
  } = props;
  const [idActual] = useState(() => id || edsRandomId());
  if (!column) return null;
  const {
    isSorted,
    isSortedDesc
  } = column;
  if (!isSorted) return null;
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("button", {
    ref: externalRef,
    type: "button",
    className: clsx('lmnt', 'mdc-icon-button material-icons mdc-data-table__sort-icon-button', isSorted && !sortIndicatorOnHover && 'lmnt-table__sort-icon-button--visible')

    // aria-label='Sort by dessert'
    // aria-describedby='dessert-status-label'
  }, isSortedDesc ? 'arrow_downward' : 'arrow_upward'), /*#__PURE__*/React.createElement("div", {
    className: "mdc-data-table__sort-status-label",
    "aria-hidden": "true",
    id: idActual
  }));
});
TableSortIndicator.displayName = 'TableSortIndicator';
TableSortIndicator.propTypes = TableSortIndicatorPropTypes;
TableSortIndicator.defaultProps = TableSortIndicatorDefaultProps;

/* eslint-disable react/prop-types */
const DragDropRenderer = props => {
  const {
    id,
    column
  } = props;
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
    isSorting
  } = useSortable({
    id
  });

  // this will probably not work with resizable columns
  const [lineage, setLineage] = useState();
  const dragStyle = {
    cursor: 'pointer',
    transform: CSS.Transform.toString(transform),
    transition
  };

  // Basically this whole lineage thing is a hack until @dnd-kit adds `data` to the options you can pass to onDragEnd()
  useEffect(() => {
    if (!column) return;
    const arr = [];
    let current = column;
    while (current.parent) {
      arr.push(current.parent.id);
      current = current.parent;
    }
    setLineage(arr);
  }, [column]);
  return {
    'data-lineage': lineage,
    setNodeRef,
    dragStyle,
    ...attributes,
    ...listeners,
    transform,
    transition,
    isDragging,
    isSorting
  };
};

const TableHeaderCell = /*#__PURE__*/forwardRef((props, customUserRef) => {
  const {
    actionsRenderer,
    alwaysUseDivTags,
    backgroundColor,
    children,
    className,
    column,
    columnIndex,
    columnReordering,
    columnWidth,
    // columnWidth is here to shut up warnings, we need to figure out why it's being passed in
    customRenderer,
    id,
    fixed,
    layout,
    onClick,
    resizableColumns,
    sortDirection,
    // sortDirection is here to shut up warnings, we need to figure out why it's being passed in
    sortIndicatorOnHover,
    sortable,
    style,
    wrapMode,
    // wrapMode is here to shut up warnings, we need to figure out why it's being passed in
    ...customProps
  } = props;
  const context = useContext(TableContext);
  const contextState = context === null || context === void 0 ? void 0 : context.state;
  const actionsRendererActual = actionsRenderer || (column === null || column === void 0 ? void 0 : column.actionsRenderer);
  const Tag = alwaysUseDivTags ? 'div' : 'th';
  const [bgColor, setBgColor] = useState(backgroundColor);
  const fixedActual = fixed || (column === null || column === void 0 ? void 0 : column.fixed);
  const isLeadingFixed = fixedActual === true || fixedActual === 'leading';
  const isTrailingFixed = fixedActual === 'trailing';
  const fixedColumnsBorder = getContextRootProp(context, 'fixedColumnsBorder', true);
  const virtualized = getContextRootProp(context, 'virtualized', false);
  const {
    setNodeRef: columnSortingRef,
    dragStyle,
    isDragging,
    isSorting,
    boxSizing,
    ...columnReorderProps
  } = columnReordering ? DragDropRenderer({
    id,
    column
  }) : {};
  const ref = useRef(columnSortingRef || customUserRef);
  const [fixedOffset, setFixedOffset] = useState(isLeadingFixed && layout !== 'standard' && column ? column.totalLeft : null);
  const [fixedWidth, setFixedWidth] = useState();
  useEffect(() => {
    if (!isLeadingFixed) return;
    const th = ref.current;
    if (virtualized) setFixedWidth(th.getBoundingClientRect().width);
    if (layout !== 'standard' && !fixed) return;
    let sibling = th.previousSibling;
    let totalLeft = 0;
    while (sibling) {
      totalLeft += sibling.getBoundingClientRect().width;
      sibling = sibling.previousSibling;
    }
    // console.log('>>>>', totalLeft);
    setFixedOffset(totalLeft);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isLeadingFixed, layout]);
  useEffect(() => {
    if (!contextState || !isLeadingFixed || fixedOffset === null || fixedOffset === undefined) return;
    const existing = contextState.fixedOffsets[columnIndex];
    if (existing || existing === 0) return;
    contextState.fixedOffsets = curr => {
      const updated = [...curr];
      updated[columnIndex] = fixedOffset;
      return updated;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fixedOffset]);
  useEffect(() => {
    if (!contextState || !isLeadingFixed || fixedWidth === null || fixedWidth === undefined) return;
    const existing = contextState.fixedWidths[columnIndex];
    if (existing || existing === 0) return;
    contextState.fixedWidths = curr => {
      const updated = [...curr];
      updated[columnIndex] = fixedWidth;
      return updated;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fixedWidth]);
  let styles = {
    ...style
  };
  if (fixedWidth) {
    styles.width = `${fixedWidth}px`;
    styles.minWidth = `${fixedWidth}px`;
  }
  if (fixedOffset || fixedOffset === 0) styles.left = `${fixedOffset}px`;
  if (bgColor) styles.backgroundColor = bgColor;
  if (dragStyle) styles = {
    ...styles,
    ...dragStyle
  };
  if (onClick || column !== null && column !== void 0 && column.onClick) styles.cursor = 'pointer';
  if (bgColor) styles.backgroundColor = bgColor;
  const finalProps = {
    ...columnReorderProps,
    ...customProps,
    style: styles
  };
  useEffect(() => {
    if (backgroundColor || !column) return;
    const bg = getBackgroundColor(column);
    if (bg) {
      setBgColor(bg);
    }
  }, [backgroundColor, column]);
  useEffect(() => {
    // Manually pass reference into the columnSortingRef
    columnSortingRef && columnSortingRef(ref.current);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const Content = useMemo(() => () => {
    const content = column ? /*#__PURE__*/React.createElement(React.Fragment, null, column.header ? column.render('header') : column.render('Header'), children) : children;
    return customRenderer && customRenderer(content) || content;
  }, [column, customRenderer, children]);
  const Actions = useMemo(() => () => {
    const actions = /*#__PURE__*/React.createElement(React.Fragment, null, (sortable || (column === null || column === void 0 ? void 0 : column.sortable)) && /*#__PURE__*/React.createElement(TableSortIndicator, {
      sortIndicatorOnHover: sortIndicatorOnHover,
      column: column
    }), resizableColumns && /*#__PURE__*/React.createElement(TableVerticalResizeHandle, {
      column: column
    }));
    return actionsRendererActual && actionsRendererActual(actions, columnIndex) || actions;
  }, [actionsRendererActual, column, columnIndex, resizableColumns, sortIndicatorOnHover, sortable]);
  const handleColumnClick = useCallback(event => {
    var _column$onClick;
    onClick === null || onClick === void 0 ? void 0 : onClick(event);
    column === null || column === void 0 ? void 0 : (_column$onClick = column.onClick) === null || _column$onClick === void 0 ? void 0 : _column$onClick.call(column, event, column);
  }, [column, onClick]);
  return /*#__PURE__*/React.createElement(Tag, _extends({
    className: clsx('lmnt', 'mdc-data-table__header-cell', 'lmnt-table__header-cell', isTrailingFixed && 'lmnt-table__trailing-fixed-cell', isLeadingFixed && 'lmnt-table__leading-fixed-cell', fixedColumnsBorder && 'lmnt-table__leading-fixed-cell--trailing-border', isDragging && 'lmnt-table__header-cell--dragging', isSorting && 'lmnt-table__header-cell--sorting', className),
    ref: ref,
    id: id || (column === null || column === void 0 ? void 0 : column.id),
    role: "columnheader",
    scope: "col",
    onClick: handleColumnClick
  }, finalProps), /*#__PURE__*/React.createElement("div", {
    className: "lmnt-table__cell-content",
    style: getColumnAlignment(column)
  }, /*#__PURE__*/React.createElement(Content, null), /*#__PURE__*/React.createElement(Actions, null)));
});
TableHeaderCell.displayName = 'TableHeaderCell';
TableHeaderCell.propTypes = TableHeaderCellPropTypes;
TableHeaderCell.defaultProps = TableHeaderCellDefaultProps;

/* eslint-disable react/prop-types */
const ColumnDndSorter = props => {
  const {
    children,
    onUpdate,
    itemIds
  } = props;
  const sensors = useSensors(useSensor(PointerSensor), useSensor(MouseSensor), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));
  const handleHeaderDragEnd = event => {
    const {
      active,
      over
    } = event;
    if (active.id === over.id) return;
    const activeEl = document.getElementById(active.id);
    const overEl = document.getElementById(over.id);
    if (!activeEl || !overEl) return;
    const activeLineage = activeEl.dataset.lineage;
    const overLineage = overEl.dataset.lineage;

    // For right now, do not allow users to drag across header groups
    if (activeLineage !== overLineage) return;
    const lineage = activeLineage ? activeLineage.split(',').reverse() : [];
    const matchFilter = id => item => item.id === id;
    onUpdate(freshColumns => {
      const arr = [...freshColumns];
      let cursor = arr;
      lineage.forEach(l => {
        const index = cursor.findIndex(c => c.id === l);
        cursor = cursor[index].columns;
      });
      const oldIndex = cursor.findIndex(matchFilter(active.id));
      const newIndex = cursor.findIndex(matchFilter(over.id));

      // because we could be arbitrarily deep here, we need to mutate the array, otherwise we could never put it back together
      cursor.splice(newIndex < 0 ? cursor.length + newIndex : newIndex, 0, cursor.splice(oldIndex, 1)[0]);
      return arr;
    });
  };
  return /*#__PURE__*/React.createElement(DndContext, {
    sensors: sensors,
    collisionDetection: closestCenter,
    onDragEnd: handleHeaderDragEnd
  }, /*#__PURE__*/React.createElement(SortableContext, {
    items: itemIds,
    strategy: horizontalListSortingStrategy
  }, children));
};

/* eslint-disable react/prop-types */
const SpecialContextContainer = props => {
  const {
    columnSorting,
    children
  } = props;
  const ColumnSortContext = useMemo(() =>
  // eslint-disable-next-line react/no-unstable-nested-components
  _ref => {
    let {
      headerGroup,
      onColumnSort,
      columnReordering
    } = _ref;
    return columnReordering ? /*#__PURE__*/React.createElement(ColumnDndSorter, {
      onUpdate: onColumnSort,
      itemIds: headerGroup.headers.map(h => h.id)
    }, children) : children;
  }, [children]);
  return columnSorting && /*#__PURE__*/React.createElement(ColumnSortContext, columnSorting);
};

var TableHeaderRenderer = (_ref => {
  let {
    alwaysUseDivTags,
    canReorderColumns,
    rtProps,
    setSortedColumns,
    tableProps
  } = _ref;
  const {
    headerCellProps,
    headerRowProps,
    layout,
    resizableColumns,
    sortIndicatorOnHover,
    sortable,
    width
  } = tableProps;
  const {
    headerGroups
  } = rtProps;
  return /*#__PURE__*/React.createElement(TableHeader, {
    alwaysUseDivTags: alwaysUseDivTags,
    width: width
  }, headerGroups === null || headerGroups === void 0 ? void 0 : headerGroups.map((headerGroup, headerGroupIndex) => {
    const customHeaderRowProps = createProps(headerRowProps, null, [(headerGroupIndex)]);
    return /*#__PURE__*/React.createElement(SpecialContextContainer, {
      key: headerGroup.id || headerGroupIndex,
      columnSorting: {
        columnReordering: canReorderColumns,
        headerGroup,
        onColumnSort: setSortedColumns
      }
    }, /*#__PURE__*/React.createElement(TableHeaderRow, headerGroup.getHeaderGroupProps({
      ...customHeaderRowProps,
      alwaysUseDivTags,
      headerGroup
    }), headerGroup.headers.map((column, columnIndex) => {
      var _column$getSortByTogg;
      const customHeaderCellProps = createProps(headerCellProps, column.headerCellProps, [column]);
      return /*#__PURE__*/React.createElement(TableHeaderCell, _extends({
        sortIndicatorOnHover: sortIndicatorOnHover,
        layout: layout
      }, column.getHeaderProps({
        ...customHeaderCellProps,
        ...(sortable ? column === null || column === void 0 ? void 0 : (_column$getSortByTogg = column.getSortByToggleProps) === null || _column$getSortByTogg === void 0 ? void 0 : _column$getSortByTogg.call(column) : {}),
        // don't mess with `id` Column reordering needs it
        alwaysUseDivTags,
        column,
        columnIndex,
        columnReordering: canReorderColumns,
        id: column.id,
        resizableColumns,
        sortable
      })));
    })));
  }));
});

/* eslint-disable react/prop-types */
var PaginationRenderer = (_ref => {
  let {
    tableProps,
    rtProps
  } = _ref;
  const {
    paginated,
    disabled
  } = tableProps;
  const {
    state,
    pageCount,
    rows,
    pageSize = 0,
    gotoPage,
    setPageSize
  } = rtProps;
  const currentPage = ((state === null || state === void 0 ? void 0 : state.pageIndex) || 0) + 1;
  const totalItems = (rows === null || rows === void 0 ? void 0 : rows.length) || 0;
  const handleOnPageChange = newPage => {
    gotoPage(newPage - 1);
  };
  const handleOnItemsPerPageChange = newPageSize => {
    setPageSize(newPageSize);
    gotoPage(0);
  };
  return paginated && /*#__PURE__*/React.createElement(Pagination, {
    controlled: true,
    disabled: disabled,
    totalPages: pageCount,
    currentPage: currentPage,
    totalItems: totalItems,
    onPageChange: handleOnPageChange,
    itemsPerPage: pageSize,
    onItemsPerPageChange: handleOnItemsPerPageChange
  });
});

// Maximum curry.
const handleCellUpdate = onCellUpdateLocal => (accessor, row, setEditedValue) => e => {
  setEditedValue === null || setEditedValue === void 0 ? void 0 : setEditedValue(e.target.value);
  onCellUpdateLocal === null || onCellUpdateLocal === void 0 ? void 0 : onCellUpdateLocal(e.target.value, accessor, row.id, row.original, e);
};
const TableBuilder = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    // Note: keeping unused props here to keep react from throwing "unused
    // props" warning
    alwaysUseDivTags,
    ariaLabel,
    canUnSort,
    cellProps,
    children,
    className,
    columnReordering,
    columnStriped,
    columns = [],
    // protects against null columns
    containerProps,
    data,
    dense,
    disableMultiSort,
    disabled,
    expandable,
    expandedRowTemplate,
    fixedHeader,
    footerContent,
    fullWidth,
    headerCellProps,
    headerContent,
    headerDividerTall,
    headerDividerThemeColor,
    headerRowProps,
    headerThemeColor,
    height,
    hiddenColumns,
    initiallyExpanded,
    layout,
    leadingContent,
    nested,
    noContentIncludeTable,
    noContentMessage,
    noHover,
    onCellUpdate,
    onStateChange,
    onWidthChange,
    paginated,
    resizableColumns,
    rowHeight,
    rowProps,
    rowStriped,
    sortIndicatorOnHover,
    sortable,
    style,
    topBar,
    trailingContent,
    variableHeight,
    virtualized,
    width,
    ...customProps
  } = props;
  const tableRef = useRef();
  const hasFixedColumns = useMemo(() => columns.some(x => x.fixed), [columns]);
  const formattedColumns = useMemo(() => formatColumns(columns, handleCellUpdate(onCellUpdate)),
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [columns, onCellUpdate]);
  const [sortedColumns, setSortedColumns] = useState(formattedColumns);
  const canReorderColumns = columnReordering && !hasFixedColumns;
  const initialState = getInitialState(columns);
  const hasData = (data === null || data === void 0 ? void 0 : data.length) > 0 && (sortedColumns === null || sortedColumns === void 0 ? void 0 : sortedColumns.length) > 0;
  const rtProps = ReactTableManager({
    canUnSort,
    columnReordering: canReorderColumns,
    data,
    disableMultiSort,
    expandable,
    initialState,
    layout,
    paginated,
    resizableColumns,
    sortable,
    columns: sortedColumns,
    virtualized
  });
  const {
    clearSortBy,
    getTableProps,
    page,
    resetResizing,
    rows,
    setHiddenColumns,
    state: rtState,
    toggleAllRowsExpanded
  } = rtProps;
  const alwaysUseDivTagsActual = alwaysUseDivTags && layout !== 'standard' || virtualized || layout === 'absolute';

  // TODO: is there a cleaner way to do this?
  const [expanded, setExpanded] = useState(false);
  useEffect(() => {
    if (!expandable || !initiallyExpanded || expanded) return;
    setExpanded(true);
    toggleAllRowsExpanded();
  }, [expandable, expanded, initiallyExpanded, toggleAllRowsExpanded]);
  useImperativeHandle(externalRef, () => ({
    resetResizing,
    clearSortBy,
    table: tableRef.current
  }), [resetResizing, clearSortBy]);
  useEffect(() => {
    if (formattedColumns) setSortedColumns(formattedColumns);
  }, [formattedColumns]);
  useEffect(() => {
    if (virtualized && !height) edsWarning$1('Element Table: Height must be defined when using `virtualized`. A default height of 500 has been set.');
  }, [virtualized, height]);
  useEffect(() => {
    if (!hiddenColumns) return;
    setHiddenColumns(hiddenColumns);
  }, [hiddenColumns, setHiddenColumns]);
  const rowsActual = paginated ? page : rows;
  useImperativeHandle(externalRef, () => ({
    resetResizing,
    clearSortBy,
    table: tableRef.current
  }), [resetResizing, clearSortBy]);
  useEffect(() => {
    onStateChange && onStateChange(rtState);
  }, [onStateChange, rtState]);
  useEffect(() => {
    // link header and body scrolling together
    const body = tableRef.current.querySelector('.lmnt-table__body');
    const header = tableRef.current.querySelector('.lmnt-table__header');

    // HACK: set extra padding for the width of the scrollbar in the header
    header.style.marginRight = `${body.offsetWidth - body.clientWidth}px`;
    const handleScroll = () => {
      header.scrollLeft = body.scrollLeft;
    };
    body.addEventListener('scroll', handleScroll);
  }, []);
  const tableProps = getCombinedProps(props, customProps, getTableProps);
  return /*#__PURE__*/React.createElement(TableBase, _extends({}, tableProps, {
    ref: tableRef,
    noInit: true,
    alwaysUseDivTags: alwaysUseDivTagsActual,
    fixedColumns: hasFixedColumns,
    trailingContent: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(PaginationRenderer, {
      tableProps: props,
      rtProps: rtProps
    }), trailingContent)
  }), headerContent, /*#__PURE__*/React.createElement(TableHeaderRenderer, {
    tableProps: props,
    alwaysUseDivTags: alwaysUseDivTagsActual,
    rtProps: rtProps,
    canReorderColumns: canReorderColumns,
    setSortedColumns: setSortedColumns
  }), /*#__PURE__*/React.createElement(TableBodyRenderer, {
    alwaysUseDivTags: alwaysUseDivTagsActual,
    rowHeight: rowHeight,
    variableHeight: variableHeight,
    tableProps: props,
    rtProps: rtProps,
    hasData: hasData,
    rows: rowsActual
  }), footerContent);
});
TableBuilder.displayName = 'TableBuilder';

// TODO
// - alwaysUseDivs breaks fixed headers
// - fixed columns still broken in virtualized (they are fixed, but horizontal scrolling does not work)
// - height/width does not apply to the correct element when using standard layout

const Table = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alwaysUseDivTags,
    ariaLabel,
    canUnSort,
    children,
    className,
    columnReordering,
    columnStriped,
    columns,
    containerProps,
    data,
    dense,
    disableMultiSort,
    expandable,
    expandedRowTemplate,
    fixedHeader,
    footerContent,
    fullWidth,
    headerContent,
    headerDividerTall,
    headerDividerThemeColor,
    headerThemeColor,
    height,
    hiddenColumns,
    initiallyExpanded,
    layout,
    leadingContent,
    nested,
    noContentIncludeTable,
    noContentMessage,
    noHover,
    onStateChange,
    onWidthChange,
    paginated,
    resizableColumns,
    rowHeight,
    rowStriped,
    sortIndicatorOnHover,
    sortable,
    style,
    topBar,
    trailingContent,
    variableHeight,
    virtualized,
    width,
    ...customProps
  } = props;
  const fixedOffsetsState = useState([]);
  const fixedWidthsState = useState([]);
  const hasData = (data === null || data === void 0 ? void 0 : data.length) > 0 && (columns === null || columns === void 0 ? void 0 : columns.length) > 0;
  if (!hasData && !children && !noContentIncludeTable) return /*#__PURE__*/React.createElement(TableNoContent, {
    ref: externalRef
  }, noContentMessage);
  const commonProps = {
    ariaLabel,
    className,
    columnStriped,
    containerProps,
    dense,
    fixedHeader,
    fullWidth,
    headerDividerTall,
    headerDividerThemeColor,
    headerThemeColor,
    height,
    leadingContent: topBar || leadingContent,
    nested,
    noContentMessage,
    noHover,
    rowStriped,
    style,
    virtualized,
    width
  };
  const contextState = {
    get fixedOffsets() {
      return fixedOffsetsState[0];
    },
    set fixedOffsets(val) {
      fixedOffsetsState[1](val);
    },
    get fixedWidths() {
      return fixedWidthsState[0];
    },
    set fixedWidths(val) {
      fixedWidthsState[1](val);
    }
  };
  if (!data && children) return /*#__PURE__*/React.createElement(TableContext.Provider, {
    // eslint-disable-next-line react/jsx-no-constructed-context-values
    value: {
      customProps,
      rootProps: props,
      state: contextState
    }
  }, /*#__PURE__*/React.createElement(HoistingContext.Provider, {
    value: hoistingEnabled
  }, /*#__PURE__*/React.createElement(TableBase, _extends({
    layout: "standard",
    ref: externalRef,
    trailingContent: trailingContent
  }, commonProps, customProps), children)));
  return /*#__PURE__*/React.createElement(TableContext.Provider, {
    // eslint-disable-next-line react/jsx-no-constructed-context-values
    value: {
      customProps,
      rootProps: props,
      state: contextState
    }
  }, /*#__PURE__*/React.createElement(TableBuilder, _extends({
    ref: externalRef
  }, props)));
});
Table.displayName = 'Table';
Table.propTypes = TablePropTypes;
Table.defaultProps = TableDefaultProps;

const TableFooter = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    alwaysUseDivTags,
    width,
    style,
    ...customProps
  } = props;
  ({
    ...style
  });
  const Tag = alwaysUseDivTags ? 'div' : 'tfoot';
  return /*#__PURE__*/React.createElement(Tag, _extends({
    ref: externalRef,
    className: clsx('lmnt', 'lmnt-table__footer', className)
  }, customProps, {
    style: style
  }), children);
});
TableFooter.displayName = 'TableFooter';
TableFooter.propTypes = TableFooterPropTypes;
TableFooter.defaultProps = TableFooterDefaultProps;

const TableTopBar = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    title,
    actions,
    prominent,
    filterBar,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("header", _extends({
    ref: externalRef,
    className: clsx('lmnt-table__top-bar', prominent && 'lmnt-table__top-bar--prominent', className)
  }, customProps), /*#__PURE__*/React.createElement("section", {
    className: "lmnt-table__top-bar--standard-bar"
  }, /*#__PURE__*/React.createElement("div", {
    className: "lmnt-table__top-bar__title"
  }, /*#__PURE__*/React.createElement(TypoDisplay, {
    level: 6
  }, title)), actions ? /*#__PURE__*/React.createElement("div", {
    className: "lmnt-table__top-bar--standard-bar--action-items"
  }, actions) : null), filterBar && filterBar);
});
TableTopBar.displayName = 'TableTopBar';
TableTopBar.propTypes = TableTopBarPropTypes;
TableTopBar.defaultProps = TableTopBarDefaultProps;

export { Table, TableBase, TableBody, TableBuilder, TableCell, TableFooter, TableHeader, TableHeaderCell, TableHeaderRow, TableNoContent, TableRow, TableSortIndicator, TableTopBar, TableVerticalResizeHandle };
//# sourceMappingURL=index.es.js.map
