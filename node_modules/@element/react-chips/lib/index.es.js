import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { forwardRef, useState, useRef, useImperativeHandle, useEffect, useCallback, useMemo } from 'react';
import clsx from 'clsx';
import { useIsomorphicLayoutEffect } from '@element/react-common';
import { deprecated } from '@material/chips';
import { useMap, useEvent } from 'react-use';
import { Icon } from '@element/react-icon';
import { edsRandomId, edsWarning } from '@element/shared';
import isObjectLike from 'lodash/isObjectLike';
import PropTypes from 'prop-types';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ChipsPropTypes = {
  /**
   * The property on each chip  that represents the id. If one is not provided material will generate an automatic ID.
   *
   * Defaults to **empty string**.
   */
  chipIdField: PropTypes.string,
  /**
   * The property on each chip that is used as a unique key.
   *
   * Defaults to **'id'**.
   */
  chipKeyField: PropTypes.string,
  /**
   * The property for the label on each chip. The `labelRenderer` overrides the rendering of the label field
   *
   * Defaults to **'label'**.
   */
  chipLabelField: PropTypes.string,
  /**
   * Array of chips to manager and render.
   *
   * Defaults to **[]**.
   */
  chips: PropTypes.array.isRequired,
  /**
   * Prevent the user from interacting with the chips.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * Allows chips to be dynamically added and removed upon trailing icon interaction.
   *
   * Defaults to **false**.
   */
  input: PropTypes.bool,
  /**
   * Returns the label to be rendered on each chip. Receives the chipData.
   *
   * Defaults to **null**.
   */
  labelRenderer: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  /**
   * Leading icon render function. `chip` and `iconProps` is passed into the params. `iconProps` contains all the props for the icon component. If unused, a material icon rendering the `leadingIconField` of each chip is used
   *
   * Defaults to **null**.
   */
  leadingIcon: PropTypes.func,
  /**
   * Leading icon property name for each chip. The leading icon property can either be a string corresponding to an icon, or an object containing all the properties for the icon component.
   *
   * Defaults to **'leadingIcon'**.
   */
  leadingIconField: PropTypes.string,
  /**
   * Fired when the chip is interacted with (via click/tap or Enter key).
   *
   * Defaults to **null**.
   */
  onInteraction: PropTypes.func,
  /**
   * Fired when a chip is removed.
   *
   * Defaults to **null**.
   */
  onRemoval: PropTypes.func,
  /**
   * Fired when the chips are removed (*input chips* only).
   *
   * Defaults to **null**.
   */
  onUpdateChips: PropTypes.func,
  /**
   * Fired when the selected chips are updated (choice and filter chips only).
   *
   * Defaults to **null**.
   */
  onUpdateSelectedChips: PropTypes.func,
  /**
   * Prevents choice chips from being deselected upon interaction.
   *
   * Defaults to **false**.
   */
  preventChoiceDeselection: PropTypes.bool,
  /**
   * Chips do not break on a newline. The user must scroll horizontally if there is any overflow.
   *
   * Defaults to **false**.
   */
  scrollable: PropTypes.bool,
  /**
   * Array of currently selected chips.
   *
   * Defaults to **[]**.
   */
  selectedChips: PropTypes.array,
  /**
   * Filter enables selection of multiple chips and will add a check mark to selected chips. Choice allows only one selected chip.
   *
   * Defaults to **'default'**.
   */
  selectionType: PropTypes.oneOf(["default", "choice", "filter"]),
  /**
   * Trailing icon render function. `chip` and `iconProps` is passed into the params. `iconProps` contains all the props for the icon component. If unused, a material icon rendering the `trailingIconField` of each chip is used
   *
   * Defaults to **null**.
   */
  trailingIcon: PropTypes.func,
  /**
   * Trailing icon property name for each chip. The trailing icon property can either be a string corresponding to an icon, or an object containing all the properties for the icon component.
   *
   * Defaults to **'trailingIcon'**.
   */
  trailingIconField: PropTypes.string,
  /**
   * Shows chips as `filled` or `outlined`.
   *
   * Defaults to **'filled'**.
   */
  variant: PropTypes.oneOf(["filled", "outlined"])
};
const ChipsDefaultProps = {
  chipIdField: "",
  chipKeyField: "id",
  chipLabelField: "label",
  chips: [],
  disabled: false,
  input: false,
  labelRenderer: null,
  leadingIcon: null,
  leadingIconField: "leadingIcon",
  preventChoiceDeselection: false,
  scrollable: false,
  selectedChips: [],
  selectionType: "default",
  trailingIcon: null,
  trailingIconField: "trailingIcon",
  variant: "filled"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ChipPropTypes = {
  /**
   * Chip data to be rendered. If no `label` is passed in, `chipData` will be used. If using an object, use the `chipLabelField` to set property to be rendered as the label. You may also set `leadingIconField` and `trailingIconField`, as well as labelRenderer for additional control.
   *
   * Defaults to **null**.
   */
  chipData: PropTypes.any.isRequired,
  /**
   * The property on the chip that represents the id. If one is not provided material will generate an automatic ID.
   *
   * Defaults to **empty string**.
   */
  chipIdField: PropTypes.string,
  /**
   * The property on the chip that is the label. The default slot overrides the rendering of the label.
   *
   * Defaults to **empty string**.
   */
  chipLabelField: PropTypes.string.isRequired,
  /**
   * Prevent the user from interacting with the chip.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * Custom id.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * If the chip is selected on mount.
   *
   * Defaults to **null**.
   */
  initiallySelected: PropTypes.bool.isRequired,
  /**
   * Allows chip to be dynamically added and removed upon trailing icon interaction.
   *
   * Defaults to **null**.
   */
  input: PropTypes.bool.isRequired,
  /**
   * The label to be rendered on each chip. Optionally `chipData` and `chipLabelField` may be used instead of `label`.
   *
   * Defaults to **null**.
   */
  label: PropTypes.node,
  /**
   * Returns the label to be rendered on each chip. Receives the chipData.
   *
   * Defaults to **null**.
   */
  labelRenderer: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  /**
   * Slot for leading icon. `chip` and `iconProps` is passed into the slots params. `iconProps` contains all the props for the icon component. If there is no leading icon, a material icon rendering the `leadingIconPropName` of each chip is used.
   *
   * Defaults to **null**.
   */
  leadingIcon: PropTypes.func,
  /**
   * Leading icon property name for the chip. The leading icon property can either be a string corresponding to an icon, or an object containing all the properties for the icon component.
   *
   * Defaults to **empty string**.
   */
  leadingIconField: PropTypes.string.isRequired,
  /**
   * Called when chip is clicked.
   *
   * Defaults to **null**.
   */
  onClick: PropTypes.func,
  /**
   * Fired when the chip is destroyed.
   *
   * Defaults to **null**.
   */
  onDestroy: PropTypes.func,
  /**
   * Called when Enter is pressed.
   *
   * Defaults to **null**.
   */
  onEnter: PropTypes.func,
  /**
   * Fired when the chip is mounted.
   *
   * Defaults to **null**.
   */
  onMounted: PropTypes.func,
  /**
   * The type`filter` enables selection of multiple chips and will add a check mark to selected chips. The type`choice` allows only one selected chip.
   *
   * Defaults to **'default'**.
   */
  selectionType: PropTypes.oneOf(["default", "choice", "filter"]),
  /**
   * Slot for trailing icon. `chip` and `iconProps` is passed into the slots params. `iconProps` contains all the props for the icon component. If there is no trailing icon, a material icon rendering the `trailingIconPropName` of each chip is used.
   *
   * Defaults to **null**.
   */
  trailingIcon: PropTypes.func,
  /**
   * Trailing icon property name for the chip. The trailing icon property can either be a string corresponding to an icon, or an object containing all the properties for the icon component.
   *
   * Defaults to **empty string**.
   */
  trailingIconField: PropTypes.string.isRequired,
  /**
   * Applies the selected style.
   *
   * Defaults to **'filled'**.
   */
  variant: PropTypes.oneOf(["filled", "outlined"]).isRequired
};
const ChipDefaultProps = {
  chipData: null,
  chipIdField: "",
  chipLabelField: "",
  disabled: false,
  id: undefined,
  initiallySelected: null,
  input: null,
  label: null,
  labelRenderer: null,
  leadingIcon: null,
  leadingIconField: "",
  selectionType: "default",
  trailingIcon: null,
  trailingIconField: "",
  variant: "filled"
};

const getChipProp = (props, prop) => {
  var _props$chipData;
  const iconProps = props === null || props === void 0 ? void 0 : (_props$chipData = props.chipData) === null || _props$chipData === void 0 ? void 0 : _props$chipData[prop];
  if (iconProps) {
    if (typeof iconProps === 'string') {
      return {
        icon: iconProps
      };
    }
    if (typeof iconProps === 'object') {
      return iconProps;
    }
    edsWarning(`${prop} chip field must be of type string or object`);
  }
  return {};
};
const leadingIconSlotProps = props => {
  const iconProps = getChipProp(props, props.leadingIconField);
  const hiddenClass = props.initiallySelected ? 'mdc-chip__icon--leading-hidden' : '';
  return {
    chip: props.chipData,
    iconProps: {
      ...iconProps,
      className: `mdc-chip__icon mdc-chip__icon--leading ${hiddenClass}`,
      tabIndex: '-1'
    }
  };
};
const trailingIconSlotProps = props => {
  const {
    icon,
    ...otherIconProps
  } = getChipProp(props, props.trailingIconField);
  return {
    chip: props.chipData,
    iconProps: {
      ...otherIconProps,
      icon: icon || 'cancel',
      className: 'mdc-chip__icon mdc-chip__icon--trailing mdc-chip-trailing-action',
      role: 'button',
      tabIndex: '0'
    }
  };
};
const checkmark = /*#__PURE__*/React.createElement("span", {
  className: "mdc-chip__checkmark"
}, /*#__PURE__*/React.createElement("svg", {
  className: "mdc-chip__checkmark-svg",
  viewBox: "-2 -3 30 30"
}, /*#__PURE__*/React.createElement("path", {
  className: "mdc-chip__checkmark-path",
  fill: "none",
  stroke: "black",
  d: "M1.73,12.91 8.1,19.28 22.79,4.59"
})));
const Chip = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    chipData,
    chipIdField,
    chipLabelField,
    disabled,
    id,
    initiallySelected,
    input,
    label,
    labelRenderer,
    leadingIcon,
    leadingIconField,
    onDestroy,
    onMounted,
    selectionType,
    trailingIcon,
    trailingIconField,
    variant,
    onClick,
    onEnter,
    ...customProps
  } = props;
  const [idActual] = useState(() => {
    var _chipData$chipIdField;
    return id || chipIdField && (chipData === null || chipData === void 0 ? void 0 : (_chipData$chipIdField = chipData[chipIdField]) === null || _chipData$chipIdField === void 0 ? void 0 : _chipData$chipIdField.toString()) || edsRandomId();
  });
  const chipRef = useRef();
  const state = useRef({});
  useImperativeHandle(externalRef, () => chipRef.current, []);
  useEffect(() => {
    state.current.onMounted = onMounted;
  }, [onMounted]);
  useEffect(() => {
    state.current.onDestroy = onDestroy;
  }, [onDestroy]);
  useEffect(() => {
    state.current.chipData = chipData;
  }, [chipData]);
  useEffect(() => {
    var _currentState$onMount;
    const currentState = state === null || state === void 0 ? void 0 : state.current;
    currentState === null || currentState === void 0 ? void 0 : (_currentState$onMount = currentState.onMounted) === null || _currentState$onMount === void 0 ? void 0 : _currentState$onMount.call(currentState, currentState.chipData, chipRef.current);
    return () => {
      var _currentState$onDestr;
      currentState === null || currentState === void 0 ? void 0 : (_currentState$onDestr = currentState.onDestroy) === null || _currentState$onDestr === void 0 ? void 0 : _currentState$onDestr.call(currentState, currentState.chipData);
    };
  }, []);
  let trailingIconElement;
  let leadingIconElement;
  const leadingIconProps = leadingIconSlotProps(props);
  if (leadingIcon) {
    leadingIconElement = leadingIcon(leadingIconProps);
  } else if (leadingIconProps.iconProps.icon) {
    leadingIconElement = /*#__PURE__*/React.createElement(Icon, leadingIconProps.iconProps);
  }
  if (input) {
    const slotProps = trailingIconSlotProps(props);
    if (trailingIcon) {
      trailingIconElement = trailingIcon(slotProps);
    } else {
      trailingIconElement = /*#__PURE__*/React.createElement(Icon, slotProps.iconProps);
    }
  }
  const [labelActual, setLabelActual] = useState();
  useEffect(() => {
    if (label) {
      setLabelActual(label);
      return;
    }
    if (labelRenderer) {
      setLabelActual(labelRenderer({
        chip: chipData
      }));
      return;
    }
    if (isObjectLike(chipData)) {
      setLabelActual(chipData[chipLabelField]);
      return;
    }
    setLabelActual(chipData);
  }, [chipData, chipLabelField, label, labelRenderer]);
  const chipClasses = clsx('lmnt', 'mdc-chip', 'mdc-chip--touch', initiallySelected && 'mdc-chip--selected', variant === 'outlined' && 'mdc-chip--outline', disabled && 'lmnt-chip--disabled');
  const handleClick = e => {
    if (!disabled) onClick === null || onClick === void 0 ? void 0 : onClick(e);
  };
  const handleKeyPress = e => {
    if (e.key === 'Enter') {
      onEnter === null || onEnter === void 0 ? void 0 : onEnter(e);
    }
  };
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: chipRef,
    className: chipClasses,
    id: idActual,
    role: "row",
    onClick: handleClick,
    tabIndex: 0,
    onKeyUp: handleKeyPress
  }, customProps), /*#__PURE__*/React.createElement("div", {
    className: "lmnt mdc-chip__ripple"
  }), leadingIconElement, selectionType === 'filter' && checkmark, /*#__PURE__*/React.createElement("span", {
    role: "gridcell"
  }, /*#__PURE__*/React.createElement("span", {
    // eslint-disable-next-line jsx-a11y/role-has-required-aria-props
    role: "checkbox",
    tabIndex: "0",
    className: "mdc-chip__primary-action"
  }, /*#__PURE__*/React.createElement("span", {
    className: "mdc-chip__text"
  }, labelActual))), trailingIconElement);
});
Chip.displayName = 'Chip';
Chip.propTypes = ChipPropTypes;
Chip.defaultProps = ChipDefaultProps;
var Chip$1 = /*#__PURE__*/React.memo(Chip);

const {
  MDCChipSet
} = {
  ...deprecated
};
const createMdcChipSet = element => {
  const chipset = MDCChipSet.attachTo(element);
  chipset.foundation.adapter.removeChipAtIndex = index => {
    // Override removeChipAtIndex so that it doesn't remove the HTML. let react handle that
    if (index >= 0 && index < chipset.chips_.length) {
      chipset.chips_[index].destroy();
      chipset.chips_.splice(index, 1);
    }
  };
  return chipset;
};
const Chips = _ref => {
  let {
    children,
    chipIdField,
    chipKeyField,
    chipLabelField,
    chips,
    input,
    labelRenderer,
    leadingIcon,
    leadingIconField,
    onInteraction,
    onRemoval,
    onUpdateChips,
    onUpdateSelectedChips,
    preventChoiceDeselection,
    scrollable,
    selectedChips,
    selectionType,
    trailingIcon,
    trailingIconField,
    variant,
    disabled,
    ...customProps
  } = _ref;
  const destroyed = useRef(false);
  const [chipKeysToId, {
    remove: removeChipId,
    set: addChipId
  }] = useMap();
  const [chipsetRef, setChipsetRef] = useState(null); // Initialize to null so that useEvent doesn't initially listen to the global window
  const [mdcChipSet, setMdcChipSet] = useState(null);
  const getKey = useCallback(chip => chip[chipKeyField] || chip, [chipKeyField]);
  const [initiallySelectedChips] = useState(() => new Set(selectedChips.map(chip => getKey(chip))));
  const selectedChipSet = useMemo(() => new Set(selectedChips.map(chip => getKey(chip))), [getKey, selectedChips]);
  useIsomorphicLayoutEffect(() => {
    destroyed.current = false;
    const chipset = chipsetRef ? createMdcChipSet(chipsetRef) : null;
    setMdcChipSet(chipset);
    return () => {
      if (chipset) {
        destroyed.current = true;
        chipset.destroy();
      }
    };
  }, [chipsetRef]);
  const getId = useCallback(chip => chipKeysToId[getKey(chip)], [chipKeysToId, getKey]);
  const getChip = useCallback(id => chips.find(chip => getId(chip) === id), [chips, getId]);
  const getMdcChip = useCallback(id => mdcChipSet === null || mdcChipSet === void 0 ? void 0 : mdcChipSet.chips.find(chip => chip.id === id), [mdcChipSet]);
  const isSelected = useCallback(chip => selectedChipSet.has(getKey(chip)), [getKey, selectedChipSet]);
  const isInitiallySelected = useCallback(chip => !!initiallySelectedChips.has(getKey(chip)), [getKey, initiallySelectedChips]);
  const onMounted = useCallback((chip, chipElement) => {
    addChipId(getKey(chip), chipElement.id);
    mdcChipSet === null || mdcChipSet === void 0 ? void 0 : mdcChipSet.addChip(chipElement);
  }, [addChipId, getKey, mdcChipSet]);
  const emitSelectedChips = useCallback(() => {
    if (onUpdateSelectedChips) {
      const selectedIdsSet = new Set(mdcChipSet === null || mdcChipSet === void 0 ? void 0 : mdcChipSet.selectedChipIds);
      onUpdateSelectedChips(chips.filter(item => selectedIdsSet.has(getId(item))));
    }
  }, [mdcChipSet, onUpdateSelectedChips, chips, getId]);
  const onSelectCallback = useCallback(() => {
    if (selectionType !== 'choice') {
      // ignore choice chips since multiple events get fired
      emitSelectedChips();
    }
  }, [selectionType, emitSelectedChips]);
  const onChipRemoval = useCallback(chip => {
    if (!input) {
      return;
    }
    const availableChips = new Set(mdcChipSet === null || mdcChipSet === void 0 ? void 0 : mdcChipSet.chips.map(item => item.id));
    const filteredChips = chips.filter(item => availableChips.has(getId(item)));
    if (onUpdateChips) {
      onUpdateChips(filteredChips);
    }
    if (onRemoval) {
      onRemoval(chip);
    }
  }, [chips, getId, input, mdcChipSet, onRemoval, onUpdateChips]);
  const onChipRemovalCallback = useCallback(event => {
    onChipRemoval(getChip(event.detail.chipId));
  }, [getChip, onChipRemoval]);
  const onInteractionCallback = useCallback(event => {
    if (onInteraction) {
      const chip = getChip(event.detail.chipId);
      onInteraction(chip);
    }
    if (selectionType === 'choice') {
      if (preventChoiceDeselection) {
        const mdcChip = getMdcChip(event.detail.chipId);
        if (!mdcChip.selected) {
          mdcChip.selected = true;
          return;
        }
      }
      emitSelectedChips();
    }
  }, [emitSelectedChips, getChip, getMdcChip, onInteraction, preventChoiceDeselection, selectionType]);
  const onDestroy = useCallback(chip => {
    if (destroyed.current) {
      return;
    }
    const id = getId(chip);
    const key = getKey(chip);
    removeChipId(key);
    if (getMdcChip(id)) {
      mdcChipSet.foundation.handleChipRemoval({
        chipId: id
      });
      onSelectCallback();
      onChipRemoval(chip);
    }
  }, [getId, getKey, getMdcChip, mdcChipSet, onChipRemoval, onSelectCallback, removeChipId]);
  useEffect(() => {
    const mdcChipMap = new Map(mdcChipSet === null || mdcChipSet === void 0 ? void 0 : mdcChipSet.chips.map(chip => [chip.id, chip]));
    for (const chip of chips) {
      const selected = isSelected(chip);
      const mdcChip = mdcChipMap.get(getId(chip));
      if (mdcChip && selected !== mdcChip.selected) {
        mdcChip.selected = selected;
      }
    }
  }, [chips, getId, isSelected, mdcChipSet]);
  useEvent('MDCChip:removal', onChipRemovalCallback, chipsetRef);
  useEvent('MDCChip:selection', onSelectCallback, chipsetRef);
  useEvent('MDCChip:interaction', onInteractionCallback, chipsetRef);
  const chipElements = useMemo(() => chips.map(chip => /*#__PURE__*/React.createElement(Chip$1, {
    key: getKey(chip),
    chipData: chip,
    chipIdField: chipIdField
    // chipKeyField={chipKeyField}
    ,
    chipLabelField: chipLabelField,
    initiallySelected: isInitiallySelected(chip),
    input: input,
    labelRenderer: labelRenderer,
    leadingIcon: leadingIcon,
    leadingIconField: leadingIconField,
    onDestroy: onDestroy,
    onMounted: onMounted,
    selectionType: selectionType,
    trailingIcon: trailingIcon,
    trailingIconField: trailingIconField,
    variant: variant,
    disabled: disabled || chip.disabled
  })), [chipIdField, chipLabelField, chips, disabled, getKey, input, isInitiallySelected, labelRenderer, leadingIcon, leadingIconField, onDestroy, onMounted, selectionType, trailingIcon, trailingIconField, variant]);
  return /*#__PURE__*/React.createElement("div", _extends({
    className: clsx('lmnt', scrollable && 'mdc-chip-set-scrollable-wrapper')
  }, customProps), /*#__PURE__*/React.createElement("div", {
    ref: setChipsetRef,
    className: clsx('lmnt', 'mdc-chip-set', selectionType === 'choice' && 'mdc-chip-set--choice', selectionType === 'filter' && 'mdc-chip-set--filter', input && 'mdc-chip-set--input', scrollable && 'mdc-chip-set--input-scroll', disabled && 'lmnt-chips--disabled')
  }, chipElements));
};
Chips.displayName = 'Chips';
Chips.propTypes = ChipsPropTypes;
Chips.defaultProps = ChipsDefaultProps;
var Chips$1 = /*#__PURE__*/React.memo(Chips);

export { Chip$1 as Chip, Chips$1 as ChipSet, Chips$1 as Chips };
//# sourceMappingURL=index.es.js.map
