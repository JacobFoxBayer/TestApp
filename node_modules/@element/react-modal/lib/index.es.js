import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { forwardRef, useRef, useImperativeHandle, useState, useEffect, useCallback, useMemo } from 'react';
import { MDCDialog } from '@material/dialog';
import { Icon } from '@element/react-icon';
import { IconButton } from '@element/react-icon-button';
import clsx from 'clsx';
import { returnFocusAfterClosing, addProps, addClass } from '@element/react-common';
import PropTypes from 'prop-types';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const ModalPropTypes = {
  /**
   * An action button that will not automatically trigger a dismiss or accept. It is meant to be used only in certain circumstances where more control of the modal is required such as validating forms. If primaryButton is sent with actionButton, actionButton will be ignored.
   *
   * Defaults to **null**.
   */
  actionButton: PropTypes.node,
  /**
   * Button for any navigating to the previous page in a Directional modal.
   *
   * Defaults to **null**.
   */
  backButton: PropTypes.node,
  /**
   * The custom modal label badge to be rendered.
   *
   * Defaults to **undefined**.
   */
  badge: PropTypes.node,
  /**
   * Accepts any valid markup. Optionally, `content` may be used instead. If `content` and `children` are both set, `content` will take priority.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Primary content of the dialog. Accepts any valid markup. Optionally, `children` may be used instead. If content and `children` are both set, content will take priority.
   *
   * Defaults to **null**.
   */
  content: PropTypes.node,
  /**
   * Button that is the default action, triggered by pressing the Enter key.
   *
   * Defaults to **'primary'**.
   */
  defaultButton: PropTypes.oneOf(["close", "primary", "action", "footerSupplemental"]),
  /**
   * Button to cancel or close the modal.
   *
   * Defaults to **null**.
   */
  dismissiveButton: PropTypes.node,
  /**
   * Button to be displayed in left corner of the modal footer. Should be a text button.
   *
   * Defaults to **null**.
   */
  footerSupplemental: PropTypes.node,
  /**
   * Content to be displayed in right corner of the modal header. Should be a text button or a group of up to 3 icon buttons.
   *
   * Defaults to **null**.
   */
  headerActions: PropTypes.node,
  /**
   * If true, the close icon in the upper left corner will not be rendered.
   *
   * Defaults to **false**.
   */
  hideCloseIcon: PropTypes.bool,
  /**
   * A slot for StepperIndicator.
   *
   * Defaults to **null**.
   */
  indicator: PropTypes.node,
  /**
   * Button to initially focus on after the dialog has opened. If left null, the initial focus will be on the first focusable element in the modal. As an alternative you can add `data-mdc-dialog-initial-focus` to any element within the modal to make that element the initial focus. If it is a directional modal, the initial focus will be on the nextButton.
   *
   * Defaults to **null**.
   */
  initialFocus: PropTypes.oneOf(["null", "primary", "action", "footerSupplemental"]),
  /**
   * If true, the buttons in the footer will be full width and stacked on mobile.
   *
   * Defaults to **false**.
   */
  mobileStackedButtons: PropTypes.bool,
  /**
   * String to determine the size of the modal.
   *
   * Defaults to **'max'**.
   */
  modalSize: PropTypes.oneOf(["fullscreen", "max", "xlarge", "large", "medium", "small", "dialog"]),
  /**
   * Button for navigating to the next page in a Directional modal or closing on the last page.
   *
   * Defaults to **null**.
   */
  nextButton: PropTypes.node,
  /**
   * Set to true if the modal will not have any actions. Should be used sparingly and the modal should be closed programmatically. For example, can be used to stop the user from interacting or navigating away while a payment is processing.
   *
   * Defaults to **null**.
   */
  noActions: PropTypes.bool,
  /**
   * Fired when the Dialog begins its closing animation. Where event.detail.action is the action which closed the dialog (close or accept).
   *
   * Defaults to **null**.
   */
  onClose: PropTypes.func,
  /**
   * Fired when the Dialog finishes its closing animation. Where event.detail.action is the action which closed the dialog (close or accept).
   *
   * Defaults to **null**.
   */
  onClosed: PropTypes.func,
  /**
   * Fired when the Dialog begins its opening animation.
   *
   * Defaults to **null**.
   */
  onOpen: PropTypes.func,
  /**
   * Fired when the Dialog finishes its opening animation.
   *
   * Defaults to **null**.
   */
  onOpened: PropTypes.func,
  /**
   * If true, the Modal will be visible on screen.
   *
   * Defaults to **false**.
   */
  open: PropTypes.bool,
  /**
   * Prevents the user from closing the dialog by hitting escape or clicking the scrim. Use caution when using this as the modal should always have a way for the user to close it.
   *
   * Defaults to **false**.
   */
  preventClose: PropTypes.bool,
  /**
   * Button for the primary action of the modal.
   *
   * Defaults to **null**.
   */
  primaryButton: PropTypes.node,
  /**
   * DOM selector to provide a target to return focus. Accepts any valid _query_ (see mdn docs for Element.querySelector). If omitted focus will return to the last focused element upon closing.
   *
   * Defaults to **null**.
   */
  returnFocusSelector: PropTypes.string,
  /**
   * If true, wrapping will be disabled and a scrollable area will be created.
   *
   * Defaults to **false**.
   */
  scrollable: PropTypes.bool,
  /**
   * String for the modal title.
   *
   * Defaults to **null**.
   */
  title: PropTypes.string
};
const ModalDefaultProps = {
  actionButton: null,
  backButton: null,
  badge: undefined,
  children: null,
  content: null,
  defaultButton: "primary",
  dismissiveButton: null,
  footerSupplemental: null,
  headerActions: null,
  hideCloseIcon: false,
  indicator: null,
  initialFocus: null,
  mobileStackedButtons: false,
  modalSize: "max",
  nextButton: null,
  noActions: null,
  open: false,
  preventClose: false,
  primaryButton: null,
  returnFocusSelector: null,
  scrollable: false,
  title: null
};

const Modal = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    actionButton,
    actionIcons,
    badge,
    backButton,
    children,
    className,
    content,
    defaultButton,
    dismissiveButton,
    footerSupplemental,
    headerActions,
    hideCloseIcon,
    indicator,
    initialFocus,
    mobileStackedButtons,
    modalSize,
    nextButton,
    noActions,
    onClose,
    onClosed,
    onOpen,
    onOpened,
    open,
    preventClose,
    primaryButton,
    returnFocusSelector,
    scrollable,
    title,
    ...customProps
  } = props;
  const ref = useRef();
  const mdcDialog = useRef();
  useImperativeHandle(externalRef, () => ref.current, []);
  const [isMobile, setMobile] = useState();
  const [isDirectional, setIsDirectional] = useState(() => nextButton || backButton);
  useEffect(() => {
    setIsDirectional(nextButton || backButton);
  }, [nextButton, backButton]);
  const handleWindowSizeChange = useCallback(() => {
    setMobile(window.innerWidth <= 600);
  }, []);
  useEffect(() => {
    handleWindowSizeChange();
    window.addEventListener('resize', handleWindowSizeChange);
    return () => {
      window.removeEventListener('resize', handleWindowSizeChange);
    };
  }, [handleWindowSizeChange]);
  useEffect(() => {
    mdcDialog.current = MDCDialog.attachTo(ref.current);
    return () => {
      mdcDialog.current.destroy();
    };
  }, [mdcDialog, ref]);
  useEffect(() => {
    if (noActions) {
      mdcDialog.current.foundation.adapter.trapFocus = () => {};
    }
  }, [noActions]);
  useEffect(() => {
    mdcDialog.current.scrimClickAction = preventClose ? '' : 'close';
    mdcDialog.current.escapeKeyAction = preventClose ? '' : 'close';
  }, [preventClose]);
  const handleOnClose = useCallback(event => {
    onClose && onClose(event);
  }, [onClose]);
  const handleOnClosed = useCallback(event => {
    returnFocusSelector && returnFocusAfterClosing(returnFocusSelector);
    onClosed && onClosed(event);
  }, [returnFocusSelector, onClosed]);
  useEffect(() => {
    mdcDialog.current.unlisten('MDCDialog: opening', onOpen);
    mdcDialog.current.listen('MDCDialog: opening', onOpen);
    return () => {
      mdcDialog.current.unlisten('MDCDialog: opening', onOpen);
    };
  }, [mdcDialog, onOpen]);
  useEffect(() => {
    mdcDialog.current.unlisten('MDCDialog:opened', onOpened);
    mdcDialog.current.listen('MDCDialog:opened', onOpened);
    return () => {
      mdcDialog.current.unlisten('MDCDialog:opened', onOpened);
    };
  }, [mdcDialog, onOpened]);
  useEffect(() => {
    mdcDialog.current.unlisten('MDCDialog:closing', handleOnClose);
    mdcDialog.current.listen('MDCDialog:closing', handleOnClose);
    return () => {
      mdcDialog.current.unlisten('MDCDialog:closing', handleOnClose);
    };
  }, [mdcDialog, handleOnClose]);
  useEffect(() => {
    mdcDialog.current.unlisten('MDCDialog:closed', handleOnClosed);
    mdcDialog.current.listen('MDCDialog:closed', handleOnClosed);
    return () => {
      mdcDialog.current.unlisten('MDCDialog:closed', handleOnClosed);
    };
  }, [mdcDialog, handleOnClosed]);
  useEffect(() => {
    if (open) {
      mdcDialog.current.open();
    } else {
      mdcDialog.current.close();
    }
  }, [mdcDialog, open]);
  const actionButtonProps = useMemo(() => () => {
    const ret = {
      className: 'lmnt-modal__button mdc-dialog__button',
      elevation: (actionButton === null || actionButton === void 0 ? void 0 : actionButton.props.elevation) !== 'default' ? actionButton === null || actionButton === void 0 ? void 0 : actionButton.props.elevation : 'flat',
      variant: (actionButton === null || actionButton === void 0 ? void 0 : actionButton.props.variant) || 'filled'
    };
    if (defaultButton === 'action') {
      ret['data-mdc-dialog-button-default'] = true;
    }
    if (initialFocus === 'action') {
      ret['data-mdc-dialog-initial-focus'] = true;
    }
    return ret;
  }, [actionButton === null || actionButton === void 0 ? void 0 : actionButton.props.elevation, actionButton === null || actionButton === void 0 ? void 0 : actionButton.props.variant, defaultButton, initialFocus]);
  const primaryButtonProps = useMemo(() => () => {
    const ret = {
      className: 'lmnt-modal__button mdc-dialog__button',
      'data-mdc-dialog-action': 'accept',
      elevation: (primaryButton === null || primaryButton === void 0 ? void 0 : primaryButton.props.elevation) !== 'default' ? primaryButton === null || primaryButton === void 0 ? void 0 : primaryButton.props.elevation : 'flat',
      variant: (primaryButton === null || primaryButton === void 0 ? void 0 : primaryButton.props.variant) || 'filled'
    };
    if (defaultButton === 'primary') {
      ret['data-mdc-dialog-button-default'] = true;
    }
    if (initialFocus === 'primary') {
      ret['data-mdc-dialog-initial-focus'] = true;
    }
    return ret;
  }, [defaultButton, initialFocus, primaryButton === null || primaryButton === void 0 ? void 0 : primaryButton.props.elevation, primaryButton === null || primaryButton === void 0 ? void 0 : primaryButton.props.variant]);
  return /*#__PURE__*/React.createElement("aside", _extends({
    ref: ref,
    className: clsx('lmnt', 'lmnt-modal', 'mdc-dialog', open && 'mdc-dialog--open', scrollable && 'lmnt-modal--scrollable mdc-dialog--scrollable', className),
    role: "alertdialog"
  }, customProps), /*#__PURE__*/React.createElement("div", {
    className: clsx('lmnt-modal__container', 'mdc-dialog__container', modalSize === 'fullscreen' && 'mdc-dialog--fullscreen', modalSize === 'max' && 'lmnt-modal__max', modalSize === 'xlarge' && 'lmnt-modal__xl', modalSize === 'large' && 'lmnt-modal__lg', modalSize === 'medium' && 'lmnt-modal__md', modalSize === 'small' && 'lmnt-modal__sm', (modalSize === 'mobile' || isMobile) && 'lmnt-modal__mobile', modalSize === 'dialog' && 'lmnt-modal__dialog', noActions && 'lmnt-modal-no-actions')
  }, /*#__PURE__*/React.createElement("div", {
    className: "lmnt-modal__surface mdc-dialog__surface"
  }, /*#__PURE__*/React.createElement("header", {
    className: clsx('lmnt-modal__title', 'mdc-dialog__title', (modalSize === 'dialog' || hideCloseIcon) && 'lmnt-modal_title-hide-close-icon', actionIcons && 'lmnt-modal_title-actionsIcons', scrollable && 'lmnt-modal__title-scrollable', (hideCloseIcon || modalSize === 'dialog' || noActions) && 'lmnt-modal--no-close-icon')
  }, !hideCloseIcon && modalSize !== 'dialog' && !noActions && /*#__PURE__*/React.createElement(IconButton, {
    className: "mdc-icon-button material-icons mdc-dialog__close",
    "data-mdc-dialog-action": "close"
  }, /*#__PURE__*/React.createElement(Icon, {
    icon: "clear"
  })), title && /*#__PURE__*/React.createElement("div", null, title), headerActions && /*#__PURE__*/React.createElement("div", {
    className: "lmnt-dialog__title-actions"
  }, headerActions), badge && /*#__PURE__*/React.createElement("div", {
    className: "lmnt-badge--modal",
    style: {
      marginLeft: '0'
    }
  }, badge)), (content || children) && /*#__PURE__*/React.createElement("section", {
    className: "lmnt-modal__content mdc-dialog__content"
  }, content || children), indicator, (actionButton || backButton || dismissiveButton || nextButton || primaryButton || footerSupplemental) && /*#__PURE__*/React.createElement("footer", {
    className: clsx('lmnt-modal__actions', 'mdc-dialog__actions', isMobile && 'lmnt-dialog__actions__mobile', footerSupplemental && 'lmnt-modal__actions--supplemental-btn', isMobile && mobileStackedButtons && 'lmnt-modal_actions-mobile-stacked')
  }, !isDirectional && footerSupplemental && /*#__PURE__*/React.createElement("div", {
    className: "lmnt-dialog__actions__supplemental"
  }, addProps(footerSupplemental, () => {
    const ret = {};
    if (defaultButton === 'footerSupplemental') {
      ret['data-mdc-dialog-button-default'] = true;
    }
    if (initialFocus === 'footerSupplemental') {
      ret['data-mdc-dialog-initial-focus'] = true;
    }
    return ret;
  })), !isDirectional && (actionButton || dismissiveButton || primaryButton) && /*#__PURE__*/React.createElement("div", {
    className: "lmnt-dialog__actions__right-align lmnt-modal_actions_button"
  }, dismissiveButton && addProps(dismissiveButton, {
    variant: 'text',
    className: 'lmnt-modal__button mdc-dialog__button',
    'data-mdc-dialog-action': 'close'
  }), actionButton && !primaryButton && addProps(actionButton, actionButtonProps), primaryButton && addProps(primaryButton, primaryButtonProps)), isDirectional && /*#__PURE__*/React.createElement("div", {
    className: "lmnt-modal_actions_button lmnt-dialog__actions__directional"
  }, /*#__PURE__*/React.createElement("div", null, addClass(backButton, 'lmnt-modal__button')), /*#__PURE__*/React.createElement("div", null, addProps(nextButton, {
    className: 'lmnt-modal__button',
    'data-mdc-dialog-initial-focus': true
  })))))), /*#__PURE__*/React.createElement("div", {
    className: "mdc-dialog__scrim"
  }));
});
Modal.displayName = 'Modal';
Modal.propTypes = ModalPropTypes;
Modal.defaultProps = ModalDefaultProps;

export { Modal };
//# sourceMappingURL=index.es.js.map
