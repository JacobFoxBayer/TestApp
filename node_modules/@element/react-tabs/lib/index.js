'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime-corejs3/helpers/extends');
var tab = require('@material/tab');
var clsx = require('clsx');
var React = require('react');
var reactCommon = require('@element/react-common');
var reactIcon = require('@element/react-icon');
var PropTypes = require('prop-types');
var tabIndicator = require('@material/tab-indicator');
var tabBar = require('@material/tab-bar');
var tabScroller = require('@material/tab-scroller');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefault(_extends);
var clsx__default = /*#__PURE__*/_interopDefault(clsx);
var React__default = /*#__PURE__*/_interopDefault(React);
var PropTypes__default = /*#__PURE__*/_interopDefault(PropTypes);

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TabBarPropTypes = {
  /**
   * Index of the currently active tab.
   *
   * Defaults to **0**.
   */
  activeTabIndex: PropTypes__default["default"].number,
  /**
   * Accepts one or more Tab components.
   *
   * Defaults to **null**.
   */
  children: PropTypes__default["default"].node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes__default["default"].string,
  /**
   * Clustered tabs can be aligned to 'start', 'center', or 'end'. Requires one or more tabs to have clustered set to true.
   *
   * Defaults to **'start'**.
   */
  clusterAlign: PropTypes__default["default"].oneOf(["start", "center", "end"]),
  /**
   * Indicates that tabs should shrink in size to be as narrow as possible without causing text to wrap.
   *
   * Defaults to **false**.
   */
  clustered: PropTypes__default["default"].bool,
  /**
   * Apply elevated styles to raise the tab-bar above standard content.
   *
   * Defaults to **false**.
   */
  elevated: PropTypes__default["default"].bool,
  /**
   * Fires when switching to a different tab.
   *
   * Defaults to **null**.
   */
  onTabActivated: PropTypes__default["default"].func,
  /**
   * @deprecated _Please use elevated instead._
   *
   *  Apply a raised style.
   *
   * Defaults to **undefined**.
   */
  raised: reactCommon.deprecatedProp(PropTypes__default["default"].bool, "TabBar", "Please use elevated instead."),
  /**
   * @deprecated _Deprecated, containers will scroll when necessary._
   *
   * Create a fixed height scrollable container.
   *
   * Defaults to **undefined**.
   */
  scrollable: reactCommon.deprecatedProp(PropTypes__default["default"].bool, "TabBar", "Deprecated, containers will scroll when necessary."),
  /**
   * Indicates that the tab icon and label should flow vertically instead of horizontally.
   *
   * Defaults to **false**.
   */
  stacked: PropTypes__default["default"].bool,
  /**
   * Background theme color. Accepts one of 'primary', 'secondary', or 'surface'.
   *
   * Defaults to **'surface'**.
   */
  variant: PropTypes__default["default"].oneOf(["primary", "secondary", "surface"])
};
const TabBarDefaultProps = {
  activeTabIndex: 0,
  children: null,
  className: undefined,
  clusterAlign: "start",
  clustered: false,
  elevated: false,
  raised: undefined,
  scrollable: undefined,
  stacked: false,
  variant: "surface"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TabPropTypes = {
  /**
   * Indicates that the tab is active.
   *
   * Defaults to **undefined**.
   */
  active: PropTypes__default["default"].bool,
  /**
   * The custom tab notification badge to be rendered.
   *
   * Defaults to **undefined**.
   */
  badge: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].func, PropTypes__default["default"].node]),
  /**
   * The displayed content. Expects a valid string, though will accept any valid components or markup. If label and `children` are both set, `label` will take priority.
   *
   * Defaults to **null**.
   */
  children: PropTypes__default["default"].node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes__default["default"].string,
  /**
   * Indicates that the tab should shrink in size to be as narrow as possible without causing text to wrap.
   *
   * Defaults to **false**.
   */
  clustered: PropTypes__default["default"].bool,
  /**
   * Add a leading icon to the tab.
   *
   * Defaults to **undefined**.
   */
  icon: PropTypes__default["default"].node,
  /**
   * An icon to be used as the tab indicator. Accepts the name of any valid material icon (see Icon component documentation for a list of valid icons). If no icon is provided the tab-indicator will use an underline.
   *
   * Defaults to **null**.
   */
  indicatorIcon: PropTypes__default["default"].string,
  /**
   * The tab-indicator will span the entire tab with 'full' or only the content of the tab with 'content'.
   *
   * Defaults to **'full'**.
   */
  indicatorSize: PropTypes__default["default"].oneOf(["full", "content"]),
  /**
   * The tab-indicator will use a 'slide' or 'fade' transition between tabs.
   *
   * Defaults to **'slide'**.
   */
  indicatorTransition: PropTypes__default["default"].oneOf(["slide", "fade"]),
  /**
   * The displayed text. Expects a valid string. If label and `children` are both set, `label` will take priority.
   *
   * Defaults to **null**.
   */
  label: PropTypes__default["default"].node,
  /**
   * Indicates that the tab icon and label should flow vertically instead of horizontally. If stacked is true the tab will not show a badge.  You can place the badge on the leading icon.
   *
   * Defaults to **false**.
   */
  stacked: PropTypes__default["default"].bool
};
const TabDefaultProps = {
  active: undefined,
  badge: undefined,
  children: null,
  className: undefined,
  clustered: false,
  icon: undefined,
  indicatorIcon: null,
  indicatorSize: "full",
  indicatorTransition: "slide",
  label: null,
  stacked: false
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Visually activates the indicator.
   *
   * Defaults to **false**.
   */
  active: PropTypes__default["default"].bool,
  /**
   * The tab-indicator will use an underline if no icon is provided.
   *
   * Defaults to **null**.
   */
  icon: PropTypes__default["default"].string,
  /**
   * The Tab Indicator will use a 'slide' or 'fade' transition between tabs.
   *
   * Defaults to **'slide'**.
   */
  transition: PropTypes__default["default"].string
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Clustered tabs can be aligned to 'start', 'center', or 'end'.
   *
   * Defaults to **'start'**.
   */
  align: PropTypes__default["default"].oneOf(["start", "center", "end"]),
  /**
   * Accepts Tab components.
   *
   * Defaults to **null**.
   */
  children: PropTypes__default["default"].node
});

const TabIndicator = /*#__PURE__*/React.forwardRef((props, externalRef) => {
  const {
    active,
    className,
    icon,
    id,
    transition,
    ...customProps
  } = props;
  const ref = React.useRef();
  const mdcTabIndicator = React.useRef();
  const classes = clsx__default["default"]('lmnt', 'lmnt-tab-indicator', 'mdc-tab-indicator', active && 'mdc-tab-indicator--active', transition === 'fade' && 'mdc-tab-indicator--fade', className);
  React.useEffect(() => {
    mdcTabIndicator.current = tabIndicator.MDCTabIndicator.attachTo(ref.current);
    return () => {
      mdcTabIndicator.current.destroy();
    };
  }, [mdcTabIndicator]);
  React.useImperativeHandle(externalRef, () => ref.current, []);
  return /*#__PURE__*/React__default["default"].createElement("span", _extends__default["default"]({
    id: id,
    className: classes,
    ref: ref
  }, customProps), icon && /*#__PURE__*/React__default["default"].createElement("span", {
    className: "mdc-tab-indicator__content mdc-tab-indicator__content--icon material-icons",
    "aria-hidden": "true"
  }, icon), !icon && /*#__PURE__*/React__default["default"].createElement("span", {
    className: "mdc-tab-indicator__content mdc-tab-indicator__content--underline"
  }));
});
TabIndicator.displayName = 'TabIndicator';
TabIndicator.propTypes = {
  active: PropTypes__default["default"].bool,
  className: PropTypes__default["default"].string,
  icon: PropTypes__default["default"].string,
  id: PropTypes__default["default"].string,
  transition: PropTypes__default["default"].oneOf(['fade', 'slide'])
};
TabIndicator.defaultProps = {
  active: false,
  className: null,
  icon: null,
  id: null,
  transition: 'slide'
};

const TabsContext = /*#__PURE__*/React.createContext({});

const TabIcon = (icon, label) => {
  if (!icon) return undefined;
  if (typeof icon === 'string') {
    return /*#__PURE__*/React__default["default"].createElement(reactIcon.Icon, {
      tabIndex: 0,
      role: "button",
      className: "mdc-tab__icon",
      ariaHidden: true,
      ariaLabel: label,
      icon: icon
    });
  }
  return reactCommon.addProps(icon, {
    className: 'mdc-tab__icon',
    tabIndex: 0,
    'aria-hidden': true,
    'aria-label': label,
    role: 'button'
  });
};
const Tab = /*#__PURE__*/React.forwardRef((props, externalRef) => {
  const {
    active,
    badge,
    children,
    className,
    clustered,
    icon,
    indicatorIcon,
    indicatorSize,
    indicatorTransition,
    label,
    stacked,
    ...customProps
  } = props;
  const ref = React.useRef();
  const mdcTab = React.useRef();
  React.useImperativeHandle(externalRef, () => ref.current, []);
  const tabsContext = React.useContext(TabsContext);
  const actualStacked = tabsContext.stacked || stacked;
  const actualClustered = tabsContext.clustered || clustered;
  React.useEffect(() => {
    mdcTab.current = tab.MDCTab.attachTo(ref.current);
    return () => {
      mdcTab.current.destroy();
    };
  }, []);
  const classes = clsx__default["default"]('lmnt', 'lmnt-tab', 'mdc-tab', 'mdc-button', active && 'mdc-tab--active', actualClustered && 'mdc-tab--min-width', actualStacked && 'mdc-tab--stacked', className);
  return /*#__PURE__*/React__default["default"].createElement("button", _extends__default["default"]({
    type: "button",
    "aria-selected": active,
    ref: ref,
    className: classes,
    role: "tab"
  }, customProps), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "mdc-tab__content"
  }, icon && TabIcon(icon, label), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "mdc-tab__text-label"
  }, children), indicatorSize === 'content' && /*#__PURE__*/React__default["default"].createElement(TabIndicator, {
    active: active,
    icon: indicatorIcon,
    transition: indicatorTransition
  }, indicatorIcon), badge && !actualStacked && reactCommon.addProps(badge, {
    className: 'lmnt-tab-bar--notification-badge'
  })), indicatorSize === 'full' && /*#__PURE__*/React__default["default"].createElement(TabIndicator, {
    active: active,
    icon: indicatorIcon,
    transition: indicatorTransition
  }, indicatorIcon), /*#__PURE__*/React__default["default"].createElement("span", {
    className: "lmnt-tab___ripple mdc-tab__ripple"
  }));
});
Tab.displayName = 'Tab';
Tab.propTypes = TabPropTypes;
Tab.defaultProps = TabDefaultProps;

const TabBar$1 = /*#__PURE__*/React.forwardRef((props, externalRef) => {
  const {
    align,
    className,
    children,
    ...customProps
  } = props;
  const ref = React.useRef();
  const mdcTabBarScroller = React.useRef();
  React.useEffect(() => {
    mdcTabBarScroller.current = tabScroller.MDCTabScroller.attachTo(ref.current);
    return () => {
      mdcTabBarScroller.current.destroy();
    };
  }, [mdcTabBarScroller]);
  const classes = clsx__default["default"]('lmnt', 'lmnt-tab-scroller', 'mdc-tab-scroller', align === 'start' && 'mdc-tab-scroller--align-start', align === 'center' && 'mdc-tab-scroller--align-center', align === 'end' && 'mdc-tab-scroller--align-end', className);
  React.useImperativeHandle(externalRef, () => ref.current, []);
  return /*#__PURE__*/React__default["default"].createElement("div", _extends__default["default"]({
    className: classes,
    ref: ref
  }, customProps), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-tab-scroller__scroll-area"
  }, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "mdc-tab-scroller__scroll-content"
  }, children)));
});
TabBar$1.displayName = 'TabBar';
TabBar$1.propTypes = {
  align: PropTypes__default["default"].oneOf(['start', 'center', 'end']),
  className: PropTypes__default["default"].string,
  children: PropTypes__default["default"].oneOfType([PropTypes__default["default"].arrayOf(PropTypes__default["default"].node), PropTypes__default["default"].node])
};
TabBar$1.defaultProps = {
  align: 'start',
  className: undefined,
  children: undefined
};

const TabBar = /*#__PURE__*/React.forwardRef((props, externalRef) => {
  const {
    activeTabIndex,
    children,
    className,
    clusterAlign,
    clustered,
    elevated,
    onTabActivated,
    raised,
    scrollable,
    stacked,
    variant,
    ...customProps
  } = props;
  const ref = React.useRef();
  const mdcTabBar = React.useRef();
  React.useImperativeHandle(externalRef, () => ref.current, []);
  const handleTabActivation = React.useCallback(event => onTabActivated && onTabActivated(event.detail.index), [onTabActivated]);
  React.useEffect(() => {
    mdcTabBar.current = tabBar.MDCTabBar.attachTo(ref.current);
    mdcTabBar.current.unlisten('MDCTabBar:activated', handleTabActivation);
    mdcTabBar.current.listen('MDCTabBar:activated', handleTabActivation);
    return () => {
      mdcTabBar.current.unlisten('MDCTabBar:activated', handleTabActivation);
      mdcTabBar.current.destroy();
    };
  }, [children, mdcTabBar, handleTabActivation]);
  React.useEffect(() => {
    mdcTabBar.current.activateTab(activeTabIndex);
  }, [mdcTabBar, activeTabIndex]);
  const classes = clsx__default["default"]('lmnt', 'lmnt-tab-bar', 'mdc-tab-bar', raised && !scrollable && 'mdc-tab-bar--raised', elevated && 'mdc-tab-bar--elevated', variant === 'primary' && 'mdc-tab-bar--primary', variant === 'secondary' && 'mdc-tab-bar--secondary', variant === 'surface' && 'mdc-tab-bar--surface', className);
  const value = React.useMemo(() => ({
    stacked,
    clustered
  }), [stacked, clustered]);
  return /*#__PURE__*/React__default["default"].createElement(TabsContext.Provider, {
    value: value
  }, /*#__PURE__*/React__default["default"].createElement("div", _extends__default["default"]({
    className: classes,
    role: "tablist",
    ref: ref
  }, customProps), /*#__PURE__*/React__default["default"].createElement(TabBar$1, {
    align: clusterAlign
  }, children)));
});
TabBar.displayName = 'TabBar';
TabBar.propTypes = TabBarPropTypes;
TabBar.defaultProps = TabBarDefaultProps;
TabBar.displayName = 'TabBar';

exports.Tab = Tab;
exports.TabBar = TabBar;
exports.TabIndicator = TabIndicator;
exports.TabScroller = TabBar$1;
exports.Tabs = TabBar;
exports.TabsContext = TabsContext;
//# sourceMappingURL=index.js.map
