import _extends from '@babel/runtime-corejs3/helpers/extends';
import { MDCTab } from '@material/tab';
import clsx from 'clsx';
import React, { forwardRef, useRef, useEffect, useImperativeHandle, createContext, useContext, useCallback, useMemo } from 'react';
import { deprecatedProp, addProps } from '@element/react-common';
import { Icon } from '@element/react-icon';
import PropTypes from 'prop-types';
import { MDCTabIndicator } from '@material/tab-indicator';
import { MDCTabBar } from '@material/tab-bar';
import { MDCTabScroller } from '@material/tab-scroller';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TabBarPropTypes = {
  /**
   * Index of the currently active tab.
   *
   * Defaults to **0**.
   */
  activeTabIndex: PropTypes.number,
  /**
   * Accepts one or more Tab components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Clustered tabs can be aligned to 'start', 'center', or 'end'. Requires one or more tabs to have clustered set to true.
   *
   * Defaults to **'start'**.
   */
  clusterAlign: PropTypes.oneOf(["start", "center", "end"]),
  /**
   * Indicates that tabs should shrink in size to be as narrow as possible without causing text to wrap.
   *
   * Defaults to **false**.
   */
  clustered: PropTypes.bool,
  /**
   * Apply elevated styles to raise the tab-bar above standard content.
   *
   * Defaults to **false**.
   */
  elevated: PropTypes.bool,
  /**
   * Fires when switching to a different tab.
   *
   * Defaults to **null**.
   */
  onTabActivated: PropTypes.func,
  /**
   * @deprecated _Please use elevated instead._
   *
   *  Apply a raised style.
   *
   * Defaults to **undefined**.
   */
  raised: deprecatedProp(PropTypes.bool, "TabBar", "Please use elevated instead."),
  /**
   * @deprecated _Deprecated, containers will scroll when necessary._
   *
   * Create a fixed height scrollable container.
   *
   * Defaults to **undefined**.
   */
  scrollable: deprecatedProp(PropTypes.bool, "TabBar", "Deprecated, containers will scroll when necessary."),
  /**
   * Indicates that the tab icon and label should flow vertically instead of horizontally.
   *
   * Defaults to **false**.
   */
  stacked: PropTypes.bool,
  /**
   * Background theme color. Accepts one of 'primary', 'secondary', or 'surface'.
   *
   * Defaults to **'surface'**.
   */
  variant: PropTypes.oneOf(["primary", "secondary", "surface"])
};
const TabBarDefaultProps = {
  activeTabIndex: 0,
  children: null,
  className: undefined,
  clusterAlign: "start",
  clustered: false,
  elevated: false,
  raised: undefined,
  scrollable: undefined,
  stacked: false,
  variant: "surface"
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TabPropTypes = {
  /**
   * Indicates that the tab is active.
   *
   * Defaults to **undefined**.
   */
  active: PropTypes.bool,
  /**
   * The custom tab notification badge to be rendered.
   *
   * Defaults to **undefined**.
   */
  badge: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.node]),
  /**
   * The displayed content. Expects a valid string, though will accept any valid components or markup. If label and `children` are both set, `label` will take priority.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Indicates that the tab should shrink in size to be as narrow as possible without causing text to wrap.
   *
   * Defaults to **false**.
   */
  clustered: PropTypes.bool,
  /**
   * Add a leading icon to the tab.
   *
   * Defaults to **undefined**.
   */
  icon: PropTypes.node,
  /**
   * An icon to be used as the tab indicator. Accepts the name of any valid material icon (see Icon component documentation for a list of valid icons). If no icon is provided the tab-indicator will use an underline.
   *
   * Defaults to **null**.
   */
  indicatorIcon: PropTypes.string,
  /**
   * The tab-indicator will span the entire tab with 'full' or only the content of the tab with 'content'.
   *
   * Defaults to **'full'**.
   */
  indicatorSize: PropTypes.oneOf(["full", "content"]),
  /**
   * The tab-indicator will use a 'slide' or 'fade' transition between tabs.
   *
   * Defaults to **'slide'**.
   */
  indicatorTransition: PropTypes.oneOf(["slide", "fade"]),
  /**
   * The displayed text. Expects a valid string. If label and `children` are both set, `label` will take priority.
   *
   * Defaults to **null**.
   */
  label: PropTypes.node,
  /**
   * Indicates that the tab icon and label should flow vertically instead of horizontally. If stacked is true the tab will not show a badge.  You can place the badge on the leading icon.
   *
   * Defaults to **false**.
   */
  stacked: PropTypes.bool
};
const TabDefaultProps = {
  active: undefined,
  badge: undefined,
  children: null,
  className: undefined,
  clustered: false,
  icon: undefined,
  indicatorIcon: null,
  indicatorSize: "full",
  indicatorTransition: "slide",
  label: null,
  stacked: false
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Visually activates the indicator.
   *
   * Defaults to **false**.
   */
  active: PropTypes.bool,
  /**
   * The tab-indicator will use an underline if no icon is provided.
   *
   * Defaults to **null**.
   */
  icon: PropTypes.string,
  /**
   * The Tab Indicator will use a 'slide' or 'fade' transition between tabs.
   *
   * Defaults to **'slide'**.
   */
  transition: PropTypes.string
});

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

({
  /**
   * Clustered tabs can be aligned to 'start', 'center', or 'end'.
   *
   * Defaults to **'start'**.
   */
  align: PropTypes.oneOf(["start", "center", "end"]),
  /**
   * Accepts Tab components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
});

const TabIndicator = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    active,
    className,
    icon,
    id,
    transition,
    ...customProps
  } = props;
  const ref = useRef();
  const mdcTabIndicator = useRef();
  const classes = clsx('lmnt', 'lmnt-tab-indicator', 'mdc-tab-indicator', active && 'mdc-tab-indicator--active', transition === 'fade' && 'mdc-tab-indicator--fade', className);
  useEffect(() => {
    mdcTabIndicator.current = MDCTabIndicator.attachTo(ref.current);
    return () => {
      mdcTabIndicator.current.destroy();
    };
  }, [mdcTabIndicator]);
  useImperativeHandle(externalRef, () => ref.current, []);
  return /*#__PURE__*/React.createElement("span", _extends({
    id: id,
    className: classes,
    ref: ref
  }, customProps), icon && /*#__PURE__*/React.createElement("span", {
    className: "mdc-tab-indicator__content mdc-tab-indicator__content--icon material-icons",
    "aria-hidden": "true"
  }, icon), !icon && /*#__PURE__*/React.createElement("span", {
    className: "mdc-tab-indicator__content mdc-tab-indicator__content--underline"
  }));
});
TabIndicator.displayName = 'TabIndicator';
TabIndicator.propTypes = {
  active: PropTypes.bool,
  className: PropTypes.string,
  icon: PropTypes.string,
  id: PropTypes.string,
  transition: PropTypes.oneOf(['fade', 'slide'])
};
TabIndicator.defaultProps = {
  active: false,
  className: null,
  icon: null,
  id: null,
  transition: 'slide'
};

const TabsContext = /*#__PURE__*/createContext({});

const TabIcon = (icon, label) => {
  if (!icon) return undefined;
  if (typeof icon === 'string') {
    return /*#__PURE__*/React.createElement(Icon, {
      tabIndex: 0,
      role: "button",
      className: "mdc-tab__icon",
      ariaHidden: true,
      ariaLabel: label,
      icon: icon
    });
  }
  return addProps(icon, {
    className: 'mdc-tab__icon',
    tabIndex: 0,
    'aria-hidden': true,
    'aria-label': label,
    role: 'button'
  });
};
const Tab = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    active,
    badge,
    children,
    className,
    clustered,
    icon,
    indicatorIcon,
    indicatorSize,
    indicatorTransition,
    label,
    stacked,
    ...customProps
  } = props;
  const ref = useRef();
  const mdcTab = useRef();
  useImperativeHandle(externalRef, () => ref.current, []);
  const tabsContext = useContext(TabsContext);
  const actualStacked = tabsContext.stacked || stacked;
  const actualClustered = tabsContext.clustered || clustered;
  useEffect(() => {
    mdcTab.current = MDCTab.attachTo(ref.current);
    return () => {
      mdcTab.current.destroy();
    };
  }, []);
  const classes = clsx('lmnt', 'lmnt-tab', 'mdc-tab', 'mdc-button', active && 'mdc-tab--active', actualClustered && 'mdc-tab--min-width', actualStacked && 'mdc-tab--stacked', className);
  return /*#__PURE__*/React.createElement("button", _extends({
    type: "button",
    "aria-selected": active,
    ref: ref,
    className: classes,
    role: "tab"
  }, customProps), /*#__PURE__*/React.createElement("span", {
    className: "mdc-tab__content"
  }, icon && TabIcon(icon, label), /*#__PURE__*/React.createElement("span", {
    className: "mdc-tab__text-label"
  }, children), indicatorSize === 'content' && /*#__PURE__*/React.createElement(TabIndicator, {
    active: active,
    icon: indicatorIcon,
    transition: indicatorTransition
  }, indicatorIcon), badge && !actualStacked && addProps(badge, {
    className: 'lmnt-tab-bar--notification-badge'
  })), indicatorSize === 'full' && /*#__PURE__*/React.createElement(TabIndicator, {
    active: active,
    icon: indicatorIcon,
    transition: indicatorTransition
  }, indicatorIcon), /*#__PURE__*/React.createElement("span", {
    className: "lmnt-tab___ripple mdc-tab__ripple"
  }));
});
Tab.displayName = 'Tab';
Tab.propTypes = TabPropTypes;
Tab.defaultProps = TabDefaultProps;

const TabBar$1 = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    align,
    className,
    children,
    ...customProps
  } = props;
  const ref = useRef();
  const mdcTabBarScroller = useRef();
  useEffect(() => {
    mdcTabBarScroller.current = MDCTabScroller.attachTo(ref.current);
    return () => {
      mdcTabBarScroller.current.destroy();
    };
  }, [mdcTabBarScroller]);
  const classes = clsx('lmnt', 'lmnt-tab-scroller', 'mdc-tab-scroller', align === 'start' && 'mdc-tab-scroller--align-start', align === 'center' && 'mdc-tab-scroller--align-center', align === 'end' && 'mdc-tab-scroller--align-end', className);
  useImperativeHandle(externalRef, () => ref.current, []);
  return /*#__PURE__*/React.createElement("div", _extends({
    className: classes,
    ref: ref
  }, customProps), /*#__PURE__*/React.createElement("div", {
    className: "mdc-tab-scroller__scroll-area"
  }, /*#__PURE__*/React.createElement("div", {
    className: "mdc-tab-scroller__scroll-content"
  }, children)));
});
TabBar$1.displayName = 'TabBar';
TabBar$1.propTypes = {
  align: PropTypes.oneOf(['start', 'center', 'end']),
  className: PropTypes.string,
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node])
};
TabBar$1.defaultProps = {
  align: 'start',
  className: undefined,
  children: undefined
};

const TabBar = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    activeTabIndex,
    children,
    className,
    clusterAlign,
    clustered,
    elevated,
    onTabActivated,
    raised,
    scrollable,
    stacked,
    variant,
    ...customProps
  } = props;
  const ref = useRef();
  const mdcTabBar = useRef();
  useImperativeHandle(externalRef, () => ref.current, []);
  const handleTabActivation = useCallback(event => onTabActivated && onTabActivated(event.detail.index), [onTabActivated]);
  useEffect(() => {
    mdcTabBar.current = MDCTabBar.attachTo(ref.current);
    mdcTabBar.current.unlisten('MDCTabBar:activated', handleTabActivation);
    mdcTabBar.current.listen('MDCTabBar:activated', handleTabActivation);
    return () => {
      mdcTabBar.current.unlisten('MDCTabBar:activated', handleTabActivation);
      mdcTabBar.current.destroy();
    };
  }, [children, mdcTabBar, handleTabActivation]);
  useEffect(() => {
    mdcTabBar.current.activateTab(activeTabIndex);
  }, [mdcTabBar, activeTabIndex]);
  const classes = clsx('lmnt', 'lmnt-tab-bar', 'mdc-tab-bar', raised && !scrollable && 'mdc-tab-bar--raised', elevated && 'mdc-tab-bar--elevated', variant === 'primary' && 'mdc-tab-bar--primary', variant === 'secondary' && 'mdc-tab-bar--secondary', variant === 'surface' && 'mdc-tab-bar--surface', className);
  const value = useMemo(() => ({
    stacked,
    clustered
  }), [stacked, clustered]);
  return /*#__PURE__*/React.createElement(TabsContext.Provider, {
    value: value
  }, /*#__PURE__*/React.createElement("div", _extends({
    className: classes,
    role: "tablist",
    ref: ref
  }, customProps), /*#__PURE__*/React.createElement(TabBar$1, {
    align: clusterAlign
  }, children)));
});
TabBar.displayName = 'TabBar';
TabBar.propTypes = TabBarPropTypes;
TabBar.defaultProps = TabBarDefaultProps;
TabBar.displayName = 'TabBar';

export { Tab, TabBar, TabIndicator, TabBar$1 as TabScroller, TabBar as Tabs, TabsContext };
//# sourceMappingURL=index.es.js.map
