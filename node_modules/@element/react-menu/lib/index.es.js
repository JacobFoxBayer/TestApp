import _extends from '@babel/runtime-corejs3/helpers/extends';
import { MDCMenu, Corner } from '@material/menu';
import { CornerBit, MDCMenuSurface } from '@material/menu-surface';
import clsx from 'clsx';
import React, { forwardRef, createContext, useState, useRef, useImperativeHandle, useCallback, useEffect, useMemo } from 'react';
import { edsRandomId, ConditionalWrapper } from '@element/react-common';
import { Portal } from '@element/react-portal';
import PropTypes from 'prop-types';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const MenuPropTypes = {
  /**
   * The horizontal position of the menu, when visible. The menu surface will be hoisted to the body of the DOM. This should only be used when the menu needs to be explicitly positioned and cannot be combined with MenuAnchor.
   *
   * Defaults to **null**.
   */
  absolutePositionX: PropTypes.number,
  /**
   * The vertical position of the menu, when visible. The menu surface will be hoisted to the body of the DOM. This should only be used when the menu needs to be explicitly positioned and cannot be combined with MenuAnchor.
   *
   * Defaults to **null**.
   */
  absolutePositionY: PropTypes.number,
  /**
   * Sets the display position of the menu relative to the parent element. It must be used with Menu Anchor.
   *
   * Defaults to **'BOTTOM_START'**.
   */
  anchorCorner: PropTypes.oneOf(["TOP_LEFT", "TOP_RIGHT", "BOTTOM_LEFT", "BOTTOM_RIGHT", "TOP_START", "TOP_END", "BOTTOM_START", "BOTTOM_END"]),
  /**
   * Sets the distance from the anchor point that the menu surface should be shown.  The object properties should include at least one of `top`, `bottom`, `left` or `right`.
   *
   * Defaults to **null**.
   */
  anchorMargin: PropTypes.object,
  /**
   * Custom props to be sent to the MenuAnchor wrapper of the `trigger`
   *
   * Defaults to **{}**.
   */
  anchorProps: PropTypes.object,
  /**
   * Expects a List or ListGroup component but accepts any valid markup or components.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node,
  /**
   * Sets the direction property for the menu. For right to left languages use `rtl`.
   *
   * Defaults to **'ltr'**.
   */
  direction: PropTypes.oneOf(["ltr", "rtl"]),
  /**
   * Prevents the use of absolute position (x/y) props.
   *
   * Defaults to **false**.
   */
  fixed: PropTypes.bool,
  /**
   * Sets the width of the menu to the full width of the body. It is to be used with `hoistToBody`. Useful when creating navigation menus for mobile devices.
   *
   * Defaults to **false**.
   */
  fullScreen: PropTypes.bool,
  /**
   * Sets the width of the menu to the full width of the parent. Cannot be used with `hoistToBody` or when `absolutePositionY` or `absolutePositionY` is set.
   *
   * Defaults to **false**.
   */
  fullWidth: PropTypes.bool,
  /**
   * Fired when html body is clicked. Default behavior is to close the menu.
   *
   * Defaults to **null**.
   */
  handleBodyClick: PropTypes.func,
  /**
   * Enables the menu to be rendered as part of the body, enables higher z-index. Requires `surfaceOnly` to be true. This can improve menu to behavior better inside a table. Use with caution: may cause unintended side-effects.
   *
   * Defaults to **false**.
   */
  hoistToBody: PropTypes.bool,
  /**
   * Sets the max height of the menu.
   *
   * Defaults to **275**.
   */
  maxHeight: PropTypes.number,
  /**
   * Fired after the menu surface is closed. For best performance, this method should be memoized or wrapped with useCallback.
   *
   * Defaults to **null**.
   */
  onClose: PropTypes.func,
  /**
   * Fired after the menu surface is opened. For best performance, this method should be memoized or wrapped with useCallback.
   *
   * Defaults to **null**.
   */
  onOpen: PropTypes.func,
  /**
   * Fired when a menu item is selected . It is not available if `surfaceOnly` is true. For best performance, this method should be memoized or wrapped with useCallback.
   *
   * Defaults to **null**.
   */
  onSelect: PropTypes.func,
  /**
   * Controls the visibility of the menu.
   *
   * Defaults to **false**.
   */
  open: PropTypes.bool,
  /**
   * Passthrough style object.
   *
   * Defaults to **null**.
   */
  style: PropTypes.object,
  /**
   * Renders as just the menu surface. While Menu expects a list of items, when surfaceOnly is true any content can go inside the menu.
   *
   * Defaults to **false**.
   */
  surfaceOnly: PropTypes.bool,
  /**
   * Background color of the menu.
   *
   * Defaults to **'surface'**.
   */
  themeColor: PropTypes.oneOf(["surface", "primary", "secondary"]),
  /**
   * Node used to trigger open the menu or menu surface. Will also serve as the anchor.
   *
   * Defaults to **null**.
   */
  trigger: PropTypes.node,
  /**
   * When used with a List component `wrapFocus` allows keyboard navigation to jump to the top or bottom of the list to enable continuous navigation.
   *
   * Defaults to **true**.
   */
  wrapFocus: PropTypes.bool
};
const MenuDefaultProps = {
  absolutePositionX: null,
  absolutePositionY: null,
  anchorCorner: "BOTTOM_START",
  anchorMargin: null,
  anchorProps: {},
  children: null,
  direction: "ltr",
  fixed: false,
  fullScreen: false,
  fullWidth: false,
  hoistToBody: false,
  maxHeight: 275,
  open: false,
  style: null,
  surfaceOnly: false,
  themeColor: "surface",
  trigger: null,
  wrapFocus: true
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const MenuAnchorPropTypes = {
  /**
   * Expects a clickable component such as Button or IconButton and the Menu component.
   *
   * Defaults to **null**.
   */
  children: PropTypes.node
};
const MenuAnchorDefaultProps = {
  children: null
};

const MenuAnchor = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    children,
    className,
    ...customProps
  } = props;
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: ref,
    className: clsx('lmnt', 'mdc-menu-surface--anchor', className)
  }, customProps), children);
});
MenuAnchor.displayName = 'MenuAnchor';
MenuAnchor.propTypes = MenuAnchorPropTypes;
MenuAnchor.defaultProps = MenuAnchorDefaultProps;

const MenuContext = /*#__PURE__*/createContext({});

const triggerWrapper = (anchorProps, trigger, anchorRef) => children => /*#__PURE__*/React.createElement(MenuAnchor, _extends({}, anchorProps, {
  ref: anchorRef
}), trigger, children);
const portalWrapper = hoistToBody => children => /*#__PURE__*/React.createElement(Portal, {
  disabled: !hoistToBody
}, children);
const Menu = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    absolutePositionX,
    absolutePositionY,
    anchorCorner,
    anchorMargin,
    anchorProps,
    children,
    className,
    direction,
    fixed,
    fullScreen,
    fullWidth,
    handleBodyClick,
    hoistToBody,
    iconMenu,
    id,
    maxHeight,
    onClose,
    onOpen,
    onSelect,
    open,
    quickOpen,
    style,
    surfaceOnly,
    themeColor,
    trigger,
    unexposed,
    wrapFocus,
    ...customProps
  } = props;
  const [idActual] = useState(() => id || edsRandomId());
  const [openUp, setOpenUp] = useState();
  const ref = useRef();
  const mdcMenu = useRef();
  const anchorRef = useRef();
  useImperativeHandle(externalRef, () => ref.current, []);
  const handleOnOpen = useCallback(e => {
    const corner = surfaceOnly ? mdcMenu.current.foundation.getoriginCorner() : mdcMenu.current.menuSurface_.foundation.getoriginCorner();
    const verticalAlignment = surfaceOnly && mdcMenu.current.foundation.hasBit(corner, CornerBit.BOTTOM) || !surfaceOnly && mdcMenu.current.menuSurface_.foundation.hasBit(corner, CornerBit.BOTTOM) ? 'bottom' : 'top';
    setOpenUp(verticalAlignment === 'bottom');
    onOpen && onOpen(e);
  }, [onOpen, surfaceOnly]);
  const handleSelect = useCallback(e => {
    onSelect && onSelect(e.detail);
  }, [onSelect]);
  useEffect(() => {
    mdcMenu.current = surfaceOnly ? MDCMenuSurface.attachTo(ref.current) : MDCMenu.attachTo(ref.current);
    return () => {
      mdcMenu.current.destroy();
    };
  }, [surfaceOnly]);
  useEffect(() => {
    if (!surfaceOnly) {
      mdcMenu.current.listen('MDCMenu:selected', handleSelect);
    }
    return () => {
      if (!surfaceOnly) {
        mdcMenu.current.unlisten('MDCMenu:selected', handleSelect);
      }
    };
  }, [handleSelect, surfaceOnly]);
  useEffect(() => {
    mdcMenu.current.listen('MDCMenuSurface:closed', onClose);
    return () => {
      mdcMenu.current.unlisten('MDCMenuSurface:closed', onClose);
    };
  }, [onClose]);
  useEffect(() => {
    mdcMenu.current.listen('MDCMenuSurface:opened', handleOnOpen);
    return () => {
      mdcMenu.current.unlisten('MDCMenuSurface:opened', handleOnOpen);
    };
  }, [handleOnOpen]);
  useEffect(() => {
    if (!surfaceOnly) {
      mdcMenu.current.menuSurface_.foundation.setMaxHeight(maxHeight);
    } else {
      mdcMenu.current.foundation.setMaxHeight(maxHeight);
    }
  }, [maxHeight, surfaceOnly]);
  useEffect(() => {
    if (anchorMargin) {
      if (!surfaceOnly) {
        mdcMenu.current.menuSurface_.foundation.setAnchorMargin(anchorMargin);
      } else {
        mdcMenu.current.foundation.setAnchorMargin(anchorMargin);
      }
    }
  }, [anchorMargin, surfaceOnly]);
  useEffect(() => {
    if (handleBodyClick) {
      mdcMenu.current.handleBodyClick = handleBodyClick;
    }
  }, [handleBodyClick]);
  useEffect(() => {
    if (!fixed && absolutePositionX && absolutePositionX > -1 || !fixed && absolutePositionY && absolutePositionY > -1) {
      mdcMenu.current.setAbsolutePosition(absolutePositionX, absolutePositionY);
      if (mdcMenu.current.foundation.getAutoLayoutmeasurements().surfaceSize) {
        mdcMenu.current.foundation.autoposition();
      }
    }
  }, [absolutePositionX, absolutePositionY, fixed]);
  useEffect(() => {
    mdcMenu.current.setFixedPosition(fixed);
  }, [fixed]);
  useEffect(() => {
    mdcMenu.current.wrapFocus = wrapFocus;
  }, [wrapFocus]);
  useEffect(() => {
    if (anchorCorner && !(absolutePositionX || absolutePositionY)) {
      mdcMenu.current.setAnchorCorner(Corner[anchorCorner.toUpperCase()]);
    }
  }, [mdcMenu, anchorCorner, absolutePositionX, absolutePositionY]);
  useEffect(() => {
    mdcMenu.current.setIsHoisted(hoistToBody);
    if (surfaceOnly) {
      mdcMenu.current.setMenuSurfaceAnchorElement(anchorRef.current);
    } else {
      mdcMenu.current.setAnchorElement(anchorRef.current);
    }
  }, [hoistToBody, surfaceOnly, trigger]);
  useEffect(() => {
    mdcMenu.current.quickOpen = quickOpen;
  }, [quickOpen]);
  useEffect(() => {
    // State is controlled both above and below this component
    // The only time we want to update MDC state is when `open` is true.
    // Updating when `open` is false fires too many `closed` events
    if (open) {
      if (!surfaceOnly && !mdcMenu.current.open) {
        mdcMenu.current.open = open;
      } else if (!mdcMenu.current.foundation.isSurfaceOpen) {
        mdcMenu.current.open();
      }
    } else if (!surfaceOnly && mdcMenu.current.open) {
      mdcMenu.current.open = false;
    } else if (mdcMenu.current.foundation.isSurfaceOpen) {
      mdcMenu.current.close();
    }
  }, [mdcMenu, open, surfaceOnly]);
  const value = useMemo(() => ({
    inMenu: true
  }), []);
  const classes = useMemo(() => {
    var _mdcMenu$current, _mdcMenu$current2;
    return clsx('lmnt', 'mdc-menu-surface', 'lmnt-menu-container', (surfaceOnly && ((_mdcMenu$current = mdcMenu.current) === null || _mdcMenu$current === void 0 ? void 0 : _mdcMenu$current.foundation.isOpen()) || !surfaceOnly && ((_mdcMenu$current2 = mdcMenu.current) === null || _mdcMenu$current2 === void 0 ? void 0 : _mdcMenu$current2.menuSurface_.foundation.isOpen())) && 'mdc-menu-surface--open', openUp && 'lmnt-menu-open-up', !surfaceOnly && 'mdc-menu', !hoistToBody && fullWidth && 'mdc-menu-surface--fullwidth', hoistToBody && fullScreen && 'lmnt-menu-surface--fullScreen', `lmnt-theme-${themeColor}-bg`, className);
  }, [className, fullScreen, fullWidth, hoistToBody, openUp, surfaceOnly, themeColor]);
  const createTriggerWrapper = useMemo(() => triggerWrapper(anchorProps, trigger, anchorRef), [anchorProps, trigger]);
  const createPortalWrapper = useMemo(() => portalWrapper(hoistToBody), [hoistToBody]);
  const styles = useMemo(() => ({
    ...style,
    direction
  }), [style, direction]);
  return /*#__PURE__*/React.createElement(ConditionalWrapper, {
    condition: trigger,
    wrapper: createTriggerWrapper
  }, /*#__PURE__*/React.createElement(ConditionalWrapper, {
    condition: hoistToBody,
    wrapper: createPortalWrapper
  }, /*#__PURE__*/React.createElement("div", _extends({
    ref: ref,
    id: idActual,
    style: styles,
    className: classes,
    tabIndex: "-1"
  }, customProps), /*#__PURE__*/React.createElement(MenuContext.Provider, {
    value: value
  }, children))));
});
Menu.displayName = 'Menu';
Menu.propTypes = MenuPropTypes;
Menu.defaultProps = MenuDefaultProps;

export { Menu, MenuAnchor, MenuContext };
//# sourceMappingURL=index.es.js.map
