import _extends from '@babel/runtime-corejs3/helpers/extends';
import { MDCTextField, MDCTextFieldHelperText } from '@material/textfield';
import clsx from 'clsx';
import { deprecatedProp, requiredIfPropType, addProps } from '@element/react-common';
import React, { forwardRef, useState, useRef, useMemo, useEffect, useImperativeHandle, useCallback } from 'react';
import { FloatingLabel } from '@element/react-floating-label';
import { LineRipple } from '@element/react-line-ripple';
import { Icon } from '@element/react-icon';
import { NotchedOutline } from '@element/react-notched-outline';
import { TooltipText } from '@element/react-tooltip';
import { edsRandomId } from '@element/shared';
import { createPopper } from '@popperjs/core';
import PropTypes from 'prop-types';

// NOTE: SpanShim simplifies the ternary for textfield input/textarea tag
// If wrap={!noResize && textarea}, a resizer span is wrapped around the textarea.
// Otherwise, the textarea/input is rendered without the added span and class
const TextfieldSpanShim = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    wrap,
    children
  } = props;
  return wrap ? /*#__PURE__*/React.createElement("span", {
    ref: externalRef,
    className: "mdc-text-field__resizer"
  }, children) : children;
});
TextfieldSpanShim.displayName = 'TextfieldSpanShim';
TextfieldSpanShim.propTypes = {
  children: PropTypes.node,
  wrap: PropTypes.bool
};
TextfieldSpanShim.defaultProps = {
  children: undefined,
  wrap: false
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TextfieldPropTypes = {
  /**
   * @deprecated _Use `fullWidth` instead._
   *
   * Applies a full-width style where the Textfield will fill its container.
   *
   * Defaults to **undefined**.
   */
  block: deprecatedProp(PropTypes.bool, "Textfield", "Use `fullWidth` instead."),
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * @deprecated _See `containerProps`._
   *
   * Add a custom class to the `Textfield` container.
   *
   * Defaults to **undefined**.
   */
  containerClass: deprecatedProp(PropTypes.string, "Textfield", "See `containerProps`."),
  /**
   * Properties to be added to the container of the textfield.
   *
   * Defaults to **undefined**.
   */
  containerProps: PropTypes.object,
  /**
   * Enables a character count. _Warning_ requires `maxlength` to be set.
   *
   * Defaults to **false**.
   */
  counter: PropTypes.bool,
  /**
   * The starting value of the Textfield when working in uncontrolled mode.
   *
   * Defaults to **undefined**.
   */
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /**
   * The size of the Textfield will be reduced.
   *
   * Defaults to **false**.
   */
  dense: PropTypes.bool,
  /**
   * Textfield will be disabled.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * @deprecated _Use `variant='embedded'_
   *
   * An unfilled, non-outlined and full-width variant of Textfield, intended to be embedded in other components such as TopAppBar or TableHeader.
   *
   * Defaults to **undefined**.
   */
  embedded: deprecatedProp(PropTypes.bool, "Textfield", 'Use `variant="embedded"'),
  /**
   * @deprecated _Use variant='filled' instead._
   *
   * Apply filled style to the Textfield. Previously called primary.
   *
   * Defaults to **undefined**.
   */
  filled: deprecatedProp(PropTypes.bool, "Textfield", 'Use variant="filled" instead.'),
  /**
   * Sets the Textfield to the focused state.
   *
   * Defaults to **false**.
   */
  focused: PropTypes.bool,
  /**
   * The Textfield will expand to 100% width.
   *
   * Defaults to **false**.
   */
  fullWidth: PropTypes.bool,
  /**
   * Helper text to be displayed below Textfield, by default only visible on focus.
   *
   * Defaults to **null**.
   */
  helperText: PropTypes.node,
  /**
   * Randomly generated id for the helper text container element. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  helperTextId: PropTypes.string,
  /**
   * Set the helper text to be permanently visible.
   *
   * Defaults to **false**.
   */
  helperTextPersistent: PropTypes.bool,
  /**
   * Set the helper text to use validation styles. Helper text changes with `valid` (e.g., helper text will appear red when `valid` is set to 'false').
   *
   * Defaults to **false**.
   */
  helperTextValidation: PropTypes.bool,
  /**
   * Randomly generated id for the input element. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * Floating input label. Note: full-width Textfields do not support floating labels - any label on a full-width Textfield will be automatically mapped to a placeholder.
   *
   * Defaults to **null**.
   */
  label: PropTypes.string,
  /**
   * Randomly generated id for the label element. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  labelId: PropTypes.string,
  /**
   * Custom content to appear before the input.
   *
   * Defaults to **null**.
   */
  leadingContent: PropTypes.node,
  /**
   * Adds the given Icon or Icon Button to the left of the Textfield. Expects the name of a valid Material.io icon, however in React an icon or icon button component may be passed in instead for more control,
   *
   * Defaults to **null**.
   */
  leadingIcon: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * @deprecated _Use `maxlength` instead. The case of this prop has changed to be more consistent._
   *
   * Restricts the number of characters that can be entered, best used with counter.
   *
   * Defaults to **undefined**.
   */
  maxLength: deprecatedProp(PropTypes.number, "Textfield", "Use `maxlength` instead. The case of this prop has changed to be more consistent."),
  /**
   * Restricts the number of characters that can be entered, best used with counter.
   *
   * Defaults to **null**.
   */
  maxlength: requiredIfPropType(PropTypes.number, "Textfield", "counter"),
  /**
   * Prevents resizing when using `textarea`.
   *
   * Defaults to **true**.
   */
  noResize: PropTypes.bool,
  /**
   * Fired when focus leaves the input.
   *
   * Defaults to **null**.
   */
  onBlur: PropTypes.func,
  /**
   * Fired when each character is entered into the Textfield.
   *
   * Defaults to **null**.
   */
  onChange: PropTypes.func,
  /**
   * Fired when the input gains focus.
   *
   * Defaults to **null**.
   */
  onFocus: PropTypes.func,
  /**
   * @deprecated _Use `variant='outlined'` instead_
   *
   * Apply outlined style to the Textfield. Previously called secondary.
   *
   * Defaults to **undefined**.
   */
  outlined: deprecatedProp(PropTypes.bool, "Textfield", 'Use `variant="outlined"` instead'),
  /**
   * Non-floating label text, will be replaced when the user starts typing.
   *
   * Defaults to **null**.
   */
  placeholder: PropTypes.string,
  /**
   * Text that will appear before the label or value of the Textfield. It will be shown on focus. An example use-case might be a currency symbol such as `$`. _Warning:_ This cannot be used with `leadingIcon` or `textarea`.
   *
   * Defaults to **null**.
   */
  prefixText: PropTypes.string,
  /**
   * @deprecated _This feature is no longer supported. Use `variant='filled'` instead._
   *
   * Enable filled styling.
   *
   * Defaults to **undefined**.
   */
  primary: deprecatedProp(PropTypes.bool, "Textfield", 'This feature is no longer supported. Use `variant="filled"` instead.'),
  /**
   * @deprecated _Use `variant='embedded'`_
   *
   * Enabled search bar styling, including a full width style.
   *
   * Defaults to **undefined**.
   */
  search: deprecatedProp(PropTypes.bool, "Textfield", 'Use `variant="embedded"`'),
  /**
   * @deprecated _Use `variant='outlined'` instead._
   *
   * Apply secondary style to the Textfield.
   *
   * Defaults to **undefined**.
   */
  secondary: deprecatedProp(PropTypes.bool, "Textfield", 'Use `variant="outlined"` instead.'),
  /**
   * Text that will appear after the label or value of the Textfield. It will be shown on focus. An example use-case might be `.00` if handling currency. _Warning:_ This cannot be used with `trailingIcon` or `textarea`.
   *
   * Defaults to **null**.
   */
  suffixText: PropTypes.string,
  /**
   * Enabled multi-line text input. _Note_ `textarea` cannot be used with the embedded variant.
   *
   * Defaults to **false**.
   */
  textarea: PropTypes.bool,
  /**
   * If defined, a Tooltip will appear on the Textfield. Useful to show the full value, if the value is too long for the Textfield width. The object should be the needed Tooltip properties. Tooltip `text` prop will be set to the current value of the Textfield.  See Tooltip docs for available props.
   *
   * Defaults to **null**.
   */
  tooltip: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),
  /**
   * Custom content to appear after the input.
   *
   * Defaults to **null**.
   */
  trailingContent: PropTypes.node,
  /**
   * Adds the given Icon or Icon Button  to the right of the Textfield . Expects the name of a valid Material.io icon, however in React an icon icon button component may be passed in instead for more control.
   *
   * Defaults to **null**.
   */
  trailingIcon: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * Support for built-in input types. Browser support for some advanced types such as color or date may be limited or appear differently between browsers. _Note_  the `Datepicker` component should be preferred over the built-in date/time types as it offers more consistency and features._Note_ Slider type is not support, please use the Element `Slider` component instead.
   *
   * Defaults to **'text'**.
   */
  type: PropTypes.oneOf(["text", "password", "color", "email", "url", "number", "tel", "search", "datetime-local", "month", "time", "week", "date"]),
  /**
   * Applies an invalid style to the Textfield.
   *
   * Defaults to **true**.
   */
  valid: PropTypes.bool,
  /**
   * The current value of the Textfield component.
   *
   * Defaults to **undefined**.
   */
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /**
   * Applies the selected styling to the Textfield. _Note_ `textarea` does not support the `embedded` variant.
   *
   * Defaults to **'filled'**.
   */
  variant: PropTypes.oneOf(["filled", "outlined", "embedded"])
};
const TextfieldDefaultProps = {
  block: undefined,
  className: undefined,
  containerClass: undefined,
  containerProps: undefined,
  counter: false,
  defaultValue: undefined,
  dense: false,
  disabled: false,
  embedded: undefined,
  filled: undefined,
  focused: false,
  fullWidth: false,
  helperText: null,
  helperTextId: undefined,
  helperTextPersistent: false,
  helperTextValidation: false,
  id: undefined,
  label: null,
  labelId: undefined,
  leadingContent: null,
  leadingIcon: null,
  maxLength: undefined,
  maxlength: null,
  noResize: true,
  outlined: undefined,
  placeholder: null,
  prefixText: null,
  primary: undefined,
  search: undefined,
  secondary: undefined,
  suffixText: null,
  textarea: false,
  tooltip: null,
  trailingContent: null,
  trailingIcon: null,
  type: "text",
  valid: true,
  value: undefined,
  variant: "filled"
};

const Counter = (hasCounter, currentMaxlength) => {
  if (hasCounter) {
    return /*#__PURE__*/React.createElement("div", {
      className: "mdc-text-field-character-counter"
    }, "0 / ", currentMaxlength);
  }
  return null;
};
const LeadingIcon = leadingIcon => {
  const {
    type
  } = {
    ...leadingIcon
  };
  const {
    displayName
  } = {
    ...type
  };
  if (typeof leadingIcon === 'string') {
    return /*#__PURE__*/React.createElement(Icon, {
      role: "button",
      className: "mdc-text-field__icon lmnt-text-field__icon mdc-text-field__icon--leading",
      icon: leadingIcon
    });
  }
  return addProps(leadingIcon, {
    className: clsx('mdc-text-field__icon lmnt-text-field__icon mdc-text-field__icon--leading', displayName === 'IconButton' && 'lmnt-text-field__icon-button--leading'),
    dense: displayName === 'IconButton' ? true : undefined,
    role: 'button'
  });
};
const TrailingIcon = trailingIcon => {
  const {
    type
  } = {
    ...trailingIcon
  };
  const {
    displayName
  } = {
    ...type
  };
  if (typeof trailingIcon === 'string') {
    return /*#__PURE__*/React.createElement(Icon, {
      className: "mdc-text-field__icon lmnt-text-field__icon mdc-text-field__icon--trailing",
      icon: trailingIcon
    });
  }
  return addProps(trailingIcon, {
    className: clsx('mdc-text-field__icon lmnt-text-field__icon mdc-text-field__icon--trailing', displayName === 'IconButton' && 'lmnt-text-field__icon-button--trailing'),
    dense: displayName === 'IconButton' ? true : undefined,
    role: displayName === 'IconButton' ? 'button' : null
  });
};
const Textfield = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    block,
    className,
    containerClass,
    containerProps,
    containerStyle,
    counter,
    defaultValue,
    dense,
    disabled,
    embedded,
    filled,
    focused,
    fullWidth,
    helperText,
    helperTextId,
    helperTextPersistent,
    helperTextValidation,
    id,
    label,
    labelId,
    leadingContent,
    leadingIcon,
    maxLength,
    maxlength,
    noResize,
    onBlur,
    outlined,
    placeholder,
    prefixText,
    primary = null,
    search,
    secondary,
    suffixText,
    textarea,
    tooltip,
    trailingContent,
    trailingIcon,
    type,
    valid,
    value,
    variant,
    ...customProps
  } = props;
  const {
    hoisted,
    position = 'bottom'
  } = tooltip && typeof tooltip === 'object' ? tooltip : {};
  // TODO: some of the logic below will get simpler when v6 removes
  // deprecated properties
  const [idActual] = useState(() => id || edsRandomId());
  const [helperTextIdActual] = useState(() => helperTextId || edsRandomId());
  const [labelIdActual] = useState(() => labelId || edsRandomId());
  const [isBlockElement, setIsBlockElement] = useState(true);
  const [hasCounter, setHasCounter] = useState(false);
  const [currentMaxlength, setCurrentMaxlength] = useState(maxlength);
  const hasHelperLine = helperText || counter && currentMaxlength;
  const Tag = textarea ? 'textarea' : 'input';
  const ref = useRef();
  const helperTextDomRef = useRef();
  const helperTextRef = useRef();
  const mdcTextFieldRef = useRef();
  const labelRef = useRef();
  const inputRefActual = useRef();
  const containerRef = useRef();
  const tooltipRef = useRef();
  const popperRef = useRef();
  const hasIcon = (trailingIcon || leadingIcon) && !textarea;
  const isValid = useMemo(() => valid === undefined || valid === null ? true : valid, [valid]);
  const isEmbedded = !textarea && (embedded || search || variant === 'embedded');
  const isOutlined = !embedded && (outlined || secondary || variant === 'outlined');
  const isFilled = !isOutlined && !isEmbedded && (primary || filled || variant === 'filled');
  const isFullWidth = isEmbedded || fullWidth || block;
  const hasLabel = !isEmbedded && !!label && !dense;
  useEffect(() => {
    mdcTextFieldRef.current = MDCTextField.attachTo(labelRef.current);
    return () => {
      mdcTextFieldRef.current.destroy();
    };
  }, [hasCounter]);
  useImperativeHandle(externalRef, () => ({
    mdc: mdcTextFieldRef.current,
    input: inputRefActual.current,
    container: containerRef.current,
    label: labelRef.current
  }));

  // TODO: in testing, I removed this code and I could not reproduce the issue this originally solved - do we still need it?
  useEffect(() => {
    // HACK: this breaks when helperText is markup instead of string, so now we bypass it in that case
    if (helperText && typeof helperText === 'string') {
      helperTextRef.current = new MDCTextFieldHelperText(helperTextDomRef.current);
    }
    return () => {
      helperTextRef.current && helperTextRef.current.destroy();
    };
  }, [helperText]);
  useEffect(() => {
    if (helperText) {
      var _helperTextRef$curren, _helperTextRef$curren2, _helperTextRef$curren3, _helperTextRef$curren4;
      (_helperTextRef$curren = helperTextRef.current) === null || _helperTextRef$curren === void 0 ? void 0 : _helperTextRef$curren.foundation.setValidation(helperTextValidation);
      (_helperTextRef$curren2 = helperTextRef.current) === null || _helperTextRef$curren2 === void 0 ? void 0 : _helperTextRef$curren2.foundation.setValidity(isValid);
      (_helperTextRef$curren3 = helperTextRef.current) === null || _helperTextRef$curren3 === void 0 ? void 0 : _helperTextRef$curren3.foundation.setPersistent(helperTextPersistent);
      (_helperTextRef$curren4 = helperTextRef.current) === null || _helperTextRef$curren4 === void 0 ? void 0 : _helperTextRef$curren4.foundation.setContent(helperText);
    }
  }, [helperText, helperTextPersistent, helperTextValidation, isValid]);
  useEffect(() => {
    // NOTE: These value and valid need to be set together otherwise mcd will "forget" the valid state.
    if (!defaultValue) mdcTextFieldRef.current.value = value || value === 0 ? value : '';
    // NOTE: valid prop is undefined until user decides valid is true or false
    // with custom validation.
    mdcTextFieldRef.current.valid = isValid;
  }, [mdcTextFieldRef, value, isValid, defaultValue]);
  useEffect(() => {
    mdcTextFieldRef.current.disabled = disabled;
  }, [mdcTextFieldRef, disabled]);

  // TODO: This goes away in v6
  useEffect(() => {
    setCurrentMaxlength(maxLength && !maxlength ? maxLength : maxlength);
  }, [maxlength, maxLength]);
  useEffect(() => {
    setHasCounter(currentMaxlength > 0 && counter);
  }, [currentMaxlength, counter]);
  useEffect(() => {
    const isBlock = isFullWidth || counter || helperText;
    setIsBlockElement(isBlock);
  }, [isFullWidth, counter, helperText]);

  // NOTE: Ignoring testing on methods below. Testing library doesn't
  // recognize events. These methods do work when called outside of tests.
  /* istanbul ignore next */
  const handleValidState = () => {
    if (valid !== undefined && value !== null) {
      mdcTextFieldRef.current.valid = valid;
    }
  };

  /* istanbul ignore next */
  const handleBlur = event => {
    if (onBlur) onBlur(event);
    handleValidState();
  };
  const handleFormReset = () => {
    mdcTextFieldRef.current.value = '';
    mdcTextFieldRef.current.valid = isValid;
  };
  useEffect(() => {
    /* eslint-disable no-undef */
    window.addEventListener('reset', handleFormReset);
    return () => {
      window.removeEventListener('reset', handleFormReset);
    };
    /* eslint-enable no-undef */
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useEffect(() => {
    if (tooltip) {
      const modifiers = [{
        name: 'flip',
        options: {
          enabled: true,
          padding: {
            bottom: 32,
            top: 32
          }
        }
      }, {
        name: 'offset',
        options: {
          offset: [0, 12]
        }
      }];
      popperRef.current = createPopper(ref.current, tooltipRef.current, {
        placement: position,
        modifiers
      });
    }
    return () => {
      var _popperRef$current;
      (_popperRef$current = popperRef.current) === null || _popperRef$current === void 0 ? void 0 : _popperRef$current.destroy();
    };
  }, [position, hoisted, tooltip]);
  const showTooltip = useCallback(() => {
    if (value) {
      // eslint-disable-next-line no-underscore-dangle
      const input = mdcTextFieldRef.current.input_;
      if (input.offsetWidth < input.scrollWidth) {
        var _tooltipRef$current, _popperRef$current2, _popperRef$current3;
        (_tooltipRef$current = tooltipRef.current) === null || _tooltipRef$current === void 0 ? void 0 : _tooltipRef$current.setAttribute('data-show', '');
        (_popperRef$current2 = popperRef.current) === null || _popperRef$current2 === void 0 ? void 0 : _popperRef$current2.setOptions(options => ({
          ...options,
          modifiers: [...options.modifiers, {
            name: 'eventListeners',
            enabled: true
          }]
        }));
        (_popperRef$current3 = popperRef.current) === null || _popperRef$current3 === void 0 ? void 0 : _popperRef$current3.update();
      }
    }
  }, [value]);
  const hideTooltip = useCallback(() => {
    var _tooltipRef$current2, _popperRef$current4;
    (_tooltipRef$current2 = tooltipRef.current) === null || _tooltipRef$current2 === void 0 ? void 0 : _tooltipRef$current2.removeAttribute('data-show');
    (_popperRef$current4 = popperRef.current) === null || _popperRef$current4 === void 0 ? void 0 : _popperRef$current4.setOptions(options => ({
      ...options,
      modifiers: [...options.modifiers, {
        name: 'eventListeners',
        enabled: false
      }]
    }));
  }, []);
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: containerRef,
    style: containerStyle,
    className: clsx('lmnt', 'lmnt-text-field--container', isFullWidth && 'lmnt-text-field--container-full-width', !isFullWidth && isBlockElement && 'lmnt-text-field--container-to-content-width', !isBlockElement && 'lmnt-text-field-inline-container', containerClass)
  }, containerProps, {
    onMouseEnter: tooltip && showTooltip,
    onFocus: tooltip && showTooltip,
    onMouseLeave: tooltip && hideTooltip,
    onBlur: tooltip && hideTooltip
  }), leadingContent, /*#__PURE__*/React.createElement("label", {
    htmlFor: idActual,
    ref: labelRef,
    className: clsx(['lmnt', 'mdc-text-field', 'lmnt-text-field', isEmbedded && 'lmnt-text-field--embedded', isFullWidth && 'lmnt-text-field--full-width', hasIcon && 'lmnt-text-field--with-icon', !isValid && 'mdc-text-field--invalid', disabled && 'mdc-text-field--disabled', focused && 'mdc-text-field--focused', !hasLabel && 'mdc-text-field--no-label', leadingIcon && !textarea && 'mdc-text-field--with-leading-icon', textarea && 'mdc-text-field--textarea', textarea && counter && currentMaxlength && !noResize && 'mdc-text-field--with-internal-counter', trailingIcon && !textarea && 'mdc-text-field--with-trailing-icon', isFilled && 'mdc-text-field--filled', isOutlined && 'mdc-text-field--outlined', dense && 'lmnt-text-field--dense', className])
  }, isFilled && /*#__PURE__*/React.createElement("span", {
    className: "mdc-text-field__ripple"
  }), leadingIcon && !textarea && LeadingIcon(leadingIcon), prefixText && !leadingIcon && !textarea && /*#__PURE__*/React.createElement("span", {
    className: "mdc-text-field__affix mdc-text-field__affix--prefix"
  }, prefixText), /*#__PURE__*/React.createElement(TextfieldSpanShim, {
    wrap: !noResize && textarea
  }, /*#__PURE__*/React.createElement(Tag, _extends({
    "aria-controls": helperTextIdActual,
    "aria-describedby": helperTextIdActual,
    "aria-labelledby": labelIdActual,
    className: clsx('mdc-text-field__input', type === 'color' && 'lmnt-text-field__input--color'),
    disabled: disabled,
    id: idActual,
    type: type,
    onBlur: handleBlur,
    defaultValue: defaultValue,
    placeholder: placeholder || (isEmbedded && label ? label : '') || (dense && label ? label : ''),
    maxLength: currentMaxlength,
    ref: inputRefActual,
    value: value
  }, customProps)), !noResize && Counter(hasCounter, currentMaxlength)), trailingIcon && !textarea && TrailingIcon(trailingIcon), suffixText && !trailingIcon && !textarea && /*#__PURE__*/React.createElement("span", {
    className: "mdc-text-field__affix mdc-text-field__affix--suffix"
  }, suffixText), isOutlined && /*#__PURE__*/React.createElement(NotchedOutline, null, hasLabel && /*#__PURE__*/React.createElement(FloatingLabel, {
    id: labelIdActual,
    htmlFor: idActual
  }, label)), isFilled && hasLabel && /*#__PURE__*/React.createElement(FloatingLabel, {
    id: labelIdActual,
    htmlFor: idActual
  }, label), (isFilled || isEmbedded) && /*#__PURE__*/React.createElement(LineRipple, null)), trailingContent, hasHelperLine && /*#__PURE__*/React.createElement("div", {
    className: "mdc-text-field-helper-line"
  }, helperText && /*#__PURE__*/React.createElement("div", {
    ref: helperTextDomRef,
    id: helperTextIdActual,
    "aria-hidden": helperTextPersistent ? 'false' : 'true',
    className: clsx(['mdc-text-field-helper-text', helperTextPersistent && 'mdc-text-field-helper-text--persistent', helperTextValidation && 'mdc-text-field-helper-text--validation-msg'])
  }, helperText), noResize && Counter(hasCounter, currentMaxlength)), tooltip && /*#__PURE__*/React.createElement(TooltipText, _extends({
    role: "tooltip"
  }, tooltip, {
    ref: tooltipRef,
    text: value
  })));
});
Textfield.displayName = 'Textfield';
Textfield.propTypes = TextfieldPropTypes;
Textfield.defaultProps = TextfieldDefaultProps;

export { Textfield, TextfieldSpanShim };
//# sourceMappingURL=index.es.js.map
