import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { forwardRef, useState, useRef, useMemo, useEffect, useCallback } from 'react';
import { edsRandomId } from '@element/react-common';
import CreatableSelect from 'react-select/creatable';
import { SelectStyles, SelectControlComponent, SelectValueContainer, SelectMultiValueRemove, SelectMultiValue, SelectClearIndicator, SelectIndicatorsContainer, SelectLabel } from '@element/react-select';
import clsx from 'clsx';
import PropTypes from 'prop-types';
import { Textfield } from '@element/react-textfield';
import { Chips } from '@element/react-chips';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const InputChipPropTypes = {
  /**
   * If true, a user can add duplicate chips.
   *
   * Defaults to **false**.
   */
  allowDuplicates: PropTypes.bool,
  /**
   * Available for Uncontained Input Chip, inputs that are anchored show up before the chip list instead of after.
   *
   * Defaults to **false**.
   */
  anchorInput: PropTypes.bool,
  /**
   * Value of the chips array. If the chips array is to be controlled by the parent for two way data binding. this must be defined. If no initial array is needed, set to an empty array
   *
   * Defaults to **[]**.
   */
  chips: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.arrayOf(PropTypes.object)]),
  /**
   * Custom props to be sent to each `Chip`. Props that will be sent through to `Chips` are 'scrollable', `variant`, `onRemoval`, `chipIdField`, `chipKeyField`, `chipLabelField`. See `Chips` docs for more information.
   *
   * Defaults to **{}**.
   */
  chipsProps: PropTypes.object,
  /**
   * If true, the chips will be contained in the `Textfield`.
   *
   * Defaults to **false**.
   */
  contained: PropTypes.bool,
  /**
   * Custom props to be sent to the container. Notes, this is only used when `contained=true`.
   *
   * Defaults to **undefined**.
   */
  containerProps: PropTypes.object,
  /**
   * Prevent the user from interacting with the input.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * Callback fired when a chip is added.
   *
   * Defaults to **null**.
   */
  onAdd: PropTypes.func,
  /**
   * What the input value will be set to after chip is added.
   *
   * Defaults to **empty string**.
   */
  resetValue: PropTypes.string,
  /**
   * Custom props to be sent to the `Textfield`. See `Textfield` docs for more information.
   *
   * Defaults to **{}**.
   */
  textfieldProps: PropTypes.object
};
const InputChipDefaultProps = {
  allowDuplicates: false,
  anchorInput: false,
  chips: [],
  chipsProps: {},
  contained: false,
  containerProps: undefined,
  disabled: false,
  resetValue: "",
  textfieldProps: {}
};

const dupeText$1 = 'Each entry must be unique.';
const ContainedInputChip = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    allowDuplicates,
    anchorInput,
    chips,
    chipsProps,
    className,
    contained,
    containerProps,
    disabled,
    id,
    onAdd,
    onTrailingIconClick,
    resetValue,
    style,
    textfieldProps,
    ...customProps
  } = props;
  const {
    valid,
    helperText,
    onFocus,
    label,
    variant = 'filled',
    onBlur
  } = textfieldProps;
  const {
    onRemoval,
    chipIdField,
    chipLabelField,
    scrollable
  } = chipsProps;
  const [idActual] = useState(() => id || edsRandomId());
  const [duplicates, setDupe] = useState(false);
  const selectRef = useRef();
  const [controlRect, setControlRect] = useState();
  const [inputValue, setInputValue] = useState(resetValue);
  const [optionChips, setOptionsChips] = useState(() => chips.map(c => {
    if (typeof c === 'string' || typeof c === 'number') return {
      label: c,
      value: c
    };
    if (typeof o !== 'object') {
      return {
        label: c[chipLabelField],
        value: c[chipIdField]
      };
    }
    return null;
  }));
  const [extendedHeight, setSelectExtendedHeight] = useState();
  const [float, setFloat] = useState();
  const [isFocused, setIsFocused] = useState(false);
  const selectId = `${idActual}-select`;
  const containerId = `${idActual}-container`;
  const isOutlined = variant === 'outlined';
  const isValid = useMemo(() => {
    if (!allowDuplicates && duplicates) return false;
    return valid === undefined || valid === null ? true : valid;
  }, [valid, duplicates, allowDuplicates]);
  useEffect(() => {
    setOptionsChips(chips.map(c => {
      if (typeof c === 'string' || typeof c === 'number') return {
        label: c,
        value: c
      };
      if (typeof o !== 'object') {
        return {
          label: c[chipLabelField],
          value: c[chipIdField]
        };
      }
      return null;
    }));
  }, [chips, chipLabelField, chipIdField]);
  const handleBlur = useCallback(e => {
    setIsFocused(false);
    setFloat(!!chips.length || !!selectRef.current.state.value && !!selectRef.current.state.value.length);
    onBlur && onBlur(e);
  }, [chips, onBlur]);
  const handleFocus = useCallback(e => {
    setIsFocused(true);
    setFloat(true);
    onFocus && onFocus(e);
  }, [onFocus]);
  const handleInputChange = useCallback(val => {
    setInputValue(val);
  }, []);
  const helperTextToUse = useMemo(() => !allowDuplicates && duplicates ? `${dupeText$1} ${helperText || ''}` : helperText, [duplicates, helperText, allowDuplicates]);
  const handleChange = useCallback((val, action) => {
    if (action.action === 'remove-value' || action.action === 'pop-value') {
      var _action$removedValue;
      setDupe(false);
      onRemoval((_action$removedValue = action.removedValue) === null || _action$removedValue === void 0 ? void 0 : _action$removedValue.value, 'remove-value');
    }
    if (action.action === 'clear') {
      const removedValues = action.removedValues.map(v => v.value);
      setDupe(false);
      onRemoval(removedValues, 'clear');
    }
  }, [onRemoval]);
  const onKeyPress = useCallback(e => {
    const isDupe = chips.some(c => c === inputValue);
    switch (e.key) {
      case 'Enter':
      case 'Tab':
        if (!inputValue) return;
        if (!allowDuplicates) {
          setDupe(isDupe);
        }
        (!isDupe || allowDuplicates) && onAdd && onAdd(inputValue);
        setInputValue(resetValue);
        e.preventDefault();
        break;
    }
  }, [inputValue, onAdd, resetValue, allowDuplicates, chips]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", _extends({
    ref: externalRef,
    id: `${idActual}-container`,
    className: clsx('lmnt', 'lmnt-input-chip--contained', 'lmnt-select-container', 'lmnt-select--value-display-pills', `lmnt-select--${variant}`, 'lmnt-select', isFocused && 'mdc-select--focused', isOutlined && 'mdc-select--outlined', float && 'lmnt-select-float-label', disabled && 'lmnt-select--is-disabled', scrollable && 'lmnt-select--fixed-height', !isValid && 'mdc-select--invalid', className),
    style: style
  }, containerProps, customProps), /*#__PURE__*/React.createElement(CreatableSelect, {
    ref: selectRef,
    classNamePrefix: "lmnt",
    className: clsx('lmnt-select-inner-container', scrollable && 'lmnt-select--fixed-height'),
    id: `${idActual}`,
    instanceId: `${idActual}`,
    isMulti: true,
    multiSelect: true,
    backspaceRemovesValue: true,
    onChange: handleChange,
    onKeyDown: onKeyPress,
    placeholder: "",
    menuIsOpen: false,
    isClearable: true,
    isDisabled: disabled,
    styles: SelectStyles(),
    onBlur: handleBlur,
    onFocus: handleFocus,
    value: optionChips,
    controlRect: controlRect,
    setControlRect: setControlRect,
    setSelectExtendedHeight: setSelectExtendedHeight,
    extendedHeight: extendedHeight,
    isOutlined: isOutlined,
    variant: variant,
    onInputChange: handleInputChange,
    inputValue: inputValue,
    multiDisplayType: "pills",
    anchorInput: anchorInput,
    valid: isValid,
    components: {
      Control: SelectControlComponent,
      ValueContainer: SelectValueContainer,
      IndicatorSeparator: null,
      DropdownIndicator: null,
      MultiValueRemove: SelectMultiValueRemove,
      MultiValue: SelectMultiValue,
      ClearIndicator: SelectClearIndicator,
      IndicatorsContainer: SelectIndicatorsContainer
    }
  }), /*#__PURE__*/React.createElement(SelectLabel, {
    extendedHeight: extendedHeight,
    label: label,
    isOutlined: isOutlined,
    id: `${idActual}-select-label`,
    selectId: selectId,
    containerId: containerId,
    float: float,
    variant: variant
  })), /*#__PURE__*/React.createElement("p", {
    id: `${idActual}-helper-text`,
    className: clsx('mdc-select-helper-text', !isValid && 'lmnt-helper-text--invalid')
  }, helperTextToUse));
});
ContainedInputChip.displayName = 'InputChip';
ContainedInputChip.propTypes = InputChipPropTypes;
ContainedInputChip.defaultProps = InputChipDefaultProps;

const dupeText = 'Each entry must be unique.';
const UncontainedInputChip = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    allowDuplicates,
    anchorInput,
    chips,
    chipsProps,
    className,
    contained,
    containerProps,
    // unused
    disabled,
    id,
    onAdd,
    onTrailingIconClick,
    resetValue,
    textfieldProps,
    ...customProps
  } = props;
  const {
    valid,
    onChange,
    helperText,
    disabled: textfieldDisabled
  } = textfieldProps;
  const {
    variant,
    onRemoval,
    chipIdField,
    chipKeyField,
    chipLabelField,
    scrollable,
    onUpdateChips,
    disabled: chipsDisabled
  } = chipsProps;
  const [idActual] = useState(() => id || edsRandomId());
  const [value, setValue] = useState('');
  const [duplicates, setDupe] = useState(false);
  const textfieldRef = useRef();
  const helperTextToUse = useMemo(() => duplicates ? `${dupeText} ${helperText || ''}` : helperText, [duplicates, helperText]);
  const isValid = useMemo(() => {
    if (!allowDuplicates && duplicates) return false;
    return valid === undefined || valid === null ? true : valid;
  }, [valid, duplicates, allowDuplicates]);
  const focusInput = useCallback(() => {
    textfieldRef.current.mdc.focus();
  }, []);
  const handleChange = event => {
    const v = event.target.value;
    if (!allowDuplicates) {
      setDupe(chips.some(c => c === v));
    }
    setValue(v);
    onChange && onChange(event);
  };
  const onKeyPress = event => {
    if (!(event.code === 'Enter' || event.key === 'Enter') || !event.target.value || !isValid || duplicates) return;
    onAdd && onAdd(event.target.value, event);
    setValue(resetValue);
  };
  const textInput = /*#__PURE__*/React.createElement(Textfield, _extends({}, textfieldProps, {
    helperTextId: `${idActual}-helperText`,
    labelId: `${idActual}-labelId`,
    ref: textfieldRef,
    id: idActual,
    value: value,
    onChange: handleChange,
    helperTextValidation: true,
    valid: isValid,
    helperText: helperTextToUse,
    containerProps: {
      className: scrollable ? 'mdc-input-chips-scroll' : ''
    },
    onKeyDown: onKeyPress,
    disabled: disabled || textfieldDisabled
  }));
  return (
    /*#__PURE__*/
    /* The <div> element has a child <Textfield> element that allows keyboard interaction */
    /* eslint-disable jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions */
    React.createElement("div", _extends({
      ref: externalRef,
      className: clsx(['mdc-input-chip-container', 'lmnt-input-chip-container', scrollable && 'mdc-text-field--with-scrollable-input-chip', 'mdc-text-field--input-chip', className]),
      onClick: focusInput
    }, customProps), anchorInput && scrollable && textInput, /*#__PURE__*/React.createElement("div", {
      id: `lmnt-chip-input-${idActual}`,
      className: clsx(['mdc-input-chip-set-wrapper', 'lmnt-input-chip-set-wrapper', scrollable && 'mdc-input-chip-set-wrapper-scrollable'])
    }, anchorInput && !scrollable && textInput, /*#__PURE__*/React.createElement(Chips, {
      id: `lmnt-input-chips-${idActual}`,
      variant: variant,
      onRemoval: onRemoval,
      onUpdateChips: onUpdateChips,
      chipIdField: chipIdField,
      chipKeyField: chipKeyField,
      chipLabelField: chipLabelField,
      chips: chips,
      scrollable: scrollable,
      input: true,
      disabled: disabled || chipsDisabled
    }), !anchorInput && !scrollable && textInput), !anchorInput && scrollable && textInput)
  );
});
UncontainedInputChip.displayName = 'InputChip';
UncontainedInputChip.propTypes = InputChipPropTypes;
UncontainedInputChip.defaultProps = InputChipDefaultProps;

const InputChip = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    contained
  } = props;
  if (contained) return /*#__PURE__*/React.createElement(ContainedInputChip, _extends({
    ref: externalRef
  }, props));
  return /*#__PURE__*/React.createElement(UncontainedInputChip, _extends({
    ref: externalRef
  }, props));
});
InputChip.displayName = 'InputChip';
InputChip.propTypes = InputChipPropTypes;
InputChip.defaultProps = InputChipDefaultProps;

export { ContainedInputChip, InputChip, UncontainedInputChip };
//# sourceMappingURL=index.es.js.map
