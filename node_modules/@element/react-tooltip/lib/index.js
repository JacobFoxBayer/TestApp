'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime-corejs3/helpers/extends');
var React = require('react');
var clsx = require('clsx');
var reactCommon = require('@element/react-common');
var shared = require('@element/shared');
var core = require('@popperjs/core');
var PropTypes = require('prop-types');
var reactPortal = require('@element/react-portal');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var _extends__default = /*#__PURE__*/_interopDefault(_extends);
var React__default = /*#__PURE__*/_interopDefault(React);
var clsx__default = /*#__PURE__*/_interopDefault(clsx);
var PropTypes__default = /*#__PURE__*/_interopDefault(PropTypes);

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TooltipPropTypes = {
  /**
   * Accepts any valid markup. This will be rendered before any value set with the `text` prop. For most use-cases use `text`.
   *
   * Defaults to **undefined**.
   */
  children: PropTypes__default["default"].node.isRequired,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes__default["default"].string,
  /**
   * Container display type, inline or block.
   *
   * Defaults to **'inline'**.
   */
  containerType: PropTypes__default["default"].oneOf(["inline", "block"]),
  /**
   * Whether or not the tooltip is hoisted to render outside of the parent element. Useful for when the tooltip needs to render in a parent with `overflow: hidden` ie. a table cell.
   *
   * Defaults to **false**.
   */
  hoisted: PropTypes__default["default"].bool,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes__default["default"].string,
  /**
   * Fired when the trigger is interacted with.
   *
   * Defaults to **null**.
   */
  onClick: PropTypes__default["default"].func,
  /**
   * The DOM element the children will render in. If a string is sent it should be a valid DOM query selector. If one is not sent, Portal will default to `document.body`.
   *
   * Defaults to **'document.body'**.
   */
  portalContainer: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].node]),
  /**
   * Position of tooltip. Options include: 'top', 'left', 'right', and 'bottom'(default).
   *
   * Defaults to **'bottom'**.
   */
  position: PropTypes__default["default"].oneOf(["bottom", "top", "left", "right"]),
  /**
   * string
   *
   * Defaults to **null**.
   */
  text: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].func, PropTypes__default["default"].node]).isRequired,
  /**
   * Custom properties to apply to the hovering element.
   *
   * Defaults to **null**.
   */
  tooltipProps: PropTypes__default["default"].object,
  /**
   * Custom properties to apply to the trigger element.
   *
   * Defaults to **null**.
   */
  triggerProps: PropTypes__default["default"].object
};
const TooltipDefaultProps = {
  children: undefined,
  className: undefined,
  containerType: "inline",
  hoisted: false,
  id: undefined,
  portalContainer: "document.body",
  position: "bottom",
  text: null,
  tooltipProps: null,
  triggerProps: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TooltipTextPropTypes = {
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes__default["default"].string,
  /**
   * Whether or not the tooltip is hoisted to render outside of the parent element. Useful for when the tooltip needs to render in a parent with `overflow: hidden` ie. a table cell.
   *
   * Defaults to **false**.
   */
  hoisted: PropTypes__default["default"].bool,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes__default["default"].string,
  /**
   * The DOM element the children will render in. If a string is sent it should be a valid DOM query selector. If one is not sent, Portal will default to `document.body`.
   *
   * Defaults to **'document.body'**.
   */
  portalContainer: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].node]),
  /**
   * The text to be rendered inside of the Tooltip.
   *
   * Defaults to **null**.
   */
  text: PropTypes__default["default"].oneOfType([PropTypes__default["default"].string, PropTypes__default["default"].func, PropTypes__default["default"].node]).isRequired
};
const TooltipTextDefaultProps = {
  className: undefined,
  hoisted: false,
  id: undefined,
  portalContainer: "document.body",
  text: null
};

const TooltipText = /*#__PURE__*/React.forwardRef((props, externalRef) => {
  const {
    className,
    hoisted,
    id,
    portalContainer,
    text,
    ...tooltipProps
  } = props;
  const [idActual] = React.useState(() => id || shared.edsRandomId());
  const tooltipRef = React.useRef();
  React.useImperativeHandle(externalRef, () => tooltipRef.current, []);
  const classNames = React.useMemo(() => clsx__default["default"](['lmnt', className, 'lmnt-tooltip__text-content', 'mdc-typography--caption']), [className]);
  return /*#__PURE__*/React__default["default"].createElement(reactPortal.Portal, {
    disabled: !hoisted,
    container: portalContainer
  }, /*#__PURE__*/React__default["default"].createElement("div", _extends__default["default"]({
    role: "tooltip",
    id: idActual,
    className: classNames
  }, tooltipProps, {
    ref: tooltipRef
  }), text));
});
TooltipText.displayName = 'TooltipText';
TooltipText.propTypes = TooltipTextPropTypes;
TooltipText.defaultProps = TooltipTextDefaultProps;

const Tooltip = /*#__PURE__*/React.forwardRef((props, externalRef) => {
  const {
    children,
    className,
    containerType,
    hoisted,
    id,
    onClick,
    portalContainer,
    position,
    text,
    tooltipProps,
    triggerProps,
    ...customProps
  } = props;
  const triggerRef = React.useRef();
  const tooltipRef = React.useRef();
  const popperRef = React.useRef();
  React.useImperativeHandle(externalRef, () => tooltipRef.current, []);
  const [idActual] = React.useState(() => id || shared.edsRandomId());
  const handleClick = React.useCallback(() => {
    onClick === null || onClick === void 0 ? void 0 : onClick();
  }, [onClick]);
  const handleKeyPress = React.useCallback(e => {
    if (e.key === 'Enter') onClick === null || onClick === void 0 ? void 0 : onClick();
  }, [onClick]);
  reactCommon.useIsomorphicLayoutEffect(() => {
    const modifiers = [{
      name: 'flip',
      options: {
        enabled: true,
        padding: {
          bottom: 32,
          top: 32
        }
      }
    }];
    if (!hoisted) {
      modifiers.push({
        name: 'offset',
        options: {
          offset: [0, 12]
        }
      });
    } else {
      modifiers.push({
        name: 'offset',
        options: {
          offset: [0, 6]
        }
      });
    }
    // HACK: workaround for jsdom issue when running in a unit test
    if (triggerRef.current && tooltipRef.current) {
      popperRef.current = core.createPopper(triggerRef.current, tooltipRef.current, {
        placement: position,
        modifiers
      });
    }
    return () => {
      var _popperRef$current;
      (_popperRef$current = popperRef.current) === null || _popperRef$current === void 0 ? void 0 : _popperRef$current.destroy();
    };
  }, [position, hoisted]);
  const showTooltip = React.useCallback(() => {
    var _tooltipRef$current, _popperRef$current2, _popperRef$current3;
    (_tooltipRef$current = tooltipRef.current) === null || _tooltipRef$current === void 0 ? void 0 : _tooltipRef$current.setAttribute('data-show', '');
    (_popperRef$current2 = popperRef.current) === null || _popperRef$current2 === void 0 ? void 0 : _popperRef$current2.setOptions(options => ({
      ...options,
      modifiers: [...options.modifiers, {
        name: 'eventListeners',
        enabled: true
      }]
    }));
    (_popperRef$current3 = popperRef.current) === null || _popperRef$current3 === void 0 ? void 0 : _popperRef$current3.update();
  }, []);
  const hideTooltip = React.useCallback(() => {
    var _tooltipRef$current2, _popperRef$current4;
    (_tooltipRef$current2 = tooltipRef.current) === null || _tooltipRef$current2 === void 0 ? void 0 : _tooltipRef$current2.removeAttribute('data-show');
    (_popperRef$current4 = popperRef.current) === null || _popperRef$current4 === void 0 ? void 0 : _popperRef$current4.setOptions(options => ({
      ...options,
      modifiers: [...options.modifiers, {
        name: 'eventListeners',
        enabled: false
      }]
    }));
  }, []);
  const isReactFragment = React.useCallback(() => {
    const el = children;
    if (el.type) {
      return el.type === React.Fragment;
    }
    return el === React.Fragment;
  }, [children]);
  React.useEffect(() => {
    const validationWarning = `Tooltips should only include short text for additional context and should not exceed three lines visually. (Toolitip ID ${idActual}).`;
    text && text.length > 100 && reactCommon.edsWarning(validationWarning);
  }, [text, idActual]);
  const ChildrenRendered = React.useMemo(
  // eslint-disable-next-line react/no-unstable-nested-components
  () => () => {
    if (!children) return null;
    if (typeof children === 'string' || isReactFragment(children)) return /*#__PURE__*/React__default["default"].createElement("span", {
      "aria-describedby": idActual
    }, children);
    return reactCommon.addProps(children, {
      'aria-describedby': idActual
    });
  }, [children, idActual, isReactFragment]);
  const clickProps = onClick ? {
    tabIndex: 0,
    role: onClick ? 'button' : 'note',
    onKeyPress: handleKeyPress,
    onClick: handleClick
  } : {};
  return /*#__PURE__*/React__default["default"].createElement("span", _extends__default["default"]({
    className: clsx__default["default"]('lmnt lmnt-tooltip', containerType === 'block' ? 'lmnt-tooltip--block' : 'lmnt-tooltip--inline')
  }, clickProps, customProps), /*#__PURE__*/React__default["default"].createElement("span", _extends__default["default"]({
    className: clsx__default["default"]('lmnt-tooltip__content', containerType === 'block' ? 'lmnt-tooltip--block' : 'lmnt-tooltip--inline')
  }, triggerProps, {
    ref: triggerRef,
    onMouseEnter: showTooltip,
    onFocus: showTooltip,
    onMouseLeave: hideTooltip,
    onBlur: hideTooltip
  }), /*#__PURE__*/React__default["default"].createElement(ChildrenRendered, null)), text && /*#__PURE__*/React__default["default"].createElement(TooltipText, _extends__default["default"]({
    hoisted: hoisted,
    portalContainer: portalContainer,
    role: "tooltip",
    id: idActual,
    className: className
  }, tooltipProps, {
    ref: tooltipRef,
    text: text
  })));
});
Tooltip.displayName = 'Tooltip';
Tooltip.propTypes = TooltipPropTypes;
Tooltip.defaultProps = TooltipDefaultProps;

exports.Tooltip = Tooltip;
exports.TooltipText = TooltipText;
//# sourceMappingURL=index.js.map
