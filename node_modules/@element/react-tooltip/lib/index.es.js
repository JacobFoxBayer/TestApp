import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { forwardRef, useState, useRef, useImperativeHandle, useMemo, useCallback, Fragment, useEffect } from 'react';
import clsx from 'clsx';
import { useIsomorphicLayoutEffect, edsWarning, addProps } from '@element/react-common';
import { edsRandomId } from '@element/shared';
import { createPopper } from '@popperjs/core';
import PropTypes from 'prop-types';
import { Portal } from '@element/react-portal';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TooltipPropTypes = {
  /**
   * Accepts any valid markup. This will be rendered before any value set with the `text` prop. For most use-cases use `text`.
   *
   * Defaults to **undefined**.
   */
  children: PropTypes.node.isRequired,
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Container display type, inline or block.
   *
   * Defaults to **'inline'**.
   */
  containerType: PropTypes.oneOf(["inline", "block"]),
  /**
   * Whether or not the tooltip is hoisted to render outside of the parent element. Useful for when the tooltip needs to render in a parent with `overflow: hidden` ie. a table cell.
   *
   * Defaults to **false**.
   */
  hoisted: PropTypes.bool,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * Fired when the trigger is interacted with.
   *
   * Defaults to **null**.
   */
  onClick: PropTypes.func,
  /**
   * The DOM element the children will render in. If a string is sent it should be a valid DOM query selector. If one is not sent, Portal will default to `document.body`.
   *
   * Defaults to **'document.body'**.
   */
  portalContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * Position of tooltip. Options include: 'top', 'left', 'right', and 'bottom'(default).
   *
   * Defaults to **'bottom'**.
   */
  position: PropTypes.oneOf(["bottom", "top", "left", "right"]),
  /**
   * string
   *
   * Defaults to **null**.
   */
  text: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.node]).isRequired,
  /**
   * Custom properties to apply to the hovering element.
   *
   * Defaults to **null**.
   */
  tooltipProps: PropTypes.object,
  /**
   * Custom properties to apply to the trigger element.
   *
   * Defaults to **null**.
   */
  triggerProps: PropTypes.object
};
const TooltipDefaultProps = {
  children: undefined,
  className: undefined,
  containerType: "inline",
  hoisted: false,
  id: undefined,
  portalContainer: "document.body",
  position: "bottom",
  text: null,
  tooltipProps: null,
  triggerProps: null
};

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const TooltipTextPropTypes = {
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Whether or not the tooltip is hoisted to render outside of the parent element. Useful for when the tooltip needs to render in a parent with `overflow: hidden` ie. a table cell.
   *
   * Defaults to **false**.
   */
  hoisted: PropTypes.bool,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * The DOM element the children will render in. If a string is sent it should be a valid DOM query selector. If one is not sent, Portal will default to `document.body`.
   *
   * Defaults to **'document.body'**.
   */
  portalContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  /**
   * The text to be rendered inside of the Tooltip.
   *
   * Defaults to **null**.
   */
  text: PropTypes.oneOfType([PropTypes.string, PropTypes.func, PropTypes.node]).isRequired
};
const TooltipTextDefaultProps = {
  className: undefined,
  hoisted: false,
  id: undefined,
  portalContainer: "document.body",
  text: null
};

const TooltipText = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    className,
    hoisted,
    id,
    portalContainer,
    text,
    ...tooltipProps
  } = props;
  const [idActual] = useState(() => id || edsRandomId());
  const tooltipRef = useRef();
  useImperativeHandle(externalRef, () => tooltipRef.current, []);
  const classNames = useMemo(() => clsx(['lmnt', className, 'lmnt-tooltip__text-content', 'mdc-typography--caption']), [className]);
  return /*#__PURE__*/React.createElement(Portal, {
    disabled: !hoisted,
    container: portalContainer
  }, /*#__PURE__*/React.createElement("div", _extends({
    role: "tooltip",
    id: idActual,
    className: classNames
  }, tooltipProps, {
    ref: tooltipRef
  }), text));
});
TooltipText.displayName = 'TooltipText';
TooltipText.propTypes = TooltipTextPropTypes;
TooltipText.defaultProps = TooltipTextDefaultProps;

const Tooltip = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    children,
    className,
    containerType,
    hoisted,
    id,
    onClick,
    portalContainer,
    position,
    text,
    tooltipProps,
    triggerProps,
    ...customProps
  } = props;
  const triggerRef = useRef();
  const tooltipRef = useRef();
  const popperRef = useRef();
  useImperativeHandle(externalRef, () => tooltipRef.current, []);
  const [idActual] = useState(() => id || edsRandomId());
  const handleClick = useCallback(() => {
    onClick === null || onClick === void 0 ? void 0 : onClick();
  }, [onClick]);
  const handleKeyPress = useCallback(e => {
    if (e.key === 'Enter') onClick === null || onClick === void 0 ? void 0 : onClick();
  }, [onClick]);
  useIsomorphicLayoutEffect(() => {
    const modifiers = [{
      name: 'flip',
      options: {
        enabled: true,
        padding: {
          bottom: 32,
          top: 32
        }
      }
    }];
    if (!hoisted) {
      modifiers.push({
        name: 'offset',
        options: {
          offset: [0, 12]
        }
      });
    } else {
      modifiers.push({
        name: 'offset',
        options: {
          offset: [0, 6]
        }
      });
    }
    // HACK: workaround for jsdom issue when running in a unit test
    if (triggerRef.current && tooltipRef.current) {
      popperRef.current = createPopper(triggerRef.current, tooltipRef.current, {
        placement: position,
        modifiers
      });
    }
    return () => {
      var _popperRef$current;
      (_popperRef$current = popperRef.current) === null || _popperRef$current === void 0 ? void 0 : _popperRef$current.destroy();
    };
  }, [position, hoisted]);
  const showTooltip = useCallback(() => {
    var _tooltipRef$current, _popperRef$current2, _popperRef$current3;
    (_tooltipRef$current = tooltipRef.current) === null || _tooltipRef$current === void 0 ? void 0 : _tooltipRef$current.setAttribute('data-show', '');
    (_popperRef$current2 = popperRef.current) === null || _popperRef$current2 === void 0 ? void 0 : _popperRef$current2.setOptions(options => ({
      ...options,
      modifiers: [...options.modifiers, {
        name: 'eventListeners',
        enabled: true
      }]
    }));
    (_popperRef$current3 = popperRef.current) === null || _popperRef$current3 === void 0 ? void 0 : _popperRef$current3.update();
  }, []);
  const hideTooltip = useCallback(() => {
    var _tooltipRef$current2, _popperRef$current4;
    (_tooltipRef$current2 = tooltipRef.current) === null || _tooltipRef$current2 === void 0 ? void 0 : _tooltipRef$current2.removeAttribute('data-show');
    (_popperRef$current4 = popperRef.current) === null || _popperRef$current4 === void 0 ? void 0 : _popperRef$current4.setOptions(options => ({
      ...options,
      modifiers: [...options.modifiers, {
        name: 'eventListeners',
        enabled: false
      }]
    }));
  }, []);
  const isReactFragment = useCallback(() => {
    const el = children;
    if (el.type) {
      return el.type === Fragment;
    }
    return el === Fragment;
  }, [children]);
  useEffect(() => {
    const validationWarning = `Tooltips should only include short text for additional context and should not exceed three lines visually. (Toolitip ID ${idActual}).`;
    text && text.length > 100 && edsWarning(validationWarning);
  }, [text, idActual]);
  const ChildrenRendered = useMemo(
  // eslint-disable-next-line react/no-unstable-nested-components
  () => () => {
    if (!children) return null;
    if (typeof children === 'string' || isReactFragment(children)) return /*#__PURE__*/React.createElement("span", {
      "aria-describedby": idActual
    }, children);
    return addProps(children, {
      'aria-describedby': idActual
    });
  }, [children, idActual, isReactFragment]);
  const clickProps = onClick ? {
    tabIndex: 0,
    role: onClick ? 'button' : 'note',
    onKeyPress: handleKeyPress,
    onClick: handleClick
  } : {};
  return /*#__PURE__*/React.createElement("span", _extends({
    className: clsx('lmnt lmnt-tooltip', containerType === 'block' ? 'lmnt-tooltip--block' : 'lmnt-tooltip--inline')
  }, clickProps, customProps), /*#__PURE__*/React.createElement("span", _extends({
    className: clsx('lmnt-tooltip__content', containerType === 'block' ? 'lmnt-tooltip--block' : 'lmnt-tooltip--inline')
  }, triggerProps, {
    ref: triggerRef,
    onMouseEnter: showTooltip,
    onFocus: showTooltip,
    onMouseLeave: hideTooltip,
    onBlur: hideTooltip
  }), /*#__PURE__*/React.createElement(ChildrenRendered, null)), text && /*#__PURE__*/React.createElement(TooltipText, _extends({
    hoisted: hoisted,
    portalContainer: portalContainer,
    role: "tooltip",
    id: idActual,
    className: className
  }, tooltipProps, {
    ref: tooltipRef,
    text: text
  })));
});
Tooltip.displayName = 'Tooltip';
Tooltip.propTypes = TooltipPropTypes;
Tooltip.defaultProps = TooltipDefaultProps;

export { Tooltip, TooltipText };
//# sourceMappingURL=index.es.js.map
