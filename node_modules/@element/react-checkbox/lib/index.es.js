import _extends from '@babel/runtime-corejs3/helpers/extends';
import { FormField } from '@element/react-form-field';
import { InputLabel } from '@element/react-input-label';
import React, { forwardRef, useState, useRef, useImperativeHandle, useCallback, useEffect } from 'react';
import clsx from 'clsx';
import { MDCCheckbox } from '@material/checkbox';
import { edsRandomId } from '@element/shared';
import PropTypes from 'prop-types';
import { deprecatedProp } from '@element/react-common';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const CheckboxPropTypes = {
  /**
   * Aligns checkbox to the right of the label.
   *
   * Defaults to **false**.
   */
  alignEnd: PropTypes.bool,
  /**
   * The current state of the checkbox.
   *
   * Defaults to **null**.
   */
  checked: PropTypes.bool,
  /**
   * @deprecated _Use `label` instead._
   *
   * Alternative to `label`, if both `label` and `children` are set, `label` will take priority. Expects a string, but will accept any valid markup.
   *
   * Defaults to **undefined**.
   */
  children: deprecatedProp(PropTypes.node, "Checkbox", "Use `label` instead."),
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Prevent the user from interacting with the component.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * The label not be displayed, but will still be available to screen readers. This should only be used when the context of the checkbox is clear and understandable. An example use-case could be as a column in a table where the column header specifies the action.
   *
   * Defaults to **false**.
   */
  hideLabel: PropTypes.bool,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * The checkbox will show an indicator if no value (true or false) is set.
   *
   * Defaults to **false**.
   */
  indeterminate: PropTypes.bool,
  /**
   * Display label. The `label` should always be set even when using `hideLabel` - it will be used by screen readers.
   *
   * Defaults to **null**.
   */
  label: PropTypes.string,
  /**
   * Fired when checkbox value is changed
   *
   * Defaults to **null**.
   */
  onChange: PropTypes.func,
  /**
   * Override the default (`primary`) color with the `secondary` color. Most commonly used when the control is placed on a darker surface.
   *
   * Defaults to **'primary'**.
   */
  themeColor: PropTypes.oneOf(["primary", "secondary"]),
  /**
   * Any additional value information to be included with the event.
   *
   * Defaults to **null**.
   */
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.bool, PropTypes.object])
};
const CheckboxDefaultProps = {
  alignEnd: false,
  checked: null,
  children: undefined,
  className: undefined,
  disabled: false,
  hideLabel: false,
  id: undefined,
  indeterminate: false,
  label: null,
  themeColor: "primary",
  value: null
};

const Checkbox = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alignEnd,
    checked,
    children,
    className,
    disabled,
    hideLabel,
    id,
    indeterminate,
    label,
    onChange,
    themeColor,
    value,
    ...customProps
  } = props;
  const [idActual] = useState(() => id || edsRandomId());
  const checkboxRef = useRef();
  const mdcCheckbox = useRef();
  const content = label || children;
  useImperativeHandle(externalRef, () => checkboxRef.current, []);

  // HACK: This is an intentionally temporary variable to track
  // if we have already called handleChange to update checked
  // to the latest value.
  let handleChangeCalled = false;
  let currentChecked = checked;
  const handleChange = useCallback(event => {
    const newChecked = event.target.checked;
    // HACK: Since we potentially have 2 events calling
    // `handleChange` (see note below), we need to make
    // sure we only run it once.
    if (handleChangeCalled && newChecked === currentChecked) return;

    // Dear eslint, I know what I'm doing and it's on purpose.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    handleChangeCalled = true;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    currentChecked = newChecked;
    onChange === null || onChange === void 0 ? void 0 : onChange(currentChecked, event, value);
  }, [onChange]);
  useEffect(() => {
    mdcCheckbox.current = new MDCCheckbox(checkboxRef.current);
    return () => {
      mdcCheckbox.current.destroy();
    };
  }, []);
  useEffect(() => {
    // HACK: We need to make sure we only update when
    // necessary. See notes above and below for more
    // details.
    if (mdcCheckbox.current.checked === checked) return;
    mdcCheckbox.current.checked = checked;
  }, [checked]);
  useEffect(() => {
    if (indeterminate && checked === null) {
      mdcCheckbox.current.indeterminate = true;
    } else {
      mdcCheckbox.current.indeterminate = false;
    }
  }, [checked, indeterminate]);
  const optionalProps = {};
  if (value !== null && value !== undefined) {
    optionalProps.value = value;
  }
  return /*#__PURE__*/React.createElement(FormField, {
    alignEnd: alignEnd,
    input: mdcCheckbox,
    className: "lmnt mdc-touch-target-wrapper"
  }, /*#__PURE__*/React.createElement("div", {
    // onClick={handleChange}
    ref: checkboxRef,
    className: clsx('lmnt mdc-checkbox lmnt-checkbox mdc-checkbox--touch', disabled && 'mdc-checkbox--disabled', themeColor && `lmnt-checkbox--${themeColor}`, className)
  }, /*#__PURE__*/React.createElement("input", _extends({
    id: idActual,
    disabled: disabled,
    type: "checkbox",
    className: "mdc-checkbox__native-control",
    onChange: handleChange
    // HACK: I know what you're thinking: having `onChange` and `onClick` is
    // silly and redundant. However, this is working around a frustrating
    // issue where mdcCheckbox does not fire `onChange` on the first click
    // after being updated programmatically. On the other hand `onClick`
    // always fires.
    //
    // Why not just use `onClick`? Glad you asked. Accessibility. The `onChange`
    // event is fired in more circumstances than just the user clicking on something.
    // Think keyboard navigation, etc. We can just ignore on change, so we use
    // `onClick` as a fallback and add logic to handleChange to avoid a double-fire.
    ,
    onClick: handleChange,
    defaultChecked: checked
  }, optionalProps, customProps)), /*#__PURE__*/React.createElement("div", {
    className: "mdc-checkbox__background"
  }, /*#__PURE__*/React.createElement("svg", {
    className: "mdc-checkbox__checkmark",
    viewBox: "0 0 24 24"
  }, /*#__PURE__*/React.createElement("path", {
    className: "mdc-checkbox__checkmark-path",
    fill: "none",
    stroke: "white",
    d: "M1.73,12.91 8.1,19.28 22.79,4.59"
  })), /*#__PURE__*/React.createElement("div", {
    className: "mdc-checkbox__mixedmark"
  })), /*#__PURE__*/React.createElement("div", {
    className: "mdc-checkbox__ripple"
  })), /*#__PURE__*/React.createElement(InputLabel, {
    hideLabel: hideLabel,
    targetId: idActual,
    className: clsx(disabled && 'lmnt-theme-on-surface-disabled'),
    disabled: disabled
  }, content));
});
Checkbox.displayName = 'Checkbox';
Checkbox.propTypes = CheckboxPropTypes;
Checkbox.defaultProps = CheckboxDefaultProps;

export { Checkbox };
//# sourceMappingURL=index.es.js.map
