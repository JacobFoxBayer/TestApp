import _extends from '@babel/runtime-corejs3/helpers/extends';
import React, { forwardRef, useState, useRef, useImperativeHandle, useEffect } from 'react';
import { MDCRadio } from '@material/radio';
import { FormField } from '@element/react-form-field';
import clsx from 'clsx';
import { InputLabel } from '@element/react-input-label';
import { deprecatedProp, edsRandomId } from '@element/react-common';
import PropTypes from 'prop-types';

/**
 *
 * This file is automatically generated by the Element
 * documentation system. Any modifications to this file
 * will be overwritten!
 *
 */

const RadioPropTypes = {
  /**
   * Aligns radio to the right of the label.
   *
   * Defaults to **false**.
   */
  alignEnd: PropTypes.bool,
  /**
   * Applies selected state when `checked` equals `value` or when `checked` is set to true.
   *
   * Defaults to **null**.
   */
  checked: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),
  /**
   * @deprecated _Use `label` instead._
   *
   * Content to be rendered as the radio label. Can be used instead of `label` to provide more flexibility. Accepts any valid markup. _Warning, if `label` is set, it will be used instead of child content._
   *
   * Defaults to **undefined**.
   */
  children: deprecatedProp(PropTypes.node, "Radio", "Use `label` instead."),
  /**
   * The css class name to be passed through to the component markup.
   *
   * Defaults to **undefined**.
   */
  className: PropTypes.string,
  /**
   * Prevents user for interacting with component.
   *
   * Defaults to **false**.
   */
  disabled: PropTypes.bool,
  /**
   * The label not be displayed, but will still be available to screen readers. This should only be used when the context of the radio button is clear and understandable. An example use-case could be as a column in a table where the column header specifies the action.
   *
   * Defaults to **false**.
   */
  hideLabel: PropTypes.bool,
  /**
   * Randomly generated id. May be overwritten.
   *
   * Defaults to **undefined**.
   */
  id: PropTypes.string,
  /**
   * Display label. The `label` should always be set even when using `hideLabel` - it will be used by screen readers.
   *
   * Defaults to **null**.
   */
  label: PropTypes.string.isRequired,
  /**
   * Name of the radio button group.
   *
   * Defaults to **null**.
   */
  name: PropTypes.string.isRequired,
  /**
   * Fired when value of the radio button is changed.
   *
   * Defaults to **null**.
   */
  onChange: PropTypes.func,
  /**
   * Override the default (`primary`) color with the `secondary` color. Most commonly used when the control is placed on a darker surface.
   *
   * Defaults to **'primary'**.
   */
  themeColor: PropTypes.oneOf(["primary", "secondary"]),
  /**
   * A custom value will be returned as the second parameter of the `change` handler.
   *
   * Defaults to **null**.
   */
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
};
const RadioDefaultProps = {
  alignEnd: false,
  checked: null,
  children: undefined,
  className: undefined,
  disabled: false,
  hideLabel: false,
  id: undefined,
  label: null,
  name: null,
  themeColor: "primary",
  value: null
};

const Radio = /*#__PURE__*/forwardRef((props, externalRef) => {
  const {
    alignEnd,
    checked,
    children,
    className,
    disabled,
    hideLabel,
    id,
    label,
    name,
    onChange,
    themeColor,
    value,
    ...customProps
  } = props;
  const [idActual] = useState(() => id || edsRandomId());
  const radioRef = useRef();
  const mdcRadio = useRef();
  useImperativeHandle(externalRef, () => radioRef.current, []);
  const handleChange = event => {
    if (onChange) {
      onChange(event, value);
      return;
    }
    mdcRadio.current.checked = event.target.checked;
  };
  useEffect(() => {
    mdcRadio.current = MDCRadio.attachTo(radioRef.current);
    return () => {
      var _mdcRadio$current;
      (_mdcRadio$current = mdcRadio.current) === null || _mdcRadio$current === void 0 ? void 0 : _mdcRadio$current.destroy();
    };
  }, [mdcRadio]);
  useEffect(() => {
    mdcRadio.current.value = value;
  }, [value]);
  useEffect(() => {
    mdcRadio.current.checked = checked;
  }, [checked]);
  useEffect(() => {
    mdcRadio.current.disabled = disabled;
  }, [disabled]);
  return /*#__PURE__*/React.createElement(FormField, {
    alignEnd: alignEnd,
    inputRef: mdcRadio
  }, /*#__PURE__*/React.createElement("div", {
    ref: radioRef,
    className: clsx('lmnt mdc-radio lmnt-radio', disabled && 'mdc-radio--disabled', themeColor && `lmnt-radio--${themeColor}`, className, 'mdc-touch-target-wrapper')
  }, /*#__PURE__*/React.createElement("input", _extends({
    id: idActual,
    onChange: handleChange,
    disabled: disabled,
    name: name,
    type: "radio",
    className: "mdc-radio__native-control"
  }, customProps)), /*#__PURE__*/React.createElement("div", {
    className: "mdc-radio__background"
  }, /*#__PURE__*/React.createElement("div", {
    className: "mdc-radio__outer-circle"
  }), /*#__PURE__*/React.createElement("div", {
    className: "mdc-radio__inner-circle"
  })), /*#__PURE__*/React.createElement("div", {
    className: "mdc-radio__ripple"
  })), /*#__PURE__*/React.createElement(InputLabel, {
    hideLabel: hideLabel,
    targetId: idActual,
    className: clsx(disabled && 'lmnt-theme-on-surface-disabled'),
    disabled: disabled
  }, label || children));
});
Radio.displayName = 'Radio';
Radio.propTypes = RadioPropTypes;
Radio.defaultProps = RadioDefaultProps;

export { Radio };
//# sourceMappingURL=index.es.js.map
