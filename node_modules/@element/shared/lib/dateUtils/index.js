import clsx from 'clsx';
import { format, parse, isValid, getDay, add, getDaysInMonth } from 'date-fns';

const getYear = (date, useUtc) =>
    useUtc ? date.getUTCFullYear() : date.getFullYear();

const getMonth = (date, useUtc) =>
    useUtc ? date.getUTCMonth() : date.getMonth();

const getDayOfMonth = (date, useUtc) => {
    const d = date || new Date();
    return useUtc ? d.getUTCDate() : d.getDate();
};

const getDayOfWeek = (date, useUtc) => {
    const d = date || new Date();
    return useUtc ? d.getUTCDay() : d.getDay();
};

const setFullYear = (date, value, useUtc) => {
    const d = new Date(date);
    if (useUtc) d.setUTCFullYear(value);
    else d.setFullYear(value);
    return d;
};

const setMonth = (date, value, useUtc) => {
    const d = new Date(date);
    if (useUtc) d.setUTCMonth(value);
    else d.setMonth(value);
    return d;
};

const setDate = (date, value, useUtc) => {
    const d = new Date(date);
    if (useUtc) d.setUTCDate(value);
    else d.setDate(value);
    return d;
};

const dateWithoutTime = (dateRaw, useUtc) => {
    const date = dateRaw || new Date();
    return useUtc
        ? new Date(
              Date.UTC(
                  date.getUTCFullYear(),
                  date.getUTCMonth(),
                  date.getUTCDate()
              )
          )
        : new Date(date.getFullYear(), date.getMonth(), date.getDate());
};

const compareDates = (date1, date2, useUtc) => {
    const d1 = dateWithoutTime(date1, useUtc);
    const d2 = dateWithoutTime(date2, useUtc);
    return d1.getTime() === d2.getTime();
};

// this is just a passthrough to the date-fns `format()` method
const formatDate = (date, formatString, locale) =>
    format(date, formatString, { locale });

const getCurrentYearBase = () =>
    (Math.ceil(new Date().getFullYear() / 100) - 1) * 100;

// To make entering an age easier (which will often extend into the previous century),
// we should anticipate and adjust the year. This is done by calculating a cutoff year based on the current date and
// an arbitrary, but configurable age (say 76), use that as the point with which to roll back the year. For example
// typing `02` should become `2002` while typing `76` should become `1976`.
//
// This may be undesirable for a datepicker doing long forecasts, so passing a cutoff year of 0 will defeat the behavior.
//
// maybe it's a dumb idea, but I got annoyed when trying to type in my birthday ðŸ™ƒ
//
const getSlidingCutoffYear = previousCenturyOffset =>
    new Date(new Date().getFullYear() - previousCenturyOffset, 1, 1).getYear();

// Typed date parsing breaks as years are partially, forcing them through a new date works around the issue. We can also
// make adjustments for century as prescribed.
const fixInvalidTypedYear = (val, centurySlidingOffset) => {
    const reference = val || new Date();
    const century = getCurrentYearBase();
    let year = reference.getFullYear();
    const month = reference.getMonth();
    const date = reference.getDate();

    if (year < 1000)
        year =
            centurySlidingOffset &&
            year >= getSlidingCutoffYear(centurySlidingOffset)
                ? year + century - 100
                : year + century;

    return new Date(year, month, date);
};

const parseDate = (
    value,
    formats,
    outputFormat,
    locale,
    centurySlidingOffset
) => {
    const initialParsed = parse(value, outputFormat, new Date(), { locale });
    if (isValid(initialParsed))
        return fixInvalidTypedYear(initialParsed, centurySlidingOffset);

    for (let i = 0; i < formats.length; i += 1) {
        const parsed = parse(value, formats[i], new Date(), { locale });
        if (isValid(parsed))
            return fixInvalidTypedYear(parsed, centurySlidingOffset);
    }
    return null;
};

const isValidDate = (date, formats, locale) => {
    if (typeof date === 'string')
        return isValid(parseDate(date, formats, locale));
    return isValid(date);
};

const matchMonthByVal = (val, months) =>
    (val || val === 0) && months ? months.find(m => m.value === val) : null;

const matchMonthByLabel = (val, months) =>
    (val || val === 0) && months ? months.find(m => m.label === val) : null;

const firstOfMonth = (val, useUtc) => {
    const date = val || new Date();
    return useUtc
        ? new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1))
        : new Date(date.getFullYear(), date.getMonth(), 1);
};

const createArrayWithRange = range =>
    // eslint-disable-next-line prefer-spread
    Array.apply(null, { length: range }).map(Number.call, Number);

const getBlankDays = ({ visibleMonthYear, useUtc, mondayFirst }) => {
    const adjustedDate = firstOfMonth(visibleMonthYear, useUtc);
    const dayOfWeek = getDayOfWeek(adjustedDate, useUtc);

    if (mondayFirst) {
        return dayOfWeek > 0
            ? createArrayWithRange(dayOfWeek - 1)
            : createArrayWithRange(6);
    }
    return createArrayWithRange(dayOfWeek);
};

const isSelectedDate = (dObj, { selectedDate, useUtc }) =>
    selectedDate && compareDates(selectedDate, dObj, useUtc);

const isInRange = (date, fromRaw, toRaw, useUtc) => {
    if (!date || !(fromRaw || toRaw)) return false;

    // throw away time
    const from = fromRaw ? dateWithoutTime(fromRaw, useUtc) : undefined;
    const to = toRaw ? dateWithoutTime(toRaw, useUtc) : undefined;

    // check entire range
    if (to && from) return date >= from && date <= to;

    // check if from infinity `to` date is implied
    if (!from && to) return date <= to;

    // check if `from` date to infinity is implied
    if (!to && from) return date >= from;

    return false;
};

// This is the shared logic for isDisabledDate and isHighlightedDate
const isDateWithinSpecifiedConfig = (
    dateRaw,
    config,
    minDate,
    maxDate,
    useUtc
) => {
    if (!dateRaw) return false;

    // throw away time
    const date = dateWithoutTime(dateRaw, useUtc);

    if (minDate && date <= minDate) return false;
    if (maxDate && date >= maxDate) return false;

    if (!config) return false;

    if (config.dates && config.dates.some(d => compareDates(date, d, useUtc)))
        return true;

    if (isInRange(date, config.from, config.to, useUtc)) return true;

    if (
        config.ranges &&
        config.ranges.some(range =>
            isInRange(date, range.from, range.to, useUtc)
        )
    )
        return true;

    if (config.days && config.days.indexOf(getDay(date, useUtc)) > -1)
        return true;

    if (
        config.daysOfMonth &&
        config.daysOfMonth.indexOf(getDayOfMonth(date, useUtc)) > -1
    )
        return true;

    if (
        config.customPredictor &&
        typeof config.customPredictor === 'function' &&
        config.customPredictor(date)
    )
        return true;

    return false;
};

const incrementMonth = (incrementBy, startDate) =>
    add(startDate, { months: incrementBy });

const isDisabledDate = isDateWithinSpecifiedConfig;

// Whether a day is highlighted (only if it is not disabled already except when highlighted.includeDisabled is true)
const isHighlightedDate = (
    date,
    highlightedDates,
    isDisabled,
    minDate,
    maxDate,
    useUtc
) => {
    if (!highlightedDates) return false;

    const { includeDisabled } = highlightedDates;

    if (includeDisabled && isDisabled) return false;

    return isDateWithinSpecifiedConfig(
        date,
        highlightedDates,
        minDate,
        maxDate,
        useUtc
    );
};

const getCalendarDateObject = (
    day,
    selectedDate,
    disabledDates,
    highlightedDates,
    minDate,
    maxDate,
    useUtc
) => {
    const isDisabled = isDisabledDate(
        day,
        disabledDates,
        minDate,
        maxDate,
        useUtc
    );
    const dayOfWeek = getDayOfWeek(day, useUtc);

    return {
        date: getDayOfMonth(day, useUtc),
        dayOfWeek,
        timestamp: day.getTime(),
        isSelected: isSelectedDate(day, { useUtc, selectedDate }),
        isDisabled,
        isHighlighted: !!isHighlightedDate(
            day,
            highlightedDates,
            isDisabled,
            minDate,
            maxDate,
            useUtc
        ),
        isToday: compareDates(day, new Date(), useUtc),
        isWeekend: dayOfWeek === 0 || dayOfWeek === 6,
        isSaturday: dayOfWeek === 6,
        isSunday: dayOfWeek === 0
    };
};

// TODO: fixed start boundary
const setHighlightBoundaries = days => {
    const output = [...days];
    let lastDayIsHighlighted = false;
    for (let i = 0; i < days.length; i += 1) {
        const day = output[i];
        day.isHighlightStart = !lastDayIsHighlighted;
        day.isHighlightEnd =
            output.length === i + 1 || !output[i + 1].isHighlighted;
        lastDayIsHighlighted = day.isHighlighted;
    }
    return output;
};

const getCalendarDays = ({
    disabledDates,
    highlightedDates,
    maxDate,
    minDate,
    selectedDate,
    useUtc,
    visibleMonthYear
}) => {
    const days = [];
    // set up a new date object to the beginning of the current 'page'
    let dt = firstOfMonth(visibleMonthYear, useUtc);

    const monthDays = getDaysInMonth(dt);

    for (let i = 0; i < monthDays; i += 1) {
        days.push(
            getCalendarDateObject(
                dt,
                selectedDate,
                disabledDates,
                highlightedDates,
                minDate,
                maxDate,
                useUtc
            )
        );
        dt = setDate(dt, getDayOfMonth(dt, useUtc) + 1, useUtc);
    }
    return setHighlightBoundaries(days);
};

const getCalendarDaysOfWeek = (locale, mondayFirst) => {
    const daysInOrder = mondayFirst
        ? [1, 2, 3, 4, 5, 0]
        : [0, 1, 2, 3, 4, 5, 6];

    return daysInOrder.map(i => ({
        label: locale.localize.day(i, { width: 'abbreviated' }),
        value: i
    }));
};

const getQuickSelectYears = ({
    maxQuickSelectYear,
    minQuickSelectYear,
    useUtc,
    visibleMonthYear
}) => {
    const selectedYear = getYear(visibleMonthYear, useUtc);
    const start = minQuickSelectYear || selectedYear - 10;
    const end = maxQuickSelectYear || selectedYear + 10;

    const ys = [];
    for (let year = start; year <= end; year += 1) {
        ys.push(year);
    }
    return ys;
};

const getQuickSelectMonths = (locale, fullMonthName) =>
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(i => ({
        label: locale.localize.month(i, {
            width: fullMonthName ? 'long' : 'narrow'
        }),
        value: i
    }));

const yearsMatch = (date1, date2, useUtc) =>
    getYear(date1, useUtc) === getYear(date2, useUtc);

const some = (array, predicate) => {
    if (!array || !(array instanceof Array)) return false;
    return array.some(predicate);
};

const find = (array, predicate) => {
    if (!array || !(array instanceof Array)) return false;
    return array.find(predicate) || {};
};

const isPreviousMonthDisabled = (
    disableChangeMonth,
    disableChangeYear,
    disabledDates,
    useUtc,
    visibleMonthYear
) => {
    if (disableChangeMonth || !visibleMonthYear) return true;

    const beginningOfCurrentMonth = new Date(
        visibleMonthYear.getFullYear(),
        visibleMonthYear.getMonth(),
        1
    );
    const lastDayOfPrevMonth = add(beginningOfCurrentMonth, { days: -1 });

    // make sure changing the month does not change the year if disableChangeYear is true
    if (
        disableChangeYear &&
        !yearsMatch(visibleMonthYear, lastDayOfPrevMonth, useUtc)
    )
        return true;

    if (
        // check if there are no disabled dates
        !disabledDates ||
        // check if no `to` dates
        (!disabledDates.to &&
            !some(disabledDates.ranges, range => range.to && !range.from)) ||
        // any finite range should not be disabled from changing months
        (disabledDates.from && disabledDates.to)
    )
        return false;

    return (
        // if the previous month exists entirely within the `to` date return true
        lastDayOfPrevMonth <= disabledDates.to ||
        // if the previous month exists entirely within the `to`of a "ranges" date return true
        lastDayOfPrevMonth <=
            find(disabledDates.ranges, range => range.to && !range.from).to
    );
};

const isNextMonthDisabled = (
    disableChangeMonth,
    disableChangeYear,
    disabledDates,
    useUtc,
    visibleMonthYear
) => {
    if (disableChangeMonth || !visibleMonthYear) return true;

    const nextMonth = add(visibleMonthYear, { months: 1 });
    const firstDayOfNextMonth = new Date(
        nextMonth.getFullYear(),
        nextMonth.getMonth(),
        1
    );

    // make sure changing the month does not allow changing the year if disableChangeYear is true
    if (
        disableChangeYear &&
        !yearsMatch(visibleMonthYear, firstDayOfNextMonth, useUtc)
    )
        return true;

    if (
        // check if there are no disabled dates
        !disabledDates ||
        // check if no `from` dates
        (!disabledDates.from &&
            !some(disabledDates.ranges, range => range.from && !range.to)) ||
        // any finite range should not be disabled from changing months
        (disabledDates.from && disabledDates.to)
    )
        return false;

    // if the previous month exists entirely within the `to` date return true
    return (
        firstDayOfNextMonth >= disabledDates.from ||
        // if the previous month exists entirely within the `to`of a "ranges" date return true
        firstDayOfNextMonth >=
            find(disabledDates.ranges, range => range.from && !range.to).from
    );
};

const getVariant = (primary, filled, secondary, outlined, variant) => {
    if (primary || filled) return 'filled';
    if (secondary || outlined) return 'outlined';
    return variant;
};

const getReadonly = (typeable, readOnly) =>
    typeable === false ? true : readOnly;

const getContainerClasses = (className, props) =>
    clsx(
        'lmnt',
        'lmnt-datepicker',
        props &&
            props.textfieldProps &&
            props.textfieldProps.fullWidth &&
            'lmnt-datepicker--fullWidth',
        className
    );

const getCalendarContainerClasses = (floating, sideContent, className) =>
    clsx(
        'lmnt',
        'lmnt-datepicker__calendar',
        floating && 'lmnt-datepicker--floating',
        sideContent && 'lmnt-datepicker__calendar--with-side-content',
        className
    );

const getCalendarDayClasses = day =>
    clsx(
        'lmnt-datepicker__cell',
        'lmnt-datepicker__cell--day',
        day.isSelected && 'lmnt-datepicker__cell--selected',
        day.isDisabled && 'lmnt-datepicker__cell--disabled',
        day.isToday && 'lmnt-datepicker__cell--today',
        day.isWeekend && 'lmnt-datepicker__cell--weekend',
        day.isSaturday && 'lmnt-datepicker__cell--sat',
        day.isSunday && 'lmnt-datepicker__cell--sun',
        day.isHighlighted && 'lmnt-datepicker__cell--highlighted',
        day.isHighlighted &&
            day.isHighlightStart &&
            'lmnt-datepicker__cell--highlight-start',
        day.isHighlighted &&
            day.isHighlightEnd &&
            'lmnt-datepicker__cell--highlight-end'
    );

const getInitialDate = (openDate, selectedDate, useUtc) =>
    setDate(openDate || selectedDate || new Date(), 1, useUtc) || new Date();

const getVisibleMonthYear = (date, useUtc) => {
    if (!date) return firstOfMonth(null, useUtc);
    return firstOfMonth(date, useUtc);
};

export { compareDates, createArrayWithRange, dateWithoutTime, firstOfMonth, fixInvalidTypedYear, formatDate, getBlankDays, getCalendarContainerClasses, getCalendarDateObject, getCalendarDayClasses, getCalendarDays, getCalendarDaysOfWeek, getContainerClasses, getCurrentYearBase, getDayOfMonth, getDayOfWeek, getInitialDate, getMonth, getQuickSelectMonths, getQuickSelectYears, getReadonly, getSlidingCutoffYear, getVariant, getVisibleMonthYear, getYear, incrementMonth, isDateWithinSpecifiedConfig, isDisabledDate, isHighlightedDate, isInRange, isNextMonthDisabled, isPreviousMonthDisabled, isSelectedDate, isValidDate, matchMonthByLabel, matchMonthByVal, parseDate, setDate, setFullYear, setHighlightBoundaries, setMonth, yearsMatch };
//# sourceMappingURL=index.js.map
